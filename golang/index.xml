<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go 语言设计与实现</title><link>/golang/</link><description>Recent content on Go 语言设计与实现</description><generator>Hugo -- gohugo.io</generator><language>cn</language><atom:link href="/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 语言 Channel 实现原理精要</title><link>/golang/docs/part3-runtime/ch06-concurrency/golang-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch06-concurrency/golang-channel/</guid><description>6.4 Channel # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 作为 Go 核心的数据结构和 Goroutine 之间的通信方式，Channel 是支撑 Go 语言高性能并发编程模型的重要结构本节会介绍管道 Channel 的设计原理、数据结构和常见操作，例如 Channel 的创建、发送、接收和关闭。虽然 Channel 与关键字 range 和 select 的关系紧密，但是因为在前面的两节中已经分析了 Channel 在不同的控制结构中组合使用时的现象，所以这里也就不会再次介绍了。
6.4.1 设计原理 # Go 语言中最常见的、也是经常被人提及的设计模式就是：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存。在很多主流的编程语言中，多个线程传递数据的方式一般都是共享内存，为了解决线程竞争，我们需要限制同一时间能够读写这些变量的线程数量，然而这与 Go 语言鼓励的设计并不相同。
图 6-17 多线程使用共享内存传递数据
虽然我们在 Go 语言中也能使用共享内存加互斥锁进行通信，但是 Go 语言提供了一种不同的并发模型，即通信顺序进程（Communicating sequential processes，CSP）1。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据。
图 6-18 Goroutine 使用 Channel 传递数据
上图中的两个 Goroutine，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。</description></item><item><title>Go 语言 for 和 range 的实现</title><link>/golang/docs/part2-foundation/ch05-keyword/golang-for-range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch05-keyword/golang-for-range/</guid><description>5.1 for 和 range # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等集合类型。本节将深入分析 Go 语言的两种循环，也就是 for 循环和 for-range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理，
for 循环能够将代码中的数据和逻辑分离，让同一份代码能够多次复用相同的处理逻辑。我们先来看一下 Go 语言 for 循环对应的汇编代码，下面是一段经典的三段式循环的代码，我们将它编译成汇编指令：
package main func main() { for i := 0; i &amp;lt; 10; i++ { println(i) } } &amp;#34;&amp;#34;.main STEXT size=98 args=0x0 locals=0x18 00000 (main.go:3) TEXT &amp;#34;&amp;#34;.main(SB), $24-0 ... 00029 (main.go:3) XORL AX, AX ;; i := 0 00031 (main.</description></item><item><title>Go 语言 HTTP 标准库的实现原理</title><link>/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/</guid><description>9.2 HTTP # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了互联网的数据传输的核心1。在过去几年的时间里，HTTP/2 和 HTTP/3 也对现有的协议进行了更新，提供更加安全和快速的传输功能。多数的编程语言都会在标准库中实现 HTTP/1.1 和 HTTP/2.0 已满足工程师的日常开发需求，今天要介绍的 Go 语言的网络库也实现了这两个大版本的 HTTP 协议。
9.2.1 设计原理 # HTTP 协议是应用层协议，在通常情况下我们都会使用 TCP 作为底层的传输层协议传输数据包，但是 HTTP/3 在 UDP 协议上实现了新的传输层协议 QUIC 并使用 QUIC 传输数据，这也意味着 HTTP 既可以跑在 TCP 上，也可以跑在 UDP 上。
图 9-5 HTTP 与传输层协议
Go 语言标准库通过 net/http 包提供 HTTP 的客户端和服务端实现，在分析内部的实现原理之前，我们先来了解一下 HTTP 协议相关的一些设计以及标准库内部的层级结构和模块之间的关系。
请求和响应 # HTTP 协议中最常见的概念是 HTTP 请求与响应，我们可以将它们理解成客户端和服务端之间传递的消息，客户端向服务端发送 HTTP 请求，服务端收到 HTTP 请求后会做出计算后以 HTTP 响应的形式发送给客户端。</description></item><item><title>Go 语言 JSON 的实现原理</title><link>/golang/docs/part4-advanced/ch09-stdlib/golang-json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part4-advanced/ch09-stdlib/golang-json/</guid><description>9.1 JSON # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 JSON（JavaScript 对象表示，JavaScript Object Notation）作为一种轻量级的数据交换格式1，在今天几乎占据了绝大多数的市场份额。虽然与更紧凑的数据交换格式相比，它的序列化和反序列化性能不足，但是 JSON 提供了良好的可读性与易用性，在不追求极致机制性能的情况下，使用 JSON 作为序列化格式是一种非常好的选择。
9.1.1 设计原理 # 几乎所有的现代编程语言都会将处理 JSON 的函数直接纳入标准库，Go 语言也不例外，它通过 encoding/json 对外提供标准的 JSON 序列化和反序列化方法，即 encoding/json.Marshal 和 encoding/json.Unmarshal，它们也是包中最常用的两个方法。
图 9-1 序列化和反序列化
序列化和反序列化的开销完全不同，JSON 反序列化的开销是序列化开销的好几倍，相信这背后的原因也非常好理解。Go 语言中的 JSON 序列化过程不需要被序列化的对象预先实现任何接口，它会通过反射获取结构体或者数组中的值并以树形的结构递归地进行编码，标准库也会根据 encoding/json.Unmarshal 中传入的值对 JSON 进行解码。
Go 语言 JSON 标准库编码和解码的过程大量地运用了反射这一特性，你会在本节的后半部分看到大量的反射代码，这一小节就不过多介绍了。我们在这里会简单介绍 JSON 标准库中的接口和标签，这是它为开发者提供的为数不多的影响编解码过程的接口。
接口 # JSON 标准库中提供了 encoding/json.Marshaler 和 encoding/json.Unmarshaler 两个接口分别可以影响 JSON 的序列化和反序列化结果：
type Marshaler interface { MarshalJSON() ([]byte, error) } type Unmarshaler interface { UnmarshalJSON([]byte) error } 在 JSON 序列化和反序列化的过程中，它会使用反射判断结构体类型是否实现了上述接口，如果实现了上述接口就会优先使用对应的方法进行编码和解码操作，除了这两个方法之外，Go 语言其实还提供了另外两个用于控制编解码结果的方法，即 encoding.</description></item><item><title>Go 语言 panic 和 recover 的原理</title><link>/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/</guid><description>5.4 panic 和 recover # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数，也提供了互补的功能。
图 5-12 panic 触发的递归延迟调用
panic 能够改变程序的控制流，调用 panic 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 defer； recover 可以中止 panic 造成的程序崩溃。它是一个只能在 defer 中发挥作用的函数，在其他作用域中调用不会发挥作用； 5.4.1 现象 # 我们先通过几个例子了解一下使用 panic 和 recover 关键字时遇到的现象，部分现象也与上一节分析的 defer 关键字有关：
panic 只会触发当前 Goroutine 的 defer； recover 只有在 defer 中调用才会生效； panic 允许在 defer 中嵌套多次调用； 跨协程失效 # 首先要介绍的现象是 panic 只会触发当前 Goroutine 的延迟函数调用，我们可以通过如下所示的代码了解该现象：</description></item><item><title>Go 语言 select 的实现原理</title><link>/golang/docs/part2-foundation/ch05-keyword/golang-select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch05-keyword/golang-select/</guid><description>5.2 select # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 select 是操作系统中的系统调用，我们经常会使用 select、poll 和 epoll 等函数构建 I/O 多路复用模型提升程序的性能。Go 语言的 select 与操作系统中的 select 比较相似，本节会介绍 Go 语言 select 关键字常见的现象、数据结构以及实现原理。
C 语言的 select 系统调用可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 select 也能够让 Goroutine 同时等待多个 Channel 可读或者可写，在多个文件或者 Channel状态改变之前，select 会一直阻塞当前线程或者 Goroutine。
图 5-5 Select 和 Channel
select 是与 switch 相似的控制结构，与 switch 不同的是，select 中虽然也有多个 case，但是这些 case 中的表达式必须都是 Channel 的收发操作。下面的代码就展示了一个包含 Channel 收发操作的 select 结构：
func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c &amp;lt;- x: x, y = y, x+y case &amp;lt;-quit: fmt.</description></item><item><title>Go 语言中的 make 和 new</title><link>/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/</guid><description>5.5 make 和 new # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — make 和 new。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑1，但是它们两者能够初始化的变量却有较大的不同。
make 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel2； new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针3； 我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：
slice := make([]int, 0, 100) hash := make(map[int]bool, 10) ch := make(chan int, 5) slice 是一个包含 data、cap 和 len 的结构体 reflect.SliceHeader； hash 是一个指向 runtime.hmap 结构体的指针； ch 是一个指向 runtime.hchan 结构体的指针； 相比与复杂的 make 关键字，new 的功能就简单多了，它只能接收类型作为参数然后返回一个指向该类型的指针：
i := new(int) var v int i := &amp;amp;v 上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 int 零值的指针。</description></item><item><title>Go 语言内存分配器的实现原理</title><link>/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/</guid><description>7.1 内存分配器 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域：栈区（Stack）和堆区（Heap）。函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。
不同的编程语言会选择不同的方式管理内存，本节会介绍 Go 语言内存分配器，详细分析内存分配的过程以及其背后的设计与实现原理。
7.1.1 设计原理 # 内存管理一般包含三个不同的组件，分别是用户程序（Mutator）、分配器（Allocator）和收集器（Collector）1，当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。
图 7-1 内存管理的组件
Go 语言的内存分配器实现非常复杂，在分析内存分配器的实现之前，我们需要了解内存分配的设计原理，掌握内存的分配过程。这里会详细介绍内存分配器的分配方法以及 Go 语言内存分配器的分级分配、虚拟内存布局和地址空间。
分配方法 # 编程语言的内存分配器一般包含两种分配方法，一种是线性分配器（Sequential Allocator，Bump Allocator），另一种是空闲链表分配器（Free-List Allocator），这两种分配方法有着不同的实现机制和特性，本节会依次介绍它们的分配过程。
线性分配器 # 线性分配（Bump Allocator）是一种高效的内存分配方法，但是有较大的局限性。当我们使用线性分配器时，只需要在内存中维护一个指向内存特定位置的指针，如果用户程序向分配器申请内存，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针：
图 7-2 线性分配器
虽然线性分配器实现为它带来了较快的执行速度以及较低的实现复杂度，但是线性分配器无法在内存被释放时重用内存。如下图所示，如果已经分配的内存被回收，线性分配器无法重新利用红色的内存：
图 7-3 线性分配器回收内存
因为线性分配器具有上述特性，所以需要与合适的垃圾回收算法配合使用，例如：标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法，它们可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。
因为线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略，我们会在下一节详细介绍常见垃圾回收算法的设计原理。
空闲链表分配器 # 空闲链表分配器（Free-List Allocator）可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表：
图 7-4 空闲链表分配器
因为不同的内存块通过指针构成了链表，所以使用这种方式的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度是 $O(n)$。空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择，最常见的是以下四种：
首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块； 循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块； 最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块； 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块； 上述四种策略的前三种就不过多介绍了，Go 语言使用的内存分配策略与第四种策略有些相似，我们通过下图了解该策略的原理：</description></item><item><title>Go 语言切片的实现原理</title><link>/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/</guid><description>3.2 切片 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 上一节介绍的数组在 Go 语言中没那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。
在 Go 语言中，切片类型的声明方式与数组有一些相似，不过由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：
[]int []interface{} 从切片的定义我们能推测出，切片在编译期间的生成的类型只会包含切片中的元素类型，即 int 或者 interface{} 等。cmd/compile/internal/types.NewSlice 就是编译期间用于创建切片类型的函数：
func NewSlice(elem *Type) *Type { if t := elem.Cache.slice; t != nil { if t.Elem() != elem { Fatalf(&amp;#34;elem mismatch&amp;#34;) } return t } t := New(TSLICE) t.Extra = Slice{Elem: elem} elem.Cache.slice = t return t } 上述方法返回结构体中的 Extra 字段是一个只包含切片内元素类型的结构，也就是说切片内元素的类型都是在编译期间确定的，编译器确定了类型之后，会将类型存储在 Extra 字段中帮助程序在运行时动态获取。
3.2.1 数据结构 # 编译期间的切片是 cmd/compile/internal/types.</description></item><item><title>Go 语言反射的实现原理</title><link>/golang/docs/part2-foundation/ch04-basic/golang-reflect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch04-basic/golang-reflect/</guid><description>4.3 反射 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制简化代码。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 reflect 包能够弥补它在语法上reflect.Type的一些劣势。
reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象1。反射包中有两对非常重要的函数和类型，两个函数分别是：
reflect.TypeOf 能获取类型信息； reflect.ValueOf 能获取数据的运行时表示； 两个类型是 reflect.Type 和 reflect.Value，它们与函数是一一对应的关系：
图 4-15 反射函数和类型
类型 reflect.Type 是反射包定义的一个接口，我们可以使用 reflect.TypeOf 函数获取任意变量的类型，reflect.Type 接口中定义了一些有趣的方法，MethodByName 可以获取当前类型对应方法的引用、Implements 可以判断当前类型是否实现了某个接口：
type Type interface { Align() int FieldAlign() int Method(int) Method MethodByName(string) (Method, bool) NumMethod() int ... Implements(u Type) bool ... } 反射包中 reflect.Value 的类型与 reflect.Type 不同，它被声明成了结构体。这个结构体没有对外暴露的字段，但是提供了获取或者写入数据的方法：</description></item><item><title>Go 语言垃圾收集器的实现原理</title><link>/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/</guid><description>7.2 垃圾收集器 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 我们在上一节中详细介绍了 Go 语言内存分配器的设计与实现原理，分析了运行时内存管理组件之间的关系以及不同类型对象的分配，然而编程语言的内存管理系统除了负责堆内存的分配之外，它还需要负责回收不再使用的对象和内存空间，这部分职责是由本节即将介绍的垃圾收集器完成的。
在几乎所有的现代编程语言中，垃圾收集器都是一个复杂的系统，为了在不影响用户程序的情况下回收废弃的内存需要付出非常多的努力，Java 的垃圾收集机制是一个很好的例子，Java 8 中包含线性、并发、并行标记清除和 G1 四个垃圾收集器1，想要理解它们的工作原理和实现细节需要花费很多的精力。
本节会详细介绍 Go 语言运行时系统中垃圾收集器的设计与实现原理，我们不仅会讨论常见的垃圾收集机制、从 Go 语言的 v1.0 版本开始分析其演进过程，还会深入源代码分析垃圾收集器的工作原理。
7.2.1 设计原理 # 今天的编程语言通常会使用手动和自动两种方式管理内存，C、C++ 以及 Rust 等编程语言使用手动的方式管理内存2，工程师需要主动申请或者释放内存；而 Python、Ruby、Java 和 Go 等语言使用自动的内存管理系统，一般都是垃圾收集机制，不过 Objective-C 却选择了自动引用计数3，虽然引用计数也是自动的内存管理机制，但是我们在这里不会详细介绍它，本节的重点还是垃圾收集。
相信很多人对垃圾收集器的印象都是暂停程序（Stop the world，STW），随着用户程序申请越来越多的内存，系统中的垃圾也逐渐增多；当程序的内存占用达到一定阈值时，整个应用程序就会全部暂停，垃圾收集器会扫描已经分配的所有对象并回收不再使用的内存空间，当这个过程结束后，用户程序才可以继续执行，Go 语言在早期也使用这种策略实现垃圾收集，但是今天的实现已经复杂了很多。
图 7-21 内存管理的组件
在上图中，用户程序（Mutator）会通过内存分配器（Allocator）在堆上申请内存，而垃圾收集器（Collector）负责回收堆上的内存空间，内存分配器和垃圾收集器共同管理着程序中的堆内存空间。我们在这一节中将详细介绍 Go 语言垃圾收集中涉及的关键理论，帮助我们更好地理解本节剩下的内容。
标记清除 # 标记清除（Mark-Sweep）算法是最常见的垃圾收集算法，标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：
标记阶段 — 从根对象出发查找并标记堆中所有存活的对象； 清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表； 如下图所示，内存空间中包含多个对象，我们从根对象出发依次遍历对象的子对象并将从根节点可达的对象都标记成存活状态，即 A、C 和 D 三个对象，剩余的 B、E 和 F 三个对象因为从根节点不可达，所以会被当做垃圾：</description></item><item><title>Go 语言如何进行类型检查</title><link>/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/</guid><description>2.3 类型检查 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 我们在上一节中介绍了 Go 语言编译的第一个阶段 — 通过词法和语法分析器的解析得到了抽象语法树，本节会继续介绍编译器执行的下一个阶段 — 类型检查。
提到类型检查和编程语言的类型系统，很多朋友可能会想到几个有些模糊并且不好理解的术语：强类型、弱类型、静态类型和动态类型。但是我们既然要谈到 Go 语言编译器的类型检查过程，我们接下来就彻底搞清楚这几个『类型』的含义与异同。
2.3.1 强弱类型 # 强类型和弱类型1经常会被放在一起讨论，然而这两者并没有一个学术上的严格定义，多查阅些资料理解起来反而更加困难，很多资料甚至相互矛盾。
图 2-10 强类型和弱类型
由于权威的定义的缺失，对于强弱类型，我们很多时候也只能根据现象和特性从直觉上进行判断，一般会有如下结论2：
强类型的编程语言在编译期间会有更严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误； 弱类型的编程语言在出现类型错误时可能会在运行时进行隐式的类型转换，在类型转换时可能会造成运行错误。 依据上面的结论，我们就可以认为 Java、C# 等在编译期间进行类型检查的编程语言是强类型的。同样地，因为 Go 语言会在编译期间发现类型错误，也应该是强类型的编程语言。
如果强类型与弱类型这一对概念定义不严格且有歧义，那么在概念上较真本身是没有太多太多实际价值的，起码对于我们真正使用和理解编程语言帮助不大。问题来了，作为一种抽象的定义，我们使用它是为了什么呢？答案是，更多时候是为了方便沟通和分类。让我们忽略强弱类型，把更多注意力放到下面的问题上：
类型的转换是显式的还是隐式的？ 编译器会帮助我们推断变量的类型么？ 这些具体的问题在这种语境下其实更有价值，也希望各位读者能够减少对强弱类型的争执。
2.3.2 静态类型与动态类型 # 静态类型和动态类型的编程语言其实也是两个不精确的表述，正确的表达应该是使用静态类型检查和动态类型检查的编程语言，这一小节会分别介绍两种类型检查的特点以及它们的区别。
静态类型检查 # 静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程3，如果我们的代码能够通过静态类型检查，那么当前程序在一定程度上可以满足类型安全的要求，它能够减少程序在运行时的类型检查，也可以被看作是一种代码优化的方式。
作为一个开发者来说，静态类型检查能够帮助我们在编译期间发现程序中出现的类型错误，一些动态类型的编程语言都会有社区提供的工具为这些编程语言加入静态类型检查，例如 JavaScript 的 Flow4，这些工具能够在编译期间发现代码中的类型错误。
相信很多读者也都听过『动态类型一时爽，代码重构火葬场』5，使用 Python、Ruby 等编程语言的开发者一定对这句话深有体会，静态类型为代码在编译期间提供了约束，编译器能够在编译期间约束变量的类型。
静态类型检查在重构时能够帮助我们节省大量时间并避免遗漏，但是如果编程语言仅支持动态类型检查，那么就需要写大量的单元测试保证重构不会出现类型错误。当然这里并不是说测试不重要，我们写的任何代码都应该有良好的测试，这与语言没有太多的关系。
动态类型检查 # 动态类型检查是在运行时确定程序类型安全的过程，它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性6。动态类型检查能为工程师提供更多的操作空间，让我们能在运行时获取一些类型相关的上下文并根据对象的类型完成一些动态操作。
只使用动态类型检查的编程语言叫做动态类型编程语言，常见的动态类型编程语言就包括 JavaScript、Ruby 和 PHP，虽然这些编程语言在使用上非常灵活也不需要经过编译，但是有问题的代码该不会因为更加灵活就会减少错误，该出错时仍然会出错，它们在提高灵活性的同时，也提高了对工程师的要求。</description></item><item><title>Go 语言字符串和字节数组的实现原理</title><link>/golang/docs/part2-foundation/ch03-datastructure/golang-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch03-datastructure/golang-string/</guid><description>3.4 字符串 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 字符串是 Go 语言中的基础数据类型，虽然字符串往往被看做一个整体，但是它实际上是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，本节会详细介绍字符串的实现原理、转换过程以及常见操作的实现。
字符串是由字符组成的数组，C 语言中的字符串使用字符数组 char[] 表示。数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，Go 语言中的字符串只是一个只读的字节数组，下图展示了 &amp;quot;hello&amp;quot; 字符串在内存中的存储方式：
图 3-18 内存中的字符串
如果是代码中存在的字符串，编译器会将其标记成只读数据 SRODATA，假设我们有以下代码，其中包含了一个字符串，当我们将这段代码编译成汇编语言时，就能够看到 hello 字符串有一个 SRODATA 的标记：
$ cat main.go package main func main() { str := &amp;#34;hello&amp;#34; println([]byte(str)) } $ GOOS=linux GOARCH=amd64 go tool compile -S main.go ... go.string.&amp;#34;hello&amp;#34; SRODATA dupok size=5 0x0000 68 65 6c 6c 6f hello ... 只读只意味着字符串会分配到只读的内存空间，但是 Go 语言只是不支持直接修改 string 类型变量的内存空间，我们仍然可以通过在 string 和 []byte 类型之间反复转换实现修改这一目的：</description></item><item><title>Go 语言并发编程、同步原语与锁</title><link>/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/</guid><description>6.2 同步原语与锁 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 Go 语言作为一个原生支持用户态进程（Goroutine）的语言，当提到并发编程、多线程编程时，往往都离不开锁这一概念。锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题。
本节会介绍 Go 语言中常见的同步原语 sync.Mutex、sync.RWMutex、sync.WaitGroup、sync.Once 和 sync.Cond 以及扩展原语 golang/sync/errgroup.Group、golang/sync/semaphore.Weighted 和 golang/sync/singleflight.Group 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。
6.2.1 基本原语 # Go 语言在 sync 包中提供了用于同步的一些基本原语，包括常见的 sync.Mutex、sync.RWMutex、sync.WaitGroup、sync.Once 和 sync.Cond：
图 6-5 基本同步原语
这些基本原语提供了较为基础的同步功能，但是它们是一种相对原始的同步机制，在多数情况下，我们都应该使用抽象层级更高的 Channel 实现同步。
Mutex # Go 语言的 sync.Mutex 由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。
type Mutex struct { state int32 sema uint32 } 上述两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</description></item><item><title>Go 语言并发编程与 Context</title><link>/golang/docs/part3-runtime/ch06-concurrency/golang-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch06-concurrency/golang-context/</guid><description>6.1 上下文 Context # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 上下文 context.Context Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。
context.Context 是 Go 语言在 1.7 版本中引入标准库的接口1，该接口定义了四个需要实现的方法，其中包括：
Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期； Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 Channel； Err — 返回 context.Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空的值； 如果 context.Context 被取消，会返回 Canceled 错误； 如果 context.Context 超时，会返回 DeadlineExceeded 错误； Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据； type Context interface { Deadline() (deadline time.</description></item><item><title>Go 语言并发编程与计时器</title><link>/golang/docs/part3-runtime/ch06-concurrency/golang-timer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch06-concurrency/golang-timer/</guid><description>6.3 计时器 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把各个节点上时间的误差控制在毫秒级，所以准确的相对时间在分布式系统中显得更为重要，本节会分析用于获取相对时间的计时器的设计与实现原理。
6.3.1 设计原理 # Go 语言从实现计时器到现在经历过很多个版本的迭代，到最新的版本为止，计时器的实现分别经历了以下几个过程：
Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护1； Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护2； Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发3； 我们在这一节会分别介绍计时器在不同版本的不同设计，梳理计时器实现的演进过程。
全局四叉堆 # Go 1.10 之前的计时器都使用最小四叉堆实现，所有的计时器都会存储在如下所示的结构体 runtime.timers:093adee 中：
var timers struct { lock mutex gp *g created bool sleeping bool rescheduling bool sleepUntil int64 waitnote note t []*timer } 这个结构体中的字段 t 就是最小四叉堆，运行时创建的所有计时器都会加入到四叉堆中。runtime.timerproc:093adee Goroutine 会运行时间驱动的事件，运行时会在发生以下事件时唤醒计时器：</description></item><item><title>Go 语言接口的原理</title><link>/golang/docs/part2-foundation/ch04-basic/golang-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch04-basic/golang-interface/</guid><description>4.2 接口 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也不清楚其底层的实现原理，这成为了开发高性能服务的阻碍。
本节会介绍使用接口时遇到的一些常见问题以及它的设计与实现，包括接口的类型转换、类型断言以及动态派发机制，帮助各位读者更好地理解接口类型。
4.2.1 概述 # 在计算机科学中，接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息1。如下图所示，接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。
图 4-5 上下游通过接口解耦
这种面向接口的编程方式有着非常强大的生命力，无论是在框架还是操作系统中我们都能够找到接口的身影。可移植操作系统接口（Portable Operating System Interface，POSIX)2就是一个典型的例子，它定义了应用程序接口和命令行等标准，为计算机软件带来了可移植性 — 只要操作系统实现了 POSIX，计算机软件就可以直接在不同操作系统上运行。
除了解耦有依赖关系的上下游，接口还能够帮助我们隐藏底层实现，减少关注点。《计算机程序的构造和解释》中有这么一句话：
代码必须能够被人阅读，只是机器恰好可以执行3
人能够同时处理的信息非常有限，定义良好的接口能够隔离底层的实现，让我们将重点放在当前的代码片段中。SQL 就是接口的一个例子，当我们使用 SQL 语句查询数据时，其实不需要关心底层数据库的具体实现，我们只在乎 SQL 返回的结果是否符合预期。
图 4-6 SQL 和不同数据库
计算机科学中的接口是比较抽象的概念，但是编程语言中接口的概念就更加具体。Go 语言中的接口是一种内置的类型，它定义了一组方法的签名，本节会介绍 Go 语言接口的几个基本概念以及常见问题，为后面的实现原理做铺垫。
隐式接口 # 很多面向对象语言都有接口这一概念，例如 Java 和 C#。Java 的接口不仅可以定义方法签名，还可以定义变量，这些定义的变量可以直接在实现接口的类中使用，这里简单介绍一下 Java 中的接口：
public interface MyInterface { public String hello = &amp;#34;Hello&amp;#34;; public void sayHello(); } 上述代码定义了一个必须实现的方法 sayHello 和一个会注入到实现类的变量 hello。在下面的代码中，MyInterfaceImpl 实现了 MyInterface 接口：</description></item><item><title>Go 语言数据库的实现原理</title><link>/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/</guid><description>9.3 数据库 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 数据库几乎是所有 Web 服务不可或缺的一部分，在所有类型的数据库中，关系型数据库是我们在想要持久存储数据时的首要选择。因为关系型数据库的种类繁多，所以 Go 语言的标准库 database/sql 仅为访问关系型数据提供了通用的接口，这样不同数据库只要实现标准库中的接口，应用程序就可以通过标准库中的方法读写数据库中的数据。
9.3.1 设计原理 # 结构化查询语言（Structured Query Language、SQL）是在关系型数据库系统中使用的领域特定语言（Domain-Specific Language、DSL），它主要用于处理结构化的数据1。作为一门领域特定语言，它有更加强大的表达能力，与传统的命令式 API 相比，它能够提供两个优点：
可以使用单个命令在数据库中访问多条数据； 不需要在查询中指定获取数据的方法； 所有的关系型数据库都会提供 SQL 作为查询语言，应用程序可以使用相同的 SQL 查询在不同数据库中查询数据，当然不同的数据库在实现细节和接口上还略有一些不同，这些不兼容的特性在不同数据库中仍然无法通用，例如：PostgreSQL 中的几何类型，不过它们基本都会兼容标准的 SQL 查询以方便应用程序接入：
图 9-12 SQL 和数据库
如上图所示，SQL 是应用程序和数据库之间的中间层，应用程序在多数情况下都不需要关心底层数据库的实现，它们只关心 SQL 查询返回的数据。
Go 语言的 database/sql 就建立在上述前提下，我们可以使用相同的 SQL 语言查询关系型数据库，所有关系型数据库的客户端都需要实现如下所示的驱动接口：
type Driver interface { Open(name string) (Conn, error) } type Conn interface { Prepare(query string) (Stmt, error) Close() error Begin() (Tx, error) } database/sql/driver.</description></item><item><title>Go 语言数组的实现原理</title><link>/golang/docs/part2-foundation/ch03-datastructure/golang-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch03-datastructure/golang-array/</guid><description>3.1 数组 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 数组和切片是 Go 语言中常见的数据结构，很多刚刚使用 Go 的开发者往往会混淆这两个概念。数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 — 切片，切片与数组有一些类似，但是它们的不同导致了使用上的巨大差别。我们在这一节中会从 Go 语言的编译期间运行时来介绍数组的底层实现原理，其中会包括数组的初始化、访问和赋值几种常见操作。
3.1.1 概述 # 数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用1。
图 3-1 多维数组
数组作为一种基本的数据类型，我们通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数，在 Go 语言中我们往往会使用如下所示的方式来表示数组类型：
[10]int [200]interface{} Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。
func NewArray(elem *Type, bound int64) *Type { if bound &amp;lt; 0 { Fatalf(&amp;#34;NewArray: invalid bound %v&amp;#34;, bound) } t := New(TARRAY) t.Extra = &amp;amp;Array{Elem: elem, Bound: bound} t.SetNotInHeap(elem.NotInHeap()) return t } 编译期间的数组类型是由上述的 cmd/compile/internal/types.</description></item><item><title>Go 语言的代码生成机制</title><link>/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/</guid><description>8.2 代码生成 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 图灵完备可能是很多工程师经常听说的术语，它的一个重要特性是计算机程序可以生成另一个程序1，本届要介绍的就是 Go 语言的代码生成机制。很多人可能认为生成代码在软件中并不常见，但是实际上它在很多场景中都扮演了重要的角色，Go 语言中的测试就使用了代码生成机制，go test 命令会扫描包中的测试用例并生成程序、编译并执行它们。
8.2.1 设计原理 # 元编程是计算机编程中一个很重要、也很有趣的概念，维基百科上将元编程描述成一种计算机程序可以将代码看待成数据的能力2。
Metaprogramming is a programming technique in which computer programs have the ability to treat programs as their data.
如果能够将代码看做数据，那么代码就可以像数据一样在运行时被修改、更新和替换；元编程赋予了编程语言更加强大的表达能力，能够让我们将一些计算过程从运行时挪到编译时、通过编译期间的展开生成代码或者允许程序在运行时改变自身的行为。总而言之，元编程其实是一种使用代码生成代码的方式，无论是编译期间生成代码，还是在运行时改变代码的行为都是生成代码的一种3。
图 8-3 元编程的使用
现代的编程语言大都会为我们提供不同的元编程能力，从总体来看，根据生成代码的时机不同，我们将元编程能力分为两种类型，其中一种是编译期间的元编程，例如：宏和模板；另一种是运行期间的元编程，也就是运行时，它赋予了编程语言在运行期间修改行为的能力，当然也有一些特性既可以在编译期实现，也可以在运行期间实现。
Go 语言作为编译型的编程语言，它提供了比较有限的运行时元编程能力，例如：反射特性，然而由于性能的问题，反射在很多场景下都不被推荐使用。当然除了反射之外，Go 语言还提供了另一种编译期间的代码生成机制 — go generate，它可以在代码编译之前根据源代码生成代码。
8.2.2 代码生成 # Go 语言的代码生成机制会读取包含预编译指令的注释，然后执行注释中的命令读取包中的文件，它们将文件解析成抽象语法树并根据语法树生成新的 Go 语言代码和文件，生成的代码会在项目的编译期间与其他代码一起编译和运行。
//go:generate command argument... go generate 不会被 go build 等命令自动执行，该命令需要显式的触发，手动执行该命令时会在文件中扫描上述形式的注释并执行后面的执行命令，需要注意的是 go:generate 和前面的 // 之间没有空格，这种不包含空格的注释一般是 Go 语言的编译器指令，而我们在代码中的正常注释都应该保留这个空格4。</description></item><item><title>Go 语言的动态库和插件系统</title><link>/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/</guid><description>8.1 插件系统 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 熟悉 Go 语言的开发者一般都非常了解 Goroutine 和 Channel 的原理，包括如何设计基于 CSP 模型的应用程序，但是 Go 语言的插件系统是很少有人了解的模块，通过插件系统，我们可以在运行时加载动态库实现一些比较有趣的功能。
8.1.1 设计原理 # Go 语言的插件系统基于 C 语言动态库实现的，所以它也继承了 C 语言动态库的优点和缺点，我们在本节中会对比 Linux 中的静态库和动态库，分析它们各自的特点和优势。
静态库或者静态链接库是由编译期决定的程序、外部函数和变量构成的，编译器或者链接器会将程序和变量等内容拷贝到目标的应用并生成一个独立的可执行对象文件1； 动态库或者共享对象可以在多个可执行文件之间共享，程序使用的模块会在运行时从共享对象中加载，而不是在编译程序时打包成独立的可执行文件2； 由于特性不同，静态库和动态库的优缺点也比较明显；只依赖静态库并且通过静态链接生成的二进制文件因为包含了全部的依赖，所以能够独立执行，但是编译的结果也比较大；而动态库可以在多个可执行文件之间共享，可以减少内存的占用，其链接的过程往往也都是在装载或者运行期间触发的，所以可以包含一些可以热插拔的模块并降低内存的占用。
图 8-1 静态库与动态库
使用静态链接编译二进制文件在部署上有非常明显的优势，最终的编译产物也可以直接运行在大多数的机器上，静态链接带来的部署优势远比更低的内存占用显得重要，所以很多编程语言包括 Go 都将静态链接作为默认的链接方式。
插件系统 # 在今天，动态链接带来的低内存占用优势虽然已经没有太多作用，但是动态链接的机制却可以为我们提供更多的灵活性，主程序可以在编译后动态加载共享库实现热插拔的插件系统。
图 8-2 插件系统
通过在主程序和共享库直接定义一系列的约定或者接口，我们可以通过以下的代码动态加载其他人编译的 Go 语言共享对象，这样做的好处是主程序和共享库的开发者不需要共享代码，只要双方的约定不变，修改共享库后也不需要重新编译主程序。
type Driver interface { Name() string } func main() { p, err := plugin.Open(&amp;#34;driver.so&amp;#34;) if err !</description></item><item><title>Go 语言的栈内存和逃逸分析</title><link>/golang/docs/part3-runtime/ch07-memory/golang-stack-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch07-memory/golang-stack-management/</guid><description>7.3 栈空间管理 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 应用程序的内存一般会分成堆区和栈区，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收，我们在上两节已经详细分析了堆内存的申请和释放过程，本节会介绍 Go 语言栈内存的管理。
7.3.1 设计原理 # 栈区的内存一般由编译器自动分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在，这种线性的内存分配策略有着极高地效率，但是工程师也往往不能控制栈内存的分配，这部分工作基本都是由编译器完成的。
寄存器 # 寄存器1是中央处理器（CPU）中的稀缺资源，它的存储能力非常有限，但是能提供最快的读写速度，充分利用寄存器的速度可以构建高性能的应用程序。寄存器在物理机上非常有限，然而栈区的操作会使用到两个以上的寄存器，这足以说明栈内存在应用程序的重要性。
栈寄存器是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈2，Go 语言的汇编代码包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址，栈内存与函数调用的关系非常紧密，我们在函数调用一节中曾经介绍过栈区，BP 和 SP 之间的内存就是当前函数的调用栈。
图 7-43 栈寄存器与内存
因为历史原因，栈区内存都是从高地址向低地址扩展的，当应用程序申请或者释放栈内存时只需要修改 SP 寄存器的值，这种线性的内存分配方式与堆内存相比更加快速，仅会带来极少的额外开销。
线程栈 # 如果我们在 Linux 操作系统中执行 pthread_create 系统调用，进程会启动一个新的线程，如果用户没有通过软资源限制 RLIMIT_STACK 指定线程栈的大小，那么操作系统会根据架构选择不同的默认栈大小3。
架构 默认栈大小 i386 2 MB IA-64 32 MB PowerPC 4 MB &amp;hellip; &amp;hellip; x86_64 2 MB 表 7-4 架构和线程默认栈大小</description></item><item><title>Go 语言系统监控的实现原理</title><link>/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/</guid><description>6.7 系统监控 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 很多系统中都有守护进程，它们能够在后台监控系统的运行状态，在出现意外情况时及时响应。系统监控是 Go 语言运行时的重要组成部分，它会每隔一段时间检查 Go 语言运行时，确保程序没有进入异常状态。本节会介绍 Go 语言系统监控的设计与实现原理，包括它的启动、执行过程以及主要职责。
6.7.1 设计原理 # 在支持多任务的操作系统中，守护进程是在后台运行的计算机程序，它不会由用户直接操作，它一般会在操作系统启动时自动运行。Kubernetes 的 DaemonSet 和 Go 语言的系统监控都使用类似设计提供一些通用的功能：
图 6-46 Go 语言系统监控
守护进程是很有效的设计，它在整个系统的生命周期中都会存在，会随着系统的启动而启动，系统的结束而结束。在操作系统和 Kubernetes 中，我们经常会将数据库服务、日志服务以及监控服务等进程作为守护进程运行。
Go 语言的系统监控也起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触发垃圾回收，通过这些行为，它能够让系统的运行状态变得更健康。
6.7.2 监控循环 # 当 Go 语言程序启动时，运行时会在第一个 Goroutine 中调用 runtime.main 启动主程序，该函数会在系统栈中创建新的线程：
func main() { ... if GOARCH != &amp;#34;wasm&amp;#34; { systemstack(func() { newm(sysmon, nil) }) } ... } runtime.newm 会创建一个存储待执行函数和处理器的新结构体 runtime.</description></item><item><title>Go 语言编译过程概述</title><link>/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/</guid><description>2.1 编译过程 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 Go 语言是一门需要编译才能运行的编程语言，也就是说代码在运行之前需要通过编译器生成二进制机器码，包含二进制机器码的文件才能在目标机器上运行，如果我们想要了解 Go 语言的实现原理，理解它的编译过程就是一个没有办法绕过的事情。
这一节会先对 Go 语言编译的过程进行概述，从顶层介绍编译器执行的几个步骤，随后的几节会分别剖析各个步骤完成的工作和实现原理，同时也会对一些需要预先掌握的知识进行介绍，确保后面的章节能够被更好的理解。
2.1.1 预备知识 # 想要深入了解 Go 语言的编译过程，需要提前了解一下编译过程中涉及的一些术语和专业知识。这些知识其实在我们的日常工作和学习中比较难用到，但是对于理解编译的过程和原理还是非常重要的。这一小节会简单挑选几个重要的概念提前进行介绍，减少后面章节的理解压力。
抽象语法树 # 抽象语法树（Abstract Syntax Tree、AST），是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构1。抽象语法树中的每一个节点都表示源代码中的一个元素，每一棵子树都表示一个语法元素，以表达式 2 * 3 + 7 为例，编译器的语法分析阶段会生成如下图所示的抽象语法树。
图 2-1 简单表达式的抽象语法树
作为编译器常用的数据结构，抽象语法树抹去了源代码中不重要的一些字符 - 空格、分号或者括号等等。编译器在执行完语法分析之后会输出一个抽象语法树，这个抽象语法树会辅助编译器进行语义分析，我们可以用它来确定语法正确的程序是否存在一些类型不匹配的问题。
静态单赋值 # 静态单赋值（Static Single Assignment、SSA）是中间代码的特性，如果中间代码具有静态单赋值的特性，那么每个变量就只会被赋值一次2。在实践中，我们通常会用下标实现静态单赋值，这里以下面的代码举个例子：
x := 1 x := 2 y := x 经过简单的分析，我们就能够发现上述的代码第一行的赋值语句 x := 1 不会起到任何作用。下面是具有 SSA 特性的中间代码，我们可以清晰地发现变量 y_1 和 x_1 是没有任何关系的，所以在机器码生成时就可以省去 x := 1 的赋值，通过减少需要执行的指令优化这段代码。</description></item><item><title>Go 语言网络轮询器的实现原理</title><link>/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/</guid><description>6.6 网络轮询器 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 在今天，大部分的服务都是 I/O 密集型的，应用程序会花费大量时间等待 I/O 操作的完成。网络轮询器是 Go 语言运行时用来处理 I/O 操作的关键组件，它使用了操作系统提供的 I/O 多路复用机制增强程序的并发处理能力。本节会深入分析 Go 语言网络轮询器的设计与实现原理。
6.6.1 设计原理 # 网络轮询器不仅用于监控网络 I/O，还能用于监控文件的 I/O，它利用了操作系统提供的 I/O 多路复用模型来提升 I/O 设备的利用率以及程序的性能。本节会分别介绍常见的几种 I/O 模型以及 Go 语言运行时的网络轮询器如何使用多模块设计在不同的操作系统上支持多路复用。
I/O 模型 # 操作系统中包含阻塞 I/O、非阻塞 I/O、信号驱动 I/O 与异步 I/O 以及 I/O 多路复用五种 I/O 模型。我们在本节中会介绍上述五种模型中的三种：
阻塞 I/O 模型； 非阻塞 I/O 模型； I/O 多路复用模型； 在 Unix 和类 Unix 操作系统中，文件描述符（File descriptor，FD）是用于访问文件或者其他 I/O 资源的抽象句柄，例如：管道或者网络套接字1。而不同的 I/O 模型会使用不同的方式操作文件描述符。</description></item><item><title>Go 语言调度器与 Goroutine 实现原理</title><link>/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/</guid><description>6.5 调度器 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 Go 语言在并发编程方面有强大的能力，这离不开语言层面对并发编程的支持。本节会介绍 Go 语言运行时调度器的实现原理，其中包含调度器的设计与实现原理、演变过程以及与运行时调度相关的数据结构。
谈到 Go 语言调度器，我们绕不开的是操作系统、进程与线程这些概念，线程是操作系统调度时的最基本单元，而 Linux 在调度器并不区分进程和线程的调度，它们在不同操作系统上也有不同的实现，但是在大多数的实现中线程都属于进程：
图 6-25 进程和线程
多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。
虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间1，但是 Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销2。
图 6-26 线程与 Goroutine
Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。
6.5.1 设计原理 # 今天的 Go 语言调度器有着优异的性能，但是如果我们回头看 Go 语言的 0.x 版本的调度器会发现最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能，历史上几个不同版本的调度器引入了不同的改进，也存在着不同的缺陷:
单线程调度器 · 0.x 只包含 40 多行代码； 程序中只能存在一个活跃线程，由 G-M 模型组成； 多线程调度器 · 1.</description></item><item><title>如何调试 Go 语言源代码</title><link>/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/</guid><description>1.1 调试源代码 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 Go 语言作为开源项目，我们可以很轻松地获取它的源代码，它有着非常复杂的项目结构和庞大的代码库，今天的 Go 语言中差不多有 150 万行源代码，其中包含将近 140 万行的 Go 语言代码，我们可以使用如下所示的命令查看项目中代码的行数：
$ cloc src 5988 text files. 5875 unique files. 1165 files ignored. github.com/AlDanial/cloc v 1.78 T=6.96 s (693.7 files/s, 274805.2 lines/s) ----------------------------------------------------------------------------------- Language files blank comment code ----------------------------------------------------------------------------------- Go 4199 139910 221375 1398357 Assembly 486 12784 19137 106699 C 64 718 562 4587 JSON 12 0 0 1712 .</description></item><item><title>指令集架构、机器码与 Go 语言</title><link>/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/</guid><description>2.5 机器码生成 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 Go 语言编译的最后一个阶段是根据 SSA 中间代码生成机器码，这里谈的机器码是在目标 CPU 架构上能够运行的二进制代码，中间代码生成一节简单介绍的从抽象语法树到 SSA 中间代码的生成过程，将近 50 个生成中间代码的步骤中有一些过程严格上说是属于机器码生成阶段的。
机器码的生成过程其实是对 SSA 中间代码的降级（lower）过程，在 SSA 中间代码降级的过程中，编译器将一些值重写成了目标 CPU 架构的特定值，降级的过程处理了所有机器特定的重写规则并对代码进行了一定程度的优化；在 SSA 中间代码生成阶段的最后，Go 函数体的代码会被转换成 cmd/compile/internal/obj.Prog 结构。
2.5.1 指令集架构 # 首先需要介绍的就是指令集架构，虽然我们在第一节编译过程概述中曾经讲解过指令集架构，但是在这里还是需要引入更多的指令集架构知识。
图 2-16 计算机软硬件之间的桥梁
指令集架构是计算机的抽象模型，在很多时候也被称作架构或者计算机架构，它是计算机软件和硬件之间的接口和桥梁1；一个为特定指令集架构编写的应用程序能够运行在所有支持这种指令集架构的机器上，也就是说如果当前应用程序支持 x86 的指令集，那么就可以运行在所有使用 x86 指令集的机器上，这其实就是抽象层的作用，每一个指令集架构都定义了支持的数据结构、寄存器、管理主内存的硬件支持（例如内存一致、地址模型和虚拟内存）、支持的指令集和 IO 模型，它的引入其实就在软件和硬件之间引入了一个抽象层，让同一个二进制文件能够在不同版本的硬件上运行。
如果一个编程语言想要在所有的机器上运行，它就可以将中间代码转换成使用不同指令集架构的机器码，这可比为不同硬件单独移植要简单的太多了。
图 2-17 复杂指令集（CISC）和精简指令集（RISC）
最常见的指令集架构分类方法是根据指令的复杂度将其分为复杂指令集（CISC）和精简指令集（RISC），复杂指令集架构包含了很多特定的指令，但是其中的一些指令很少会被程序使用，而精简指令集只实现了经常被使用的指令，不常用的操作都会通过组合简单指令来实现。
复杂指令集的特点就是指令数目多并且复杂，每条指令的字节长度并不相等，x86 就是常见的复杂指令集处理器，它的指令长度大小范围非常广，从 1 到 15 字节不等，对于长度不固定的指令，计算机必须额外对指令进行判断，这需要付出额外的性能损失2。
而精简指令集对指令的数目和寻址方式做了精简，大大减少指令数量的同时更容易实现，指令集中的每一个指令都使用标准的字节长度、执行时间相比复杂指令集会少很多，处理器在处理指令时也可以流水执行，提高了对并行的支持。作为一种常见的精简指令集处理器，arm 使用 4 个字节作为指令的固定长度，省略了判断指令的性能损失3，精简指令集其实就是利用了我们耳熟能详的 20/80 原则，用 20% 的基础指令和它们的组合来解决问题。
最开始的计算机使用复杂指令集是因为当时计算机的性能和内存比较有限，业界需要尽可能地减少机器需要执行的指令，所以更倾向于高度编码、长度不等以及多操作数的指令。不过随着计算机性能的提升，出现了精简指令集这种牺牲代码密度换取简单实现的设计；除此之外，硬件的飞速提升还带来了更多的寄存器和更高的时钟频率，软件开发人员也不再直接接触汇编代码，而是通过编译器和汇编器生成指令，复杂的机器指令对于编译器来说很难利用，所以精简指令在这种场景下更适合。
复杂指令集和精简指令集的使用是设计上的权衡，经过这么多年的发展，两种指令集也相互借鉴和学习，与最开始刚被设计出来时已经有了较大的差别，对于软件工程师来讲，复杂的硬件设备对于我们来说已经是领域下三层的知识了，其实不太需要掌握太多，但是对指令集架构感兴趣的读者可以找一些资料开拓眼界。</description></item><item><title>理解 Go 语言 defer 关键字的原理</title><link>/golang/docs/part2-foundation/ch05-keyword/golang-defer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch05-keyword/golang-defer/</guid><description>5.3 defer # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。这一节会深入 Go 语言的源代码介绍 defer 关键字的实现原理，相信读者读完这一节会对 defer 的数据结构、实现以及调用过程有着更清晰的理解。
作为一个编程语言中的关键字，defer 的实现一定是由编译器和运行时共同完成的，不过在深入源码分析它的实现之前我们还是需要了解 defer 关键字的常见使用场景以及使用时的注意事项。
使用 defer 的最常见场景是在函数调用结束后完成一些收尾工作，例如在 defer 中回滚数据库的事务：
func createPost(db *gorm.DB) error { tx := db.Begin() defer tx.Rollback() if err := tx.Create(&amp;amp;Post{Author: &amp;#34;Draveness&amp;#34;}).Error; err != nil { return err } return tx.Commit().Error } 在使用数据库事务时，我们可以使用上面的代码在创建事务后就立刻调用 Rollback 保证事务一定会回滚。哪怕事务真的执行成功了，那么调用 tx.Commit() 之后再执行 tx.Rollback() 也不会影响已经提交的事务。
5.3.1 现象 # 我们在 Go 语言中使用 defer 时会遇到两个常见问题，这里会介绍具体的场景并分析这两个现象背后的设计原理：</description></item><item><title>理解 Go 语言的函数调用</title><link>/golang/docs/part2-foundation/ch04-basic/golang-function-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch04-basic/golang-function-call/</guid><description>4.1 函数调用 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执行过程。
4.1.1 调用惯例 # 无论是系统级编程语言 C 和 Go，还是脚本语言 Ruby 和 Python，这些编程语言在调用函数时往往都使用相同的语法：
somefunction(arg0, arg1) 虽然它们调用函数的语法很相似，但是它们的调用惯例却可能大不相同。调用惯例是调用方和被调用方对于参数和返回值传递的约定，本节将为各位读者介绍 C 和 Go 语言的调用惯例。
C 语言 # 我们先来研究 C 语言的调用惯例，使用 gcc1 或者 clang2 将 C 语言编译成汇编代码是分析其调用惯例的最好方法，从汇编语言中可以了解函数调用的具体过程。
gcc 和 clang 编译相同 C 语言代码可能会生成不同的汇编指令，不过生成的代码在结构上不会有太大的区别，所以对只想理解调用惯例的人来说没有太多影响。作者在本节中选择使用 gcc 编译器来编译 C 语言：
$ gcc --version gcc (Ubuntu 4.8.2-19ubuntu1) 4.8.2 Copyright (C) 2013 Free Software Foundation, Inc.</description></item><item><title>理解 Golang 哈希表 Map 的原理</title><link>/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</guid><description>3.3 哈希表 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 本节会介绍 Go 语言的哈希的实现原理，哈希是除了数组之外，最常见的数据结构。几乎所有的语言都会有数组和哈希表两种集合元素，有的语言将数组实现成列表，而有的语言将哈希称作字典或者映射。无论如何命名或者如何实现，数组和哈希是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系。
哈希表1是一种古老的数据结构，在 1953 年就有人使用拉链法实现了哈希表，它能够通过键直接获取该键对应的值。
3.3.1 设计原理 # 哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 $O(1)$ 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。
哈希函数 # 实现哈希表的关键点在于哈希函数的选择，哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求哈希函数的输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。
图 3-7 完美哈希函数
比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题。哈希函数映射的结果一定要尽可能均匀，结果不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能。
图 3-8 不均匀哈希函数
如果使用结果分布较为均匀的哈希函数，那么哈希的增删改查的时间复杂度为 $O(1)$；但是如果哈希函数的结果分布不均匀，那么所有操作的时间复杂度可能会达到 $O(n)$，由此看来，使用好的哈希函数是至关重要的。
冲突解决 # 就像我们之前所提到的，在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多也会产生冲突。然而多数的哈希函数都是不够完美的，所以仍然存在发生哈希碰撞的可能，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。
需要注意的是，这里提到的哈希碰撞不是多个键对应的哈希完全相等，可能是多个哈希的部分相等，例如：两个键对应哈希的前四个字节相同。
开放寻址法 # 开放寻址法2是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中，如果我们使用开放寻址法来实现哈希表，那么实现哈希表底层的数据结构就是数组，不过因为数组的长度有限，向哈希表写入 (author, draven) 这个键值对时会从如下的索引开始遍历：
index := hash(&amp;#34;author&amp;#34;) % array.len 当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置：
图 3-9 开放地址法写入数据
如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲位置。当我们再去读取 Key3 对应的值时就会先获取键的哈希并取模，这会先帮助我们找到 Key1，找到 Key1 后发现它与 Key 3 不相等，所以会继续查找后面的元素，直到内存为空或者找到目标元素。</description></item><item><title>解析器眼中的 Go 语言</title><link>/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/</guid><description>2.2 词法分析和语法分析 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 当使用通用编程语言1进行编写代码时，我们一定要认识到代码首先是写给人看的，只是恰好可以被机器编译和执行，而很难被人理解和维护的代码是非常糟糕。代码其实是按照约定格式编写的字符串，经过训练的软件工程师能对本来无意义的字符串进行分组和分析，按照约定的语法来理解源代码，并在脑内编译并运行程序。
既然工程师能够按照一定的方式理解和编译 Go 语言的源代码，那么我们如何模拟人理解源代码的方式构建一个能够分析编程语言代码的程序呢。我们在这一节中将介绍词法分析和语法分析这两个重要的编译过程，这两个过程能将原本机器看来无序意义的源文件转换成更容易理解、分析并且结构化的抽象语法树，接下来我们就看一看解析器眼中的 Go 语言是什么样的。
2.2.1 词法分析 # 源代码在计算机『眼中』其实是一团乱麻，一个由字符组成的、无法被理解的字符串，所有的字符在计算器看来并没有什么区别，为了理解这些字符我们需要做的第一件事情就是将字符串分组，这能够降低理解字符串的成本，简化源代码的分析过程。
make(chan int) 哪怕是不懂编程的人看到上述文本的第一反应也应该会将上述字符串分成几个部分 - make、chan、int 和括号，这个凭直觉分解文本的过程就是词法分析，词法分析是将字符序列转换为标记（token）序列的过程2。
lex # lex3 是用于生成词法分析器的工具，lex 生成的代码能够将一个文件中的字符分解成 Token 序列，很多语言在设计早期都会使用它快速设计出原型。词法分析作为具有固定模式的任务，出现这种更抽象的工具必然的，lex 作为一个代码生成器，使用了类似 C 语言的语法，我们将 lex 理解为正则匹配的生成器，它会使用正则匹配扫描输入的字符流，下面是一个 lex 文件的示例：
%{ #include &amp;lt;stdio.h&amp;gt;%} %% package printf(&amp;#34;PACKAGE &amp;#34;); import printf(&amp;#34;IMPORT &amp;#34;); \. printf(&amp;#34;DOT &amp;#34;); \{ printf(&amp;#34;LBRACE &amp;#34;); \} printf(&amp;#34;RBRACE &amp;#34;); \( printf(&amp;#34;LPAREN &amp;#34;); \) printf(&amp;#34;RPAREN &amp;#34;); \&amp;#34; printf(&amp;#34;QUOTE &amp;#34;); \n printf(&amp;#34;\n&amp;#34;); [0-9]+ printf(&amp;#34;NUMBER &amp;#34;); [a-zA-Z_]+ printf(&amp;#34;IDENT &amp;#34;); %% 这个定义好的文件能够解析 package 和 import 关键字、常见的特殊字符、数字以及标识符，虽然这里的规则可能有一些简陋和不完善，但是用来解析下面的这一段代码还是比较轻松的：</description></item><item><title>详解 Go 语言中间代码生成</title><link>/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/</guid><description>2.4 中间代码生成 # 各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。 前两节介绍的词法与语法分析以及类型检查两个部分都属于编译器前端，它们负责对源代码进行分析并检查其中存在的词法和语法错误，经过这两个阶段生成的抽象语法树已经不存在语法错误了，本节将继续介绍编译器的后端工作 —— 中间代码生成。
2.4.1 概述 # 中间代码是编译器或者虚拟机使用的语言，它可以来帮助我们分析计算机程序。在编译过程中，编译器会在将源代码转换到机器码的过程中，先把源代码转换成一种中间的表示形式，即中间代码1。
图 2-12 源代码、中间代码和机器码
很多读者可能认为中间代码没有太多价值，我们可以直接将源代码翻译成目标语言，这种看起来可行的办法实际上有很多问题，其中最主要的是：它忽略了编译器面对的复杂场景，很多编译器需要将源代码翻译成多种机器码，直接翻译高级编程语言相对比较困难。
将编程语言到机器码的过程拆成中间代码生成和机器码生成两个简单步骤可以简化该问题，中间代码是一种更接近机器语言的表示形式，对中间代码的优化和分析相比直接分析高级编程语言更容易。
Go 语言编译器的中间代码具有静态单赋值（SSA）的特性，我们在 Go 语言编译过程一节曾经介绍过静态单赋值，对这个特性不了解的读者可以回到上面的章节阅读相关的内容。
我们再来回忆一下编译阶段入口的主函数 cmd/compile/internal/gc.Main 中关于中间代码生成的部分，这一段代码会初始化 SSA 生成的配置，在配置初始化结束后会调用 cmd/compile/internal/gc.funccompile 编译函数：
func Main(archInit func(*Arch)) { ... initssaconfig() for i := 0; i &amp;lt; len(xtop); i++ { n := xtop[i] if n.Op == ODCLFUNC { funccompile(n) } } compileFunctions() } 这一节将分别介绍配置的初始化以及函数编译两部分内容，我们会以 cmd/compile/internal/gc.initssaconfig 和 cmd/compile/internal/gc.funccompile 这两个函数作为入口来分析中间代码生成的具体过程和实现原理。
2.4.2 配置初始化 # SSA 配置的初始化过程是中间代码生成之前的准备工作，在该过程中，我们会缓存可能用到的类型指针、初始化 SSA 配置和一些之后会调用的运行时函数，例如：用于处理 defer 关键字的 runtime.</description></item></channel></rss>