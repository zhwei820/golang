<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="3.1 数组 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  数组和切片是 Go 语言中常见的数据结构，很多刚刚使用 Go 的开发者往往会混淆这两个概念。数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 — 切片，切片与数组有一些类似，但是它们的不同导致了使用上的巨大差别。我们在这一节中会从 Go 语言的编译期间运行时来介绍数组的底层实现原理，其中会包括数组的初始化、访问和赋值几种常见操作。
3.1.1 概述 #  数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用1。
图 3-1 多维数组
数组作为一种基本的数据类型，我们通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数，在 Go 语言中我们往往会使用如下所示的方式来表示数组类型：
[10]int [200]interface{} Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。
func NewArray(elem *Type, bound int64) *Type { if bound < 0 { Fatalf(&#34;NewArray: invalid bound %v&#34;, bound) } t := New(TARRAY) t.Extra = &Array{Elem: elem, Bound: bound} t.SetNotInHeap(elem.NotInHeap()) return t } 编译期间的数组类型是由上述的 cmd/compile/internal/types."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言数组的实现原理"><meta property="og:description" content="3.1 数组 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  数组和切片是 Go 语言中常见的数据结构，很多刚刚使用 Go 的开发者往往会混淆这两个概念。数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 — 切片，切片与数组有一些类似，但是它们的不同导致了使用上的巨大差别。我们在这一节中会从 Go 语言的编译期间运行时来介绍数组的底层实现原理，其中会包括数组的初始化、访问和赋值几种常见操作。
3.1.1 概述 #  数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用1。
图 3-1 多维数组
数组作为一种基本的数据类型，我们通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数，在 Go 语言中我们往往会使用如下所示的方式来表示数组类型：
[10]int [200]interface{} Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。
func NewArray(elem *Type, bound int64) *Type { if bound < 0 { Fatalf(&#34;NewArray: invalid bound %v&#34;, bound) } t := New(TARRAY) t.Extra = &Array{Elem: elem, Bound: bound} t.SetNotInHeap(elem.NotInHeap()) return t } 编译期间的数组类型是由上述的 cmd/compile/internal/types."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part2-foundation/ch03-datastructure/golang-array/"><title>Go 语言数组的实现原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言数组的实现原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#31-数组>3.1 数组</a><ul><li><a href=#311-概述>3.1.1 概述</a></li><li><a href=#312-初始化>3.1.2 初始化</a><ul><li><a href=#上限推导>上限推导</a></li><li><a href=#语句转换>语句转换</a></li></ul></li><li><a href=#313-访问和赋值>3.1.3 访问和赋值</a></li><li><a href=#314-小结>3.1.4 小结</a></li><li><a href=#315-延伸阅读>3.1.5 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=31-数组>3.1 数组
<a class=anchor href=#31-%e6%95%b0%e7%bb%84>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>数组和切片是 Go 语言中常见的数据结构，很多刚刚使用 Go 的开发者往往会混淆这两个概念。数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 — 切片，切片与数组有一些类似，但是它们的不同导致了使用上的巨大差别。我们在这一节中会从 Go 语言的<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>编译期间</a>运行时来介绍数组的底层实现原理，其中会包括数组的初始化、访问和赋值几种常见操作。</p><h2 id=311-概述>3.1.1 概述
<a class=anchor href=#311-%e6%a6%82%e8%bf%b0>#</a></h2><p>数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问特定元素，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。</p><p><img src=https://img.draveness.me/2019-02-20-3D-array.jpg alt=3D-array></p><p><strong>图 3-1 多维数组</strong></p><p>数组作为一种基本的数据类型，我们通常会从两个维度描述数组，也就是数组中存储的元素类型和数组最大能存储的元素个数，在 Go 语言中我们往往会使用如下所示的方式来表示数组类型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>[<span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>int</span>
[<span style=color:#ae81ff>200</span>]<span style=color:#66d9ef>interface</span>{}
</code></pre></div><p>Go 语言数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewArray</span>(<span style=color:#a6e22e>elem</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>bound</span> <span style=color:#66d9ef>int64</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Type</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bound</span> &lt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;NewArray: invalid bound %v&#34;</span>, <span style=color:#a6e22e>bound</span>)
	}
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>TARRAY</span>)
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Extra</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Array</span>{<span style=color:#a6e22e>Elem</span>: <span style=color:#a6e22e>elem</span>, <span style=color:#a6e22e>Bound</span>: <span style=color:#a6e22e>bound</span>}
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>SetNotInHeap</span>(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>NotInHeap</span>())
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>
}
</code></pre></div><p>编译期间的数组类型是由上述的 <a href=/golang/tree/cmd/compile/internal/types.NewArray><code>cmd/compile/internal/types.NewArray</code></a> 函数生成的，该类型包含两个字段，分别是元素类型 <code>Elem</code> 和数组的大小 <code>Bound</code>，这两个字段共同构成了数组类型，而当前数组是否应该在堆栈中初始化也在编译期就确定了。</p><h2 id=312-初始化>3.1.2 初始化
<a class=anchor href=#312-%e5%88%9d%e5%a7%8b%e5%8c%96>#</a></h2><p>Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用 <code>[...]T</code> 声明数组，Go 语言会在编译期间通过源代码推导数组的大小：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>arr1</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
<span style=color:#a6e22e>arr2</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</code></pre></div><p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这也就是编译器对数组大小的推导，下面我们来介绍编译器的推导过程。</p><h3 id=上限推导>上限推导
<a class=anchor href=#%e4%b8%8a%e9%99%90%e6%8e%a8%e5%af%bc>#</a></h3><p>两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式 <code>[10]T</code>，那么变量的类型在编译进行到<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>类型检查</a>阶段就会被提取出来，随后使用 <a href=/golang/tree/cmd/compile/internal/types.NewArray><code>cmd/compile/internal/types.NewArray</code></a>创建包含数组大小的 <a href=/golang/tree/cmd/compile/internal/types.Array><code>cmd/compile/internal/types.Array</code></a> 结构体。</p><p>当我们使用 <code>[...]T</code> 的方式声明数组时，编译器会在的 <a href=/golang/tree/cmd/compile/internal/gc.typecheckcomplit><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数中对该数组的大小进行推导：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>typecheckcomplit</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) (<span style=color:#a6e22e>res</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>OTARRAY</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ODDD</span> {
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>ctxType</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Type</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
		}
		<span style=color:#a6e22e>elemType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Type</span>

		<span style=color:#a6e22e>length</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheckarraylit</span>(<span style=color:#a6e22e>elemType</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Slice</span>(), <span style=color:#e6db74>&#34;array literal&#34;</span>)

		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> = <span style=color:#a6e22e>OARRAYLIT</span>
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewArray</span>(<span style=color:#a6e22e>elemType</span>, <span style=color:#a6e22e>length</span>)
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
	}
	<span style=color:#f92672>...</span>

	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Etype</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TARRAY</span>:
		<span style=color:#a6e22e>typecheckarraylit</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Elem</span>(), <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>NumElem</span>(), <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Slice</span>(), <span style=color:#e6db74>&#34;array literal&#34;</span>)
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> = <span style=color:#a6e22e>OARRAYLIT</span>
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#66d9ef>nil</span>
	}
}
</code></pre></div><p>这个删减后的 <a href=/golang/tree/cmd/compile/internal/gc.typecheckcomplit><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 会调用 <a href=/golang/tree/cmd/compile/internal/gc.typecheckarraylit><code>cmd/compile/internal/gc.typecheckarraylit</code></a> 通过遍历元素的方式来计算数组中元素的数量。</p><p>所以我们可以看出 <code>[...]T{1, 2, 3}</code> 和 <code>[3]T{1, 2, 3}</code> 在运行时是完全等价的，<code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量。</p><h3 id=语句转换>语句转换
<a class=anchor href=#%e8%af%ad%e5%8f%a5%e8%bd%ac%e6%8d%a2>#</a></h3><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <a href=/golang/tree/cmd/compile/internal/gc.anylit><code>cmd/compile/internal/gc.anylit</code></a> 函数中做两种不同的优化：</p><ol><li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li><li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>anylit</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>var_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) {
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OSTRUCTLIT</span>, <span style=color:#a6e22e>OARRAYLIT</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Len</span>() &gt; <span style=color:#ae81ff>4</span> {
			<span style=color:#f92672>...</span>
		}

		<span style=color:#a6e22e>fixedlit</span>(<span style=color:#a6e22e>inInitFunction</span>, <span style=color:#a6e22e>initKindLocalCode</span>, <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>var_</span>, <span style=color:#a6e22e>init</span>)
	<span style=color:#f92672>...</span>
	}
}
</code></pre></div><p>当数组的元素<strong>小于或者等于四个</strong>时，<a href=/golang/tree/cmd/compile/internal/gc.fixedlit><code>cmd/compile/internal/gc.fixedlit</code></a> 会负责在函数编译之前将 <code>[3]{1, 2, 3}</code> 转换成更加原始的语句：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fixedlit</span>(<span style=color:#a6e22e>ctxt</span> <span style=color:#a6e22e>initContext</span>, <span style=color:#a6e22e>kind</span> <span style=color:#a6e22e>initKind</span>, <span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>var_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>splitnode</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>)
	<span style=color:#f92672>...</span>

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Slice</span>() {
		<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>splitnode</span>(<span style=color:#a6e22e>r</span>)
		<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OAS</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>value</span>)
		<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>ctxStmt</span>)
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>kind</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>initKindStatic</span>:
			<span style=color:#a6e22e>genAsStatic</span>(<span style=color:#a6e22e>a</span>)
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>initKindLocalCode</span>:
			<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>orderStmtInPlace</span>(<span style=color:#a6e22e>a</span>, <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>][]<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{})
			<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>walkstmt</span>(<span style=color:#a6e22e>a</span>)
			<span style=color:#a6e22e>init</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>a</span>)
		}
	}
}
</code></pre></div><p>当数组中元素的个数小于或者等于四个并且 <a href=/golang/tree/cmd/compile/internal/gc.fixedlit><code>cmd/compile/internal/gc.fixedlit</code></a> 函数接收的 <code>kind</code> 是 <code>initKindLocalCode</code> 时，上述代码会将原有的初始化语句 <code>[3]int{1, 2, 3}</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>1</span>
<span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>1</span>] = <span style=color:#ae81ff>2</span>
<span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>2</span>] = <span style=color:#ae81ff>3</span>
</code></pre></div><p>但是如果当前数组的元素大于四个，<a href=/golang/tree/cmd/compile/internal/gc.anylit><code>cmd/compile/internal/gc.anylit</code></a> 会先获取一个唯一的 <code>staticname</code>，然后调用 <a href=/golang/tree/cmd/compile/internal/gc.fixedlit><code>cmd/compile/internal/gc.fixedlit</code></a> 函数在静态存储区初始化数组中的元素并将临时变量赋值给数组：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>anylit</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>var_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) {
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OSTRUCTLIT</span>, <span style=color:#a6e22e>OARRAYLIT</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Len</span>() &gt; <span style=color:#ae81ff>4</span> {
			<span style=color:#a6e22e>vstat</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>staticname</span>(<span style=color:#a6e22e>t</span>)
			<span style=color:#a6e22e>vstat</span>.<span style=color:#a6e22e>Name</span>.<span style=color:#a6e22e>SetReadonly</span>(<span style=color:#66d9ef>true</span>)

			<span style=color:#a6e22e>fixedlit</span>(<span style=color:#a6e22e>inNonInitFunction</span>, <span style=color:#a6e22e>initKindStatic</span>, <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>vstat</span>, <span style=color:#a6e22e>init</span>)

			<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OAS</span>, <span style=color:#a6e22e>var_</span>, <span style=color:#a6e22e>vstat</span>)
			<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>ctxStmt</span>)
			<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>walkexpr</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>init</span>)
			<span style=color:#a6e22e>init</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>a</span>)
			<span style=color:#66d9ef>break</span>
		}

		<span style=color:#f92672>...</span>
	}
}
</code></pre></div><p>假设代码需要初始化 <code>[5]int{1, 2, 3, 4, 5}</code>，那么我们可以将上述过程理解成以下的伪代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr</span> [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>statictmp_0</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>1</span>
<span style=color:#a6e22e>statictmp_0</span>[<span style=color:#ae81ff>1</span>] = <span style=color:#ae81ff>2</span>
<span style=color:#a6e22e>statictmp_0</span>[<span style=color:#ae81ff>2</span>] = <span style=color:#ae81ff>3</span>
<span style=color:#a6e22e>statictmp_0</span>[<span style=color:#ae81ff>3</span>] = <span style=color:#ae81ff>4</span>
<span style=color:#a6e22e>statictmp_0</span>[<span style=color:#ae81ff>4</span>] = <span style=color:#ae81ff>5</span>
<span style=color:#a6e22e>arr</span> = <span style=color:#a6e22e>statictmp_0</span>
</code></pre></div><p>总结起来，在不考虑逃逸分析的情况下，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>中间代码生成</a>和<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>机器码生成</a>两个阶段，最后生成可以执行的二进制文件。</p><h2 id=313-访问和赋值>3.1.3 访问和赋值
<a class=anchor href=#313-%e8%ae%bf%e9%97%ae%e5%92%8c%e8%b5%8b%e5%80%bc>#</a></h2><p>无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生越界；而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，无论丢失了哪个信息，我们都无法知道这片连续的内存空间到底存储了什么数据：</p><p><img src=https://img.draveness.me/2019-12-27-15773821941323-golang-array-memory.png alt=golang-array-memory></p><p><strong>图 3-2 数组的内存空间</strong></p><p>数组访问越界是非常严重的错误，Go 语言中可以在编译期间的静态类型检查判断数组越界，<a href=/golang/tree/cmd/compile/internal/gc.typecheck1><code>cmd/compile/internal/gc.typecheck1</code></a> 会验证访问数组的索引：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>typecheck1</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>top</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>res</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OINDEX</span>:
		<span style=color:#a6e22e>ok</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>ctxExpr</span>
		<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>  <span style=color:#75715e>// array
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span> <span style=color:#75715e>// index
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>Etype</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TSTRING</span>, <span style=color:#a6e22e>TARRAY</span>, <span style=color:#a6e22e>TSLICE</span>:
			<span style=color:#f92672>...</span>
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Type</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>IsInteger</span>() {
				<span style=color:#a6e22e>yyerror</span>(<span style=color:#e6db74>&#34;non-integer array index %v&#34;</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>)
				<span style=color:#66d9ef>break</span>
			}
			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Bounded</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>Isconst</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>CTINT</span>) {
				<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Int64</span>()
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> &lt; <span style=color:#ae81ff>0</span> {
					<span style=color:#a6e22e>yyerror</span>(<span style=color:#e6db74>&#34;invalid array index %v (index must be non-negative)&#34;</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>)
				} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>IsArray</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>NumElem</span>() {
					<span style=color:#a6e22e>yyerror</span>(<span style=color:#e6db74>&#34;invalid array index %v (out of bounds for %d-element array)&#34;</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>NumElem</span>())
				}
			}
		}
	<span style=color:#f92672>...</span>
	}
}
</code></pre></div><ol><li>访问数组的索引是非整数时，报错 &ldquo;non-integer array index %v&rdquo;；</li><li>访问数组的索引是负数时，报错 &ldquo;invalid array index %v (index must be non-negative)"；</li><li>访问数组的索引越界时，报错 &ldquo;invalid array index %v (out of bounds for %d-element array)"；</li></ol><p>数组和字符串的一些简单越界错误都会在编译期间发现，例如：直接使用整数或者常量访问数组；但是如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，我们需要 Go 语言运行时阻止不合法的访问：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>4</span>]: <span style=color:#a6e22e>invalid</span> <span style=color:#a6e22e>array</span> <span style=color:#a6e22e>index</span> <span style=color:#ae81ff>4</span> (<span style=color:#a6e22e>out</span> <span style=color:#a6e22e>of</span> <span style=color:#a6e22e>bounds</span> <span style=color:#66d9ef>for</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>-</span><span style=color:#a6e22e>element</span> <span style=color:#a6e22e>array</span>)
<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>]: <span style=color:#a6e22e>panic</span>: <span style=color:#a6e22e>runtime</span> <span style=color:#66d9ef>error</span>: <span style=color:#a6e22e>index</span> <span style=color:#a6e22e>out</span> <span style=color:#a6e22e>of</span> <span style=color:#66d9ef>range</span> [<span style=color:#ae81ff>4</span>] <span style=color:#a6e22e>with</span> <span style=color:#a6e22e>length</span> <span style=color:#ae81ff>3</span>
</code></pre></div><p>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <a href=/golang/tree/runtime.panicIndex><code>runtime.panicIndex</code></a> 和 <a href=/golang/tree/runtime.goPanicIndex><code>runtime.goPanicIndex</code></a> 触发程序的运行时错误并导致崩溃退出：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>panicIndex</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>
	<span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>x</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>)
	<span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>CX</span>, <span style=color:#a6e22e>y</span><span style=color:#f92672>+</span><span style=color:#ae81ff>4</span>(<span style=color:#a6e22e>FP</span>)
	<span style=color:#a6e22e>JMP</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>goPanicIndex</span>(<span style=color:#a6e22e>SB</span>)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>goPanicIndex</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>panicCheck1</span>(<span style=color:#a6e22e>getcallerpc</span>(), <span style=color:#e6db74>&#34;index out of range&#34;</span>)
	panic(<span style=color:#a6e22e>boundsError</span>{<span style=color:#a6e22e>x</span>: int64(<span style=color:#a6e22e>x</span>), <span style=color:#a6e22e>signed</span>: <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>y</span>: <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>code</span>: <span style=color:#a6e22e>boundsIndex</span>})
}
</code></pre></div><p>当数组的访问操作 <code>OINDEX</code> 成功通过编译器的检查后，会被转换成几个 SSA 指令，假设我们有如下所示的 Go 语言代码，通过如下的方式进行编译会得到 ssa.html 文件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>check</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>outOfRange</span>() <span style=color:#66d9ef>int</span> {
	<span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>4</span>
	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>]
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>elem</span>
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#a6e22e>GOSSAFUNC</span>=<span style=color:#a6e22e>outOfRange</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>build</span> <span style=color:#a6e22e>array</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>dumped</span> <span style=color:#a6e22e>SSA</span> <span style=color:#a6e22e>to</span> .<span style=color:#f92672>/</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>html</span>
</code></pre></div><p><code>start</code> 阶段生成的 SSA 代码就是优化之前的第一版中间代码，下面展示的部分是 <code>elem := arr[i]</code> 对应的中间代码，在这段中间代码中我们发现 Go 语言为数组的访问操作生成了判断数组上限的指令 <code>IsInBounds</code> 以及当条件不满足时触发程序崩溃的 <code>PanicBounds</code> 指令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>b1</span>:
    <span style=color:#f92672>...</span>
    <span style=color:#a6e22e>v22</span> (<span style=color:#ae81ff>6</span>) = <span style=color:#a6e22e>LocalAddr</span> &lt;<span style=color:#f92672>*</span>[<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>&gt; {<span style=color:#a6e22e>arr</span>} <span style=color:#a6e22e>v2</span> <span style=color:#a6e22e>v20</span>
    <span style=color:#a6e22e>v23</span> (<span style=color:#ae81ff>6</span>) = <span style=color:#a6e22e>IsInBounds</span> &lt;<span style=color:#66d9ef>bool</span>&gt; <span style=color:#a6e22e>v21</span> <span style=color:#a6e22e>v11</span>
<span style=color:#a6e22e>If</span> <span style=color:#a6e22e>v23</span> <span style=color:#960050;background-color:#1e0010>→</span> <span style=color:#a6e22e>b2</span> <span style=color:#a6e22e>b3</span> (<span style=color:#a6e22e>likely</span>) (<span style=color:#ae81ff>6</span>)

<span style=color:#a6e22e>b2</span>: <span style=color:#960050;background-color:#1e0010>←</span> <span style=color:#a6e22e>b1</span><span style=color:#f92672>-</span>
    <span style=color:#a6e22e>v26</span> (<span style=color:#ae81ff>6</span>) = <span style=color:#a6e22e>PtrIndex</span> &lt;<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>&gt; <span style=color:#a6e22e>v22</span> <span style=color:#a6e22e>v21</span>
    <span style=color:#a6e22e>v27</span> (<span style=color:#ae81ff>6</span>) = <span style=color:#a6e22e>Copy</span> &lt;<span style=color:#a6e22e>mem</span>&gt; <span style=color:#a6e22e>v20</span>
    <span style=color:#a6e22e>v28</span> (<span style=color:#ae81ff>6</span>) = <span style=color:#a6e22e>Load</span> &lt;<span style=color:#66d9ef>int</span>&gt; <span style=color:#a6e22e>v26</span> <span style=color:#a6e22e>v27</span> (<span style=color:#a6e22e>elem</span>[<span style=color:#66d9ef>int</span>])
    <span style=color:#f92672>...</span>
<span style=color:#a6e22e>Ret</span> <span style=color:#a6e22e>v30</span> (<span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>)

<span style=color:#a6e22e>b3</span>: <span style=color:#960050;background-color:#1e0010>←</span> <span style=color:#a6e22e>b1</span><span style=color:#f92672>-</span>
    <span style=color:#a6e22e>v24</span> (<span style=color:#ae81ff>6</span>) = <span style=color:#a6e22e>Copy</span> &lt;<span style=color:#a6e22e>mem</span>&gt; <span style=color:#a6e22e>v20</span>
    <span style=color:#a6e22e>v25</span> (<span style=color:#ae81ff>6</span>) = <span style=color:#a6e22e>PanicBounds</span> &lt;<span style=color:#a6e22e>mem</span>&gt; [<span style=color:#ae81ff>0</span>] <span style=color:#a6e22e>v21</span> <span style=color:#a6e22e>v11</span> <span style=color:#a6e22e>v24</span>
<span style=color:#a6e22e>Exit</span> <span style=color:#a6e22e>v25</span> (<span style=color:#ae81ff>6</span>)
</code></pre></div><p>编译器会将 <code>PanicBounds</code> 指令转换成上面提到的 <a href=/golang/tree/runtime.panicIndex><code>runtime.panicIndex</code></a> 函数，当数组下标没有越界时，编译器会先获取数组的内存地址和访问的下标、利用 <code>PtrIndex</code> 计算出目标元素的地址，最后使用 <code>Load</code> 操作将指针中的元素加载到内存中。</p><p>当然只有当编译器无法对数组下标是否越界无法做出判断时才会加入 <code>PanicBounds</code> 指令交给运行时进行判断，在使用字面量整数访问数组下标时会生成非常简单的中间代码，当我们将上述代码中的 <code>arr[i]</code> 改成 <code>arr[2]</code> 时，就会得到如下所示的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>b1</span>:
    <span style=color:#f92672>...</span>
    <span style=color:#a6e22e>v21</span> (<span style=color:#ae81ff>5</span>) = <span style=color:#a6e22e>LocalAddr</span> &lt;<span style=color:#f92672>*</span>[<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>&gt; {<span style=color:#a6e22e>arr</span>} <span style=color:#a6e22e>v2</span> <span style=color:#a6e22e>v20</span>
    <span style=color:#a6e22e>v22</span> (<span style=color:#ae81ff>5</span>) = <span style=color:#a6e22e>PtrIndex</span> &lt;<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>&gt; <span style=color:#a6e22e>v21</span> <span style=color:#a6e22e>v14</span>
    <span style=color:#a6e22e>v23</span> (<span style=color:#ae81ff>5</span>) = <span style=color:#a6e22e>Load</span> &lt;<span style=color:#66d9ef>int</span>&gt; <span style=color:#a6e22e>v22</span> <span style=color:#a6e22e>v20</span> (<span style=color:#a6e22e>elem</span>[<span style=color:#66d9ef>int</span>])
    <span style=color:#f92672>...</span>
</code></pre></div><p>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，还会在运行期间通过插入的函数保证不会发生越界。</p><p>数组的赋值和更新操作 <code>a[i] = 2</code> 也会生成 SSA 生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容，这些赋值语句会被转换成如下所示的 SSA 代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>b1</span>:
    <span style=color:#f92672>...</span>
    <span style=color:#a6e22e>v21</span> (<span style=color:#ae81ff>5</span>) = <span style=color:#a6e22e>LocalAddr</span> &lt;<span style=color:#f92672>*</span>[<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>&gt; {<span style=color:#a6e22e>arr</span>} <span style=color:#a6e22e>v2</span> <span style=color:#a6e22e>v19</span>
    <span style=color:#a6e22e>v22</span> (<span style=color:#ae81ff>5</span>) = <span style=color:#a6e22e>PtrIndex</span> &lt;<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>&gt; <span style=color:#a6e22e>v21</span> <span style=color:#a6e22e>v13</span>
    <span style=color:#a6e22e>v23</span> (<span style=color:#ae81ff>5</span>) = <span style=color:#a6e22e>Store</span> &lt;<span style=color:#a6e22e>mem</span>&gt; {<span style=color:#66d9ef>int</span>} <span style=color:#a6e22e>v22</span> <span style=color:#a6e22e>v20</span> <span style=color:#a6e22e>v19</span>
    <span style=color:#f92672>...</span>
</code></pre></div><p>赋值的过程中会先确定目标数组的地址，再通过 <code>PtrIndex</code> 获取目标元素的地址，最后使用 <code>Store</code> 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出 上述数组寻址和赋值都是在编译阶段完成的，没有运行时的参与。</p><h2 id=314-小结>3.1.4 小结
<a class=anchor href=#314-%e5%b0%8f%e7%bb%93>#</a></h2><p>数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>编译期间</a>都会转换成直接读写内存，在中间代码生成期间，编译器还会插入运行时方法 <a href=/golang/tree/runtime.panicIndex><code>runtime.panicIndex</code></a> 调用防止发生越界错误。</p><h2 id=315-延伸阅读>3.1.5 延伸阅读
<a class=anchor href=#315-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=https://blog.golang.org/slices>Arrays, slices (and strings): The mechanics of &lsquo;append&rsquo;</a></li><li><a href=https://stackoverflow.com/questions/30525184/array-vs-slice-accessing-speed>Array vs Slice: accessing speed</a></li></ul><p><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/ class=book-btn>上一节</a>
<a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Array data structure, <a href=https://en.wikipedia.org/wiki/Array_data_structure>https://en.wikipedia.org/wiki/Array_data_structure</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-array data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-array",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#31-数组>3.1 数组</a><ul><li><a href=#311-概述>3.1.1 概述</a></li><li><a href=#312-初始化>3.1.2 初始化</a><ul><li><a href=#上限推导>上限推导</a></li><li><a href=#语句转换>语句转换</a></li></ul></li><li><a href=#313-访问和赋值>3.1.3 访问和赋值</a></li><li><a href=#314-小结>3.1.4 小结</a></li><li><a href=#315-延伸阅读>3.1.5 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>