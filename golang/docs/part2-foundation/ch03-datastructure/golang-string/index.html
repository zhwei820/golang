<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="3.4 字符串 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  字符串是 Go 语言中的基础数据类型，虽然字符串往往被看做一个整体，但是它实际上是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，本节会详细介绍字符串的实现原理、转换过程以及常见操作的实现。
字符串是由字符组成的数组，C 语言中的字符串使用字符数组 char[] 表示。数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，Go 语言中的字符串只是一个只读的字节数组，下图展示了 &#34;hello&#34; 字符串在内存中的存储方式：
图 3-18 内存中的字符串
如果是代码中存在的字符串，编译器会将其标记成只读数据 SRODATA，假设我们有以下代码，其中包含了一个字符串，当我们将这段代码编译成汇编语言时，就能够看到 hello 字符串有一个 SRODATA 的标记：
$ cat main.go package main func main() { str := &#34;hello&#34; println([]byte(str)) } $ GOOS=linux GOARCH=amd64 go tool compile -S main.go ... go.string.&#34;hello&#34; SRODATA dupok size=5 0x0000 68 65 6c 6c 6f hello ... 只读只意味着字符串会分配到只读的内存空间，但是 Go 语言只是不支持直接修改 string 类型变量的内存空间，我们仍然可以通过在 string 和 []byte 类型之间反复转换实现修改这一目的："><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言字符串和字节数组的实现原理"><meta property="og:description" content="3.4 字符串 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  字符串是 Go 语言中的基础数据类型，虽然字符串往往被看做一个整体，但是它实际上是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，本节会详细介绍字符串的实现原理、转换过程以及常见操作的实现。
字符串是由字符组成的数组，C 语言中的字符串使用字符数组 char[] 表示。数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，Go 语言中的字符串只是一个只读的字节数组，下图展示了 &#34;hello&#34; 字符串在内存中的存储方式：
图 3-18 内存中的字符串
如果是代码中存在的字符串，编译器会将其标记成只读数据 SRODATA，假设我们有以下代码，其中包含了一个字符串，当我们将这段代码编译成汇编语言时，就能够看到 hello 字符串有一个 SRODATA 的标记：
$ cat main.go package main func main() { str := &#34;hello&#34; println([]byte(str)) } $ GOOS=linux GOARCH=amd64 go tool compile -S main.go ... go.string.&#34;hello&#34; SRODATA dupok size=5 0x0000 68 65 6c 6c 6f hello ... 只读只意味着字符串会分配到只读的内存空间，但是 Go 语言只是不支持直接修改 string 类型变量的内存空间，我们仍然可以通过在 string 和 []byte 类型之间反复转换实现修改这一目的："><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part2-foundation/ch03-datastructure/golang-string/"><title>Go 语言字符串和字节数组的实现原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言字符串和字节数组的实现原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#34-字符串>3.4 字符串</a><ul><li><a href=#341-数据结构>3.4.1 数据结构</a></li><li><a href=#342-解析过程>3.4.2 解析过程</a></li><li><a href=#343-拼接>3.4.3 拼接</a></li><li><a href=#344-类型转换>3.4.4 类型转换</a></li><li><a href=#345-小结>3.4.5 小结</a></li><li><a href=#346-延伸阅读>3.4.6 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=34-字符串>3.4 字符串
<a class=anchor href=#34-%e5%ad%97%e7%ac%a6%e4%b8%b2>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>字符串是 Go 语言中的基础数据类型，虽然字符串往往被看做一个整体，但是它实际上是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，本节会详细介绍字符串的实现原理、转换过程以及常见操作的实现。</p><p>字符串是由字符组成的数组，C 语言中的字符串使用字符数组 <code>char[]</code> 表示。数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，Go 语言中的字符串只是一个只读的字节数组，下图展示了 <code>"hello"</code> 字符串在内存中的存储方式：</p><p><img src=https://img.draveness.me/2019-12-31-15777265631608-in-memory-string.png alt=in-memory-string></p><p><strong>图 3-18 内存中的字符串</strong></p><p>如果是代码中存在的字符串，编译器会将其标记成只读数据 <code>SRODATA</code>，假设我们有以下代码，其中包含了一个字符串，当我们将这段代码编译成汇编语言时，就能够看到 <code>hello</code> 字符串有一个 <code>SRODATA</code> 的标记：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ cat main.go
package main

func main<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
	str :<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>
	println<span style=color:#f92672>([]</span>byte<span style=color:#f92672>(</span>str<span style=color:#f92672>))</span>
<span style=color:#f92672>}</span>

$ GOOS<span style=color:#f92672>=</span>linux GOARCH<span style=color:#f92672>=</span>amd64 go tool compile -S main.go
...
go.string.<span style=color:#e6db74>&#34;hello&#34;</span> SRODATA dupok size<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>
	0x0000 <span style=color:#ae81ff>68</span> <span style=color:#ae81ff>65</span> 6c 6c 6f                                   hello
...
</code></pre></div><p>只读只意味着字符串会分配到只读的内存空间，但是 Go 语言只是不支持直接修改 <code>string</code> 类型变量的内存空间，我们仍然可以通过在 <code>string</code> 和 <code>[]byte</code> 类型之间反复转换实现修改这一目的：</p><ol><li>先将这段内存拷贝到堆或者栈上；</li><li>将变量的类型转换成 <code>[]byte</code> 后并修改字节数据；</li><li>将修改后的字节数组转换回 <code>string</code>；</li></ol><p>Java、Python 以及很多编程语言的字符串也都是不可变的，这种不可变的特性可以保证我们不会引用到意外发生改变的值，而因为 Go 语言的字符串可以作为哈希的键，所以如果哈希的键是可变的，不仅会增加哈希实现的复杂度，还可能会影响哈希的比较。</p><h2 id=341-数据结构>3.4.1 数据结构
<a class=anchor href=#341-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p>字符串在 Go 语言中的接口其实非常简单，每一个字符串在运行时都会使用如下的 <a href=/golang/tree/reflect.StringHeader><code>reflect.StringHeader</code></a> 表示，其中包含指向字节数组的指针和数组的大小：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>StringHeader</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Data</span> <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>Len</span>  <span style=color:#66d9ef>int</span>
}
</code></pre></div><p>与切片的结构体相比，字符串只少了一个表示容量的 <code>Cap</code> 字段，而正是因为切片在 Go 语言的运行时表示与字符串高度相似，所以我们经常会说字符串是一个只读的切片类型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>SliceHeader</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Data</span> <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>Len</span>  <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>Cap</span>  <span style=color:#66d9ef>int</span>
}
</code></pre></div><p>因为字符串作为只读的类型，我们并不会直接向字符串直接追加元素改变其本身的内存空间，所有在字符串上的写入操作都是通过拷贝实现的。</p><h2 id=342-解析过程>3.4.2 解析过程
<a class=anchor href=#342-%e8%a7%a3%e6%9e%90%e8%bf%87%e7%a8%8b>#</a></h2><p>解析器会在<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>词法分析</a>阶段解析字符串，词法分析阶段会对源文件中的字符串进行切片和分组，将原有无意义的字符流转换成 Token 序列。我们可以使用两种字面量方式在 Go 语言中声明字符串，即双引号和反引号:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>str1</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;this is a string&#34;</span>
<span style=color:#a6e22e>str2</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>`this is another
</span><span style=color:#e6db74>string`</span>
</code></pre></div><p>使用双引号声明的字符串和其他语言中的字符串没有太多的区别，它只能用于单行字符串的初始化，如果字符串内部出现双引号，需要使用 <code>\</code> 符号避免编译器的解析错误，而反引号声明的字符串可以摆脱单行的限制。当使用反引号时，因为双引号不再负责标记字符串的开始和结束，我们可以在字符串内部直接使用 <code>"</code>，在遇到需要手写 JSON 或者其他复杂数据格式的场景下非常方便。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>json</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>`{&#34;author&#34;: &#34;draven&#34;, &#34;tags&#34;: [&#34;golang&#34;]}`</span>
</code></pre></div><p>两种不同的声明方式其实也意味着 Go 语言编译器需要能够区分并且正确解析两种不同的字符串格式。解析字符串使用的扫描器 <a href=/golang/tree/cmd/compile/internal/syntax.scanner><code>cmd/compile/internal/syntax.scanner</code></a> 会将输入的字符串转换成 Token 流，<a href=/golang/tree/cmd/compile/internal/syntax.scanner.stdString><code>cmd/compile/internal/syntax.scanner.stdString</code></a> 方法是它用来解析使用双引号的标准字符串：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>scanner</span>) <span style=color:#a6e22e>stdString</span>() {
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>startLit</span>()
	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>getr</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;&#34;&#39;</span> {
			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\\&#39;</span> {
			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>escape</span>(<span style=color:#e6db74>&#39;&#34;&#39;</span>)
			<span style=color:#66d9ef>continue</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span> {
			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ungetr</span>()
			<span style=color:#a6e22e>s</span>.error(<span style=color:#e6db74>&#34;newline in string&#34;</span>)
			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> &lt; <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>errh</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>line</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>col</span>, <span style=color:#e6db74>&#34;string not terminated&#34;</span>)
			<span style=color:#66d9ef>break</span>
		}
	}
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nlsemi</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>lit</span> = string(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>stopLit</span>())
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>kind</span> = <span style=color:#a6e22e>StringLit</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tok</span> = <span style=color:#a6e22e>_Literal</span>
}
</code></pre></div><p>从这个方法的实现我们能分析出 Go 语言处理标准字符串的逻辑：</p><ol><li>标准字符串使用双引号表示开头和结尾；</li><li>标准字符串需要使用反斜杠 <code>\</code> 来逃逸双引号；</li><li>标准字符串不能出现如下所示的隐式换行 <code>\n</code>；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>str</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;start
</span><span style=color:#e6db74>end&#34;</span>
</code></pre></div><p>使用反引号声明的原始字符串的解析规则就非常简单了，<a href=/golang/tree/cmd/compile/internal/syntax.scanner.rawString><code>cmd/compile/internal/syntax.scanner.rawString</code></a> 会将非反引号的所有字符都划分到当前字符串的范围中，所以我们可以使用它支持复杂的多行字符串：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>scanner</span>) <span style=color:#a6e22e>rawString</span>() {
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>startLit</span>()
	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>getr</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;`&#39;</span> {
			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> &lt; <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>errh</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>line</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>col</span>, <span style=color:#e6db74>&#34;string not terminated&#34;</span>)
			<span style=color:#66d9ef>break</span>
		}
	}
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>nlsemi</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>lit</span> = string(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>stopLit</span>())
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>kind</span> = <span style=color:#a6e22e>StringLit</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tok</span> = <span style=color:#a6e22e>_Literal</span>
}
</code></pre></div><p>无论是标准字符串还是原始字符串都会被标记成 <code>StringLit</code> 并传递到语法分析阶段。在语法分析阶段，与字符串相关的表达式都会由 <a href=/golang/tree/cmd/compile/internal/gc.noder.basicLit><code>cmd/compile/internal/gc.noder.basicLit</code></a> 方法处理：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>noder</span>) <span style=color:#a6e22e>basicLit</span>(<span style=color:#a6e22e>lit</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>syntax</span>.<span style=color:#a6e22e>BasicLit</span>) <span style=color:#a6e22e>Val</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lit</span>.<span style=color:#a6e22e>Value</span>; <span style=color:#a6e22e>lit</span>.<span style=color:#a6e22e>Kind</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>syntax</span>.<span style=color:#a6e22e>StringLit</span>:
		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>s</span>) &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;`&#39;</span> {
			<span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Replace</span>(<span style=color:#a6e22e>s</span>, <span style=color:#e6db74>&#34;\r&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
		}
		<span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Unquote</span>(<span style=color:#a6e22e>s</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Val</span>{<span style=color:#a6e22e>U</span>: <span style=color:#a6e22e>u</span>}
	}
}
</code></pre></div><p>无论是 <code>import</code> 语句中包的路径、结构体中的字段标签还是表达式中的字符串都会使用这个方法将原生字符串中最后的换行符删除并对字符串 Token 进行 Unquote，也就是去掉字符串两边的引号等无关干扰，还原其本来的面目。</p><p><a href=/golang/tree/strconv.Unquote><code>strconv.Unquote</code></a> 处理了很多边界条件导致实现非常复杂，其中不仅包括引号，还包括 UTF-8 等编码的处理逻辑，这里也就不展开介绍了。</p><h2 id=343-拼接>3.4.3 拼接
<a class=anchor href=#343-%e6%8b%bc%e6%8e%a5>#</a></h2><p>Go 语言拼接字符串会使用 <code>+</code> 符号，编译器会将该符号对应的 <code>OADD</code> 节点转换成 <code>OADDSTR</code> 类型的节点，随后在 <a href=/golang/tree/cmd/compile/internal/gc.walkexpr><code>cmd/compile/internal/gc.walkexpr</code></a> 中调用 <a href=/golang/tree/cmd/compile/internal/gc.addstr><code>cmd/compile/internal/gc.addstr</code></a> 函数生成用于拼接字符串的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkexpr</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OADDSTR</span>:
		<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>addstr</span>(<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>init</span>)
	}
}
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/gc.addstr><code>cmd/compile/internal/gc.addstr</code></a> 能帮助我们在编译期间选择合适的函数对字符串进行拼接，该函数会根据带拼接的字符串数量选择不同的逻辑：</p><ul><li>如果小于或者等于 5 个，那么会调用 <code>concatstring{2,3,4,5}</code> 等一系列函数；</li><li>如果超过 5 个，那么会选择 <a href=/golang/tree/runtime.concatstrings><code>runtime.concatstrings</code></a> 传入一个数组切片；</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addstr</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Len</span>()

	<span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nodnil</span>()
	<span style=color:#a6e22e>args</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>buf</span>}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>n2</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Slice</span>() {
		<span style=color:#a6e22e>args</span> = append(<span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>conv</span>(<span style=color:#a6e22e>n2</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TSTRING</span>]))
	}

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>string</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>5</span> {
		<span style=color:#a6e22e>fn</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;concatstring%d&#34;</span>, <span style=color:#a6e22e>c</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>fn</span> = <span style=color:#e6db74>&#34;concatstrings&#34;</span>

		<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewSlice</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TSTRING</span>])
		<span style=color:#a6e22e>slice</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OCOMPLIT</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>typenod</span>(<span style=color:#a6e22e>t</span>))
		<span style=color:#a6e22e>slice</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>1</span>:])
		<span style=color:#a6e22e>args</span> = []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>slice</span>}
	}

	<span style=color:#a6e22e>cat</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syslook</span>(<span style=color:#a6e22e>fn</span>)
	<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OCALL</span>, <span style=color:#a6e22e>cat</span>, <span style=color:#66d9ef>nil</span>)
	<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>args</span>)
	<span style=color:#f92672>...</span>

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>
}
</code></pre></div><p>其实无论使用 <code>concatstring{2,3,4,5}</code> 中的哪一个，最终都会调用 <a href=/golang/tree/runtime.concatstrings><code>runtime.concatstrings</code></a>，它会先对遍历传入的切片参数，再过滤空字符串并计算拼接后字符串的长度。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>concatstrings</span>(<span style=color:#a6e22e>buf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>tmpBuf</span>, <span style=color:#a6e22e>a</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#a6e22e>idx</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>a</span> {
		<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>x</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>continue</span>
		}
		<span style=color:#a6e22e>l</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>n</span>
		<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
		<span style=color:#a6e22e>idx</span> = <span style=color:#a6e22e>i</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>buf</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> !<span style=color:#a6e22e>stringDataOnStack</span>(<span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>idx</span>])) {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>idx</span>]
	}
	<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rawstringtmp</span>(<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>l</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>a</span> {
		copy(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>x</span>)
		<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>[len(<span style=color:#a6e22e>x</span>):]
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
}
</code></pre></div><p>如果非空字符串的数量为 1 并且当前的字符串不在栈上，就可以直接返回该字符串，不需要做出额外操作。</p><p><img src=https://img.draveness.me/2019-12-31-15777265631620-string-concat-and-copy.png alt=string-concat-and-copy></p><p><strong>图 3-19 字符串的拼接和拷贝</strong></p><p>但是在正常情况下，运行时会调用 <code>copy</code> 将输入的多个字符串拷贝到目标字符串所在的内存空间。新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失是无法忽略的。</p><h2 id=344-类型转换>3.4.4 类型转换
<a class=anchor href=#344-%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2>#</a></h2><p>当我们使用 Go 语言解析和序列化 JSON 等数据格式时，经常需要将数据在 <code>string</code> 和 <code>[]byte</code> 之间来回转换，类型转换的开销并没有想象的那么小，我们经常会看到 <a href=/golang/tree/runtime.slicebytetostring><code>runtime.slicebytetostring</code></a> 等函数出现在火焰图<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>中，成为程序的性能热点。</p><p>从字节数组到字符串的转换需要使用 <a href=/golang/tree/runtime.slicebytetostring><code>runtime.slicebytetostring</code></a> 函数，例如：<code>string(bytes)</code>，该函数在函数体中会先处理两种比较常见的情况，也就是长度为 0 或者 1 的字节数组，这两种情况处理起来都非常简单：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>slicebytetostring</span>(<span style=color:#a6e22e>buf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>tmpBuf</span>, <span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>str</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>b</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>l</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>l</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
		<span style=color:#a6e22e>stringStructOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>str</span>).<span style=color:#a6e22e>str</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>staticbytes</span>[<span style=color:#a6e22e>b</span>[<span style=color:#ae81ff>0</span>]])
		<span style=color:#a6e22e>stringStructOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>str</span>).<span style=color:#a6e22e>len</span> = <span style=color:#ae81ff>1</span>
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>buf</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> len(<span style=color:#a6e22e>b</span>) <span style=color:#f92672>&lt;=</span> len(<span style=color:#a6e22e>buf</span>) {
		<span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>buf</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>mallocgc</span>(uintptr(len(<span style=color:#a6e22e>b</span>)), <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>)
	}
	<span style=color:#a6e22e>stringStructOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>str</span>).<span style=color:#a6e22e>str</span> = <span style=color:#a6e22e>p</span>
	<span style=color:#a6e22e>stringStructOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>str</span>).<span style=color:#a6e22e>len</span> = len(<span style=color:#a6e22e>b</span>)
	<span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>p</span>, (<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slice</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>))).<span style=color:#a6e22e>array</span>, uintptr(len(<span style=color:#a6e22e>b</span>)))
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>处理过后会根据传入的缓冲区大小决定是否需要为新字符串分配一片内存空间，<a href=/golang/tree/runtime.stringStructOf><code>runtime.stringStructOf</code></a> 会将传入的字符串指针转换成 <a href=/golang/tree/runtime.stringStruct><code>runtime.stringStruct</code></a> 结构体指针，然后设置结构体持有的字符串指针 <code>str</code> 和长度 <code>len</code>，最后通过 <a href=/golang/tree/runtime.memmove><code>runtime.memmove</code></a> 将原 <code>[]byte</code> 中的字节全部复制到新的内存空间中。</p><p>当我们想要将字符串转换成 <code>[]byte</code> 类型时，需要使用 <a href=/golang/tree/runtime.stringtoslicebyte><code>runtime.stringtoslicebyte</code></a> 函数，该函数的实现非常容易理解：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>stringtoslicebyte</span>(<span style=color:#a6e22e>buf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>tmpBuf</span>, <span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) []<span style=color:#66d9ef>byte</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>buf</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> len(<span style=color:#a6e22e>s</span>) <span style=color:#f92672>&lt;=</span> len(<span style=color:#a6e22e>buf</span>) {
		<span style=color:#f92672>*</span><span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>tmpBuf</span>{}
		<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>buf</span>[:len(<span style=color:#a6e22e>s</span>)]
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>rawbyteslice</span>(len(<span style=color:#a6e22e>s</span>))
	}
	copy(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>s</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>
}
</code></pre></div><p>上述函数会根据是否传入缓冲区做出不同的处理：</p><ul><li>当传入缓冲区时，它会使用传入的缓冲区存储 <code>[]byte</code>；</li><li>当没有传入缓冲区时，运行时会调用 <a href=/golang/tree/runtime.rawbyteslice><code>runtime.rawbyteslice</code></a> 创建新的字节切片并将字符串中的内容拷贝过去；</li></ul><p><img src=https://img.draveness.me/2019-12-31-15777265631625-string-bytes-conversion.png alt=string-bytes-conversion></p><p><strong>图 3-20 字符串和字节数组的转换</strong></p><p>字符串和 <code>[]byte</code> 中的内容虽然一样，但是字符串的内容是只读的，我们不能通过下标或者其他形式改变其中的数据，而 <code>[]byte</code> 中的内容是可以读写的。不过无论从哪种类型转换到另一种都需要拷贝数据，而内存拷贝的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</p><h2 id=345-小结>3.4.5 小结
<a class=anchor href=#345-%e5%b0%8f%e7%bb%93>#</a></h2><p>字符串是 Go 语言中相对来说比较简单的一种数据结构，我们在这一节中详细分析了字符串与 <code>[]byte</code> 类型的关系，从词法分析阶段理解字符串是如何被解析的，作为只读的数据类型，我们无法改变其本身的结构，但是在做拼接和类型转换等操作时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。</p><h2 id=346-延伸阅读>3.4.6 延伸阅读
<a class=anchor href=#346-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=https://go101.org/article/string.html>Strings in Go</a></li><li><a href=https://blog.golang.org/strings>Strings, bytes, runes and characters in Go</a></li><li><a href=https://en.wikipedia.org/wiki/UTF-8>UTF-8 · Wikipedia</a></li><li><a href=https://stackoverflow.com/questions/29255746/how-encode-rune-into-byte-using-utf8-in-golang>How encode []rune into []byte using utf8 in golang?</a></li><li><a href=https://golang.org/ref/spec#Conversions_to_and_from_a_string_type>Conversions to and from a string type</a></li><li><a href=http://cenalulu.github.io/linux/character-encoding/>十分钟搞清字符集和字符编码</a></li></ul><p><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/ class=book-btn>上一节</a>
<a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>火焰图是一种分析程序性能的手段，Flame Graphs <a href=http://www.brendangregg.com/flamegraphs.html>http://www.brendangregg.com/flamegraphs.html</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-string data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-string",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#34-字符串>3.4 字符串</a><ul><li><a href=#341-数据结构>3.4.1 数据结构</a></li><li><a href=#342-解析过程>3.4.2 解析过程</a></li><li><a href=#343-拼接>3.4.3 拼接</a></li><li><a href=#344-类型转换>3.4.4 类型转换</a></li><li><a href=#345-小结>3.4.5 小结</a></li><li><a href=#346-延伸阅读>3.4.6 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>