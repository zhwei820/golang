<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="4.3 反射 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制简化代码。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 reflect 包能够弥补它在语法上reflect.Type的一些劣势。
reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象1。反射包中有两对非常重要的函数和类型，两个函数分别是：
 reflect.TypeOf 能获取类型信息； reflect.ValueOf 能获取数据的运行时表示；  两个类型是 reflect.Type 和 reflect.Value，它们与函数是一一对应的关系：
图 4-15 反射函数和类型
类型 reflect.Type 是反射包定义的一个接口，我们可以使用 reflect.TypeOf 函数获取任意变量的类型，reflect.Type 接口中定义了一些有趣的方法，MethodByName 可以获取当前类型对应方法的引用、Implements 可以判断当前类型是否实现了某个接口：
type Type interface { Align() int FieldAlign() int Method(int) Method MethodByName(string) (Method, bool) NumMethod() int ... Implements(u Type) bool ... } 反射包中 reflect.Value 的类型与 reflect.Type 不同，它被声明成了结构体。这个结构体没有对外暴露的字段，但是提供了获取或者写入数据的方法："><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言反射的实现原理"><meta property="og:description" content="4.3 反射 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制简化代码。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 reflect 包能够弥补它在语法上reflect.Type的一些劣势。
reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象1。反射包中有两对非常重要的函数和类型，两个函数分别是：
 reflect.TypeOf 能获取类型信息； reflect.ValueOf 能获取数据的运行时表示；  两个类型是 reflect.Type 和 reflect.Value，它们与函数是一一对应的关系：
图 4-15 反射函数和类型
类型 reflect.Type 是反射包定义的一个接口，我们可以使用 reflect.TypeOf 函数获取任意变量的类型，reflect.Type 接口中定义了一些有趣的方法，MethodByName 可以获取当前类型对应方法的引用、Implements 可以判断当前类型是否实现了某个接口：
type Type interface { Align() int FieldAlign() int Method(int) Method MethodByName(string) (Method, bool) NumMethod() int ... Implements(u Type) bool ... } 反射包中 reflect.Value 的类型与 reflect.Type 不同，它被声明成了结构体。这个结构体没有对外暴露的字段，但是提供了获取或者写入数据的方法："><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part2-foundation/ch04-basic/golang-reflect/"><title>Go 语言反射的实现原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言反射的实现原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#43-反射>4.3 反射</a><ul><li><a href=#431-三大法则>4.3.1 三大法则</a><ul><li><a href=#第一法则>第一法则</a></li><li><a href=#第二法则>第二法则</a></li><li><a href=#第三法则>第三法则</a></li></ul></li><li><a href=#432-类型和值>4.3.2 类型和值</a></li><li><a href=#433-更新变量>4.3.3 更新变量</a></li><li><a href=#434-实现协议>4.3.4 实现协议</a></li><li><a href=#435-方法调用>4.3.5 方法调用</a><ul><li><a href=#参数检查>参数检查</a></li><li><a href=#准备参数>准备参数</a></li><li><a href=#调用函数>调用函数</a></li><li><a href=#处理返回值>处理返回值</a></li></ul></li><li><a href=#436-小结>4.3.6 小结</a></li><li><a href=#437-延伸阅读>4.3.7 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=43-反射>4.3 反射
<a class=anchor href=#43-%e5%8f%8d%e5%b0%84>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制简化代码。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 <a href=https://golang.org/pkg/reflect/><code>reflect</code></a> 包能够弥补它在语法上<a href=/golang/tree/reflect.Type><code>reflect.Type</code></a>的一些劣势。</p><p><a href=https://golang.org/pkg/reflect/><code>reflect</code></a> 实现了运行时的反射能力，能够让程序操作不同类型的对象<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。反射包中有两对非常重要的函数和类型，两个函数分别是：</p><ul><li><a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a> 能获取类型信息；</li><li><a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 能获取数据的运行时表示；</li></ul><p>两个类型是 <a href=/golang/tree/reflect.Type><code>reflect.Type</code></a> 和 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a>，它们与函数是一一对应的关系：</p><p><img src=https://img.draveness.me/golang-reflection.png alt=golang-reflection></p><p><strong>图 4-15 反射函数和类型</strong></p><p>类型 <a href=/golang/tree/reflect.Type><code>reflect.Type</code></a> 是反射包定义的一个接口，我们可以使用 <a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a> 函数获取任意变量的类型，<a href=/golang/tree/reflect.Type><code>reflect.Type</code></a> 接口中定义了一些有趣的方法，<code>MethodByName</code> 可以获取当前类型对应方法的引用、<code>Implements</code> 可以判断当前类型是否实现了某个接口：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Type</span> <span style=color:#66d9ef>interface</span> {
        <span style=color:#a6e22e>Align</span>() <span style=color:#66d9ef>int</span>
        <span style=color:#a6e22e>FieldAlign</span>() <span style=color:#66d9ef>int</span>
        <span style=color:#a6e22e>Method</span>(<span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>Method</span>
        <span style=color:#a6e22e>MethodByName</span>(<span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Method</span>, <span style=color:#66d9ef>bool</span>)
        <span style=color:#a6e22e>NumMethod</span>() <span style=color:#66d9ef>int</span>
        <span style=color:#f92672>...</span>
        <span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>u</span> <span style=color:#a6e22e>Type</span>) <span style=color:#66d9ef>bool</span>
        <span style=color:#f92672>...</span>
}
</code></pre></div><p>反射包中 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 的类型与 <a href=/golang/tree/reflect.Type><code>reflect.Type</code></a> 不同，它被声明成了结构体。这个结构体没有对外暴露的字段，但是提供了获取或者写入数据的方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Value</span> <span style=color:#66d9ef>struct</span> {
        <span style=color:#75715e>// 包含过滤的或者未导出的字段
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Addr</span>() <span style=color:#a6e22e>Value</span>
<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Bool</span>() <span style=color:#66d9ef>bool</span>
<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Bytes</span>() []<span style=color:#66d9ef>byte</span>
<span style=color:#f92672>...</span>
</code></pre></div><p>反射包中的所有方法基本都是围绕着 <a href=/golang/tree/reflect.Type><code>reflect.Type</code></a> 和 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 两个类型设计的。我们通过 <a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a>、<a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 可以将一个普通的变量转换成反射包中提供的 <a href=/golang/tree/reflect.Type><code>reflect.Type</code></a> 和 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a>，随后就可以使用反射包中的方法对它们进行复杂的操作。</p><h2 id=431-三大法则>4.3.1 三大法则
<a class=anchor href=#431-%e4%b8%89%e5%a4%a7%e6%b3%95%e5%88%99>#</a></h2><p>运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢。我们在这一节中会介绍 Go 语言反射的三大法则<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，其中包括：</p><ol><li>从 <code>interface{}</code> 变量可以反射出反射对象；</li><li>从反射对象可以获取 <code>interface{}</code> 变量；</li><li>要修改反射对象，其值必须可设置；</li></ol><h3 id=第一法则>第一法则
<a class=anchor href=#%e7%ac%ac%e4%b8%80%e6%b3%95%e5%88%99>#</a></h3><p>反射的第一法则是我们能将 Go 语言的 <code>interface{}</code> 变量转换成反射对象。很多读者可能会对这以法则产生困惑 — 为什么是从 <code>interface{}</code> 变量到反射对象？当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是由于 <a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a>、<a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 两个方法的入参都是 <code>interface{}</code> 类型，所以在方法执行的过程中发生了类型转换。</p><p>因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface{}</code> 类型，这也就是为什么第一条法则是从接口到反射对象。</p><p>上面提到的 <a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a> 和 <a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 函数就能完成这里的转换，如果我们认为 Go 语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。</p><p><img src=https://img.draveness.me/golang-interface-to-reflection.png alt=golang-interface-to-reflection></p><p><strong>图 4-16 接口到反射对象</strong></p><p>我们可以通过以下例子简单介绍它们的作用，<a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a> 获取了变量 <code>author</code> 的类型，<a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 获取了变量的值 <code>draven</code>。如果我们知道了一个变量的类型和值，那么就意味着我们知道了这个变量的全部信息。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;reflect&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>author</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;draven&#34;</span>
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;TypeOf author:&#34;</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>author</span>))
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;ValueOf author:&#34;</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>author</span>))
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>TypeOf</span> <span style=color:#a6e22e>author</span>: <span style=color:#66d9ef>string</span>
<span style=color:#a6e22e>ValueOf</span> <span style=color:#a6e22e>author</span>: <span style=color:#a6e22e>draven</span>
</code></pre></div><p>有了变量的类型之后，我们可以通过 <code>Method</code> 方法获得类型实现的方法，通过 <code>Field</code> 获取类型包含的全部字段。对于不同的类型，我们也可以调用不同的方法获取相关信息：</p><ul><li>结构体：获取字段的数量并通过下标和字段名获取字段 <code>StructField</code>；</li><li>哈希表：获取哈希表的 <code>Key</code> 类型；</li><li>函数或方法：获取入参和返回值的类型；</li><li>&mldr;</li></ul><p>总而言之，使用 <a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a> 和 <a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 能够获取 Go 语言中的变量对应的反射对象。一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。</p><h3 id=第二法则>第二法则
<a class=anchor href=#%e7%ac%ac%e4%ba%8c%e6%b3%95%e5%88%99>#</a></h3><p>反射的第二法则是我们可以从反射对象可以获取 <code>interface{}</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<a href=https://golang.org/pkg/reflect/><code>reflect</code></a> 中的 <a href=/golang/tree/reflect.Value.Interface><code>reflect.Value.Interface</code></a> 就能完成这项工作：</p><p><img src=https://img.draveness.me/golang-reflection-to-interface.png alt=golang-reflection-to-interface></p><p><strong>图 4-17 反射对象到接口</strong></p><p>不过调用 <a href=/golang/tree/reflect.Value.Interface><code>reflect.Value.Interface</code></a> 方法只能获得 <code>interface{}</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#ae81ff>1</span>)
<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Interface</span>().(<span style=color:#66d9ef>int</span>)
</code></pre></div><p>从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p><ul><li>从接口值到反射对象：<ul><li>从基本类型到接口类型的类型转换；</li><li>从接口类型到反射对象的转换；</li></ul></li><li>从反射对象到接口值：<ul><li>反射对象转换成接口类型；</li><li>通过显式类型转换变成原始类型；</li></ul></li></ul><p><img src=https://img.draveness.me/golang-bidirectional-reflection.png alt=golang-bidirectional-reflection></p><p><strong>图 4-18 接口和反射对象的双向转换</strong></p><p>当然不是所有的变量都需要类型转换这一过程。如果变量本身就是 <code>interface{}</code> 类型的，那么它不需要类型转换，因为类型转换这一过程一般都是隐式的，所以我不太需要关心它，只有在我们需要将反射对象转换回基本类型时才需要显式的转换操作。</p><h3 id=第三法则>第三法则
<a class=anchor href=#%e7%ac%ac%e4%b8%89%e6%b3%95%e5%88%99>#</a></h3><p>Go 语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a>，那么它持有的值一定是可以被更新的，假设我们有以下代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>i</span>)
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>SetInt</span>(<span style=color:#ae81ff>10</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>panic</span>: <span style=color:#a6e22e>reflect</span>: <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>mustBeAssignable</span> <span style=color:#a6e22e>using</span> <span style=color:#a6e22e>unaddressable</span> <span style=color:#a6e22e>value</span>

<span style=color:#a6e22e>goroutine</span> <span style=color:#ae81ff>1</span> [<span style=color:#a6e22e>running</span>]:
<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>mustBeAssignableSlow</span>(<span style=color:#ae81ff>0x82</span>, <span style=color:#ae81ff>0x1014c0</span>)
	<span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>local</span><span style=color:#f92672>/</span><span style=color:#66d9ef>go</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>reflect</span><span style=color:#f92672>/</span><span style=color:#a6e22e>value</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>247</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0x180</span>
<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>mustBeAssignable</span>(<span style=color:#f92672>...</span>)
	<span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>local</span><span style=color:#f92672>/</span><span style=color:#66d9ef>go</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>reflect</span><span style=color:#f92672>/</span><span style=color:#a6e22e>value</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>234</span>
<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>.<span style=color:#a6e22e>SetInt</span>(<span style=color:#ae81ff>0x100dc0</span>, <span style=color:#ae81ff>0x414020</span>, <span style=color:#ae81ff>0x82</span>, <span style=color:#ae81ff>0x1840</span>, <span style=color:#ae81ff>0xa</span>, <span style=color:#ae81ff>0x0</span>)
	<span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>local</span><span style=color:#f92672>/</span><span style=color:#66d9ef>go</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>reflect</span><span style=color:#f92672>/</span><span style=color:#a6e22e>value</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>1606</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0x40</span>
<span style=color:#a6e22e>main</span>.<span style=color:#a6e22e>main</span>()
	<span style=color:#f92672>/</span><span style=color:#a6e22e>tmp</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sandbox590309925</span><span style=color:#f92672>/</span><span style=color:#a6e22e>prog</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>11</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0xe0</span>
</code></pre></div><p>运行上述代码会导致程序崩溃并报出 &ldquo;reflect: reflect.flag.mustBeAssignable using unaddressable value&rdquo; 错误，仔细思考一下就能够发现出错的原因：由于 Go 语言的函数调用都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系，那么直接修改反射对象无法改变原始变量，程序为了防止错误就会崩溃。</p><p>想要修改原变量只能使用如下的方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>)
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Elem</span>().<span style=color:#a6e22e>SetInt</span>(<span style=color:#ae81ff>10</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#66d9ef>go</span>
<span style=color:#ae81ff>10</span>
</code></pre></div><ol><li>调用 <a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 获取变量指针；</li><li>调用 <a href=/golang/tree/reflect.Value.Elem><code>reflect.Value.Elem</code></a> 获取指针指向的变量；</li><li>调用 <a href=/golang/tree/reflect.Value.SetInt><code>reflect.Value.SetInt</code></a> 更新变量的值：</li></ol><p>由于 Go 语言的函数调用都是值传递的，所以我们只能只能用迂回的方式改变原变量：先获取指针对应的 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a>，再通过 <a href=/golang/tree/reflect.Value.Elem><code>reflect.Value.Elem</code></a> 方法得到可以被设置的变量，我们可以通过下面的代码理解这个过程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>
	<span style=color:#f92672>*</span><span style=color:#a6e22e>v</span> = <span style=color:#ae81ff>10</span>
}
</code></pre></div><p>如果不能直接操作 <code>i</code> 变量修改其持有的值，我们就只能获取 <code>i</code> 变量所在地址并使用 <code>*v</code> 修改所在地址中存储的整数。</p><h2 id=432-类型和值>4.3.2 类型和值
<a class=anchor href=#432-%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%80%bc>#</a></h2><p>Go 语言的 <code>interface{}</code> 类型在语言内部是通过 <a href=/golang/tree/reflect.emptyInterface><code>reflect.emptyInterface</code></a> 结体表示的，其中的 <code>rtype</code> 字段用于表示变量的类型，另一个 <code>word</code> 字段指向内部封装的数据：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>emptyInterface</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>typ</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>
	<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
}
</code></pre></div><p>用于获取变量类型的 <a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a> 函数将传入的变量隐式转换成 <a href=/golang/tree/reflect.emptyInterface><code>reflect.emptyInterface</code></a> 类型并获取其中存储的类型信息 <a href=/golang/tree/reflect.rtype><code>reflect.rtype</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Type</span> {
	<span style=color:#a6e22e>eface</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyInterface</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>))
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>toType</span>(<span style=color:#a6e22e>eface</span>.<span style=color:#a6e22e>typ</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>toType</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>) <span style=color:#a6e22e>Type</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>
}
</code></pre></div><p><a href=/golang/tree/reflect.rtype><code>reflect.rtype</code></a> 是一个实现了 <a href=/golang/tree/reflect.Type><code>reflect.Type</code></a> 接口的结构体，该结构体实现的 <a href=/golang/tree/reflect.rtype.String><code>reflect.rtype.String</code></a> 方法可以帮助我们获取当前类型的名称：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>) <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span> {
	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>nameOff</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>str</span>).<span style=color:#a6e22e>name</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>tflag</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>tflagExtraStar</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:]
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
}
</code></pre></div><p><a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a> 的实现原理其实并不复杂，它只是将一个 <code>interface{}</code> 变量转换成了内部的 <a href=/golang/tree/reflect.emptyInterface><code>reflect.emptyInterface</code></a> 表示，然后从中获取相应的类型信息。</p><p>用于获取接口值 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 的函数 <a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 实现也非常简单，在该函数中我们先调用了 <a href=/golang/tree/reflect.escapes><code>reflect.escapes</code></a> 保证当前值逃逸到堆上，然后通过 <a href=/golang/tree/reflect.unpackEface><code>reflect.unpackEface</code></a> 从接口中获取 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 结构体：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Value</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{}
	}

	<span style=color:#a6e22e>escapes</span>(<span style=color:#a6e22e>i</span>)

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unpackEface</span>(<span style=color:#a6e22e>i</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>unpackEface</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Value</span> {
	<span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyInterface</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>))
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>typ</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{}
	}
	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flag</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Kind</span>())
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ifaceIndir</span>(<span style=color:#a6e22e>t</span>) {
		<span style=color:#a6e22e>f</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>flagIndir</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>word</span>, <span style=color:#a6e22e>f</span>}
}
</code></pre></div><p><a href=/golang/tree/reflect.unpackEface><code>reflect.unpackEface</code></a> 会将传入的接口转换成 <a href=/golang/tree/reflect.emptyInterface><code>reflect.emptyInterface</code></a>，然后将具体类型和指针包装成 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 结构体后返回。</p><p><a href=/golang/tree/reflect.TypeOf><code>reflect.TypeOf</code></a> 和 <a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 的实现都很简单。我们已经分析了这两个函数的实现，现在需要了解编译器在调用函数之前做了哪些工作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;reflect&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>20</span>
	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>i</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>build</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>gcflags</span>=<span style=color:#e6db74>&#34;-S -N&#34;</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#f92672>...</span>
<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>20</span>, <span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_20</span><span style=color:#f92672>+</span><span style=color:#ae81ff>56</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// autotmp = 20
</span><span style=color:#75715e></span><span style=color:#a6e22e>LEAQ</span>	<span style=color:#66d9ef>type</span>.int(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>AX</span>           <span style=color:#75715e>// AX = type.int(SB)
</span><span style=color:#75715e></span><span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_19</span><span style=color:#f92672>+</span><span style=color:#ae81ff>280</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// autotmp_19+280(SP) = type.int(SB)
</span><span style=color:#75715e></span><span style=color:#a6e22e>LEAQ</span>	<span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_20</span><span style=color:#f92672>+</span><span style=color:#ae81ff>56</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>CX</span>  <span style=color:#75715e>// CX = 20
</span><span style=color:#75715e></span><span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>CX</span>, <span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_19</span><span style=color:#f92672>+</span><span style=color:#ae81ff>288</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// autotmp_19+288(SP) = 20
</span><span style=color:#75715e></span><span style=color:#f92672>...</span>
</code></pre></div><p>从上面这段截取的汇编语言，我们可以发现在函数调用之前已经发生了类型转换，上述指令将 <code>int</code> 类型的变量转换成了占用 16 字节 <code>autotmp_19+280(SP) ~ autotmp_19+288(SP)</code> 的接口，两个 <code>LEAQ</code> 指令分别获取了类型的指针 <code>type.int(SB)</code> 以及变量 <code>i</code> 所在的地址。</p><p>当我们想要将一个变量转换成反射对象时，Go 语言会在编译期间完成类型转换，将变量的类型和值转换成了 <code>interface{}</code> 并等待运行期间使用 <a href=https://golang.org/pkg/reflect/><code>reflect</code></a> 包获取接口中存储的信息。</p><h2 id=433-更新变量>4.3.3 更新变量
<a class=anchor href=#433-%e6%9b%b4%e6%96%b0%e5%8f%98%e9%87%8f>#</a></h2><p>当我们想要更新 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 时，就需要调用 <a href=/golang/tree/reflect.Value.Set><code>reflect.Value.Set</code></a> 更新反射对象，该方法会调用 <a href=/golang/tree/reflect.flag.mustBeAssignable><code>reflect.flag.mustBeAssignable</code></a> 和 <a href=/golang/tree/reflect.flag.mustBeExported><code>reflect.flag.mustBeExported</code></a> 分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>x</span> <span style=color:#a6e22e>Value</span>) {
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>mustBeAssignable</span>()
	<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>mustBeExported</span>()
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>target</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>kind</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>Interface</span> {
		<span style=color:#a6e22e>target</span> = <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>ptr</span>
	}
	<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>assignTo</span>(<span style=color:#e6db74>&#34;reflect.Set&#34;</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>, <span style=color:#a6e22e>target</span>)
	<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>ptr</span>)
}
</code></pre></div><p><a href=/golang/tree/reflect.Value.Set><code>reflect.Value.Set</code></a> 会调用 <a href=/golang/tree/reflect.Value.assignTo><code>reflect.Value.assignTo</code></a> 并返回一个新的反射对象，这个返回的反射对象指针会直接覆盖原反射变量。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>assignTo</span>(<span style=color:#a6e22e>context</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>dst</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>, <span style=color:#a6e22e>target</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>Value</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>switch</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>directlyAssignable</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>):
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>fl</span>}
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>implements</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>):
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>Interface</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>IsNil</span>() {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>dst</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>flag</span>(<span style=color:#a6e22e>Interface</span>)}
		}
		<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>valueInterface</span>(<span style=color:#a6e22e>v</span>, <span style=color:#66d9ef>false</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>NumMethod</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>interface</span>{})(<span style=color:#a6e22e>target</span>) = <span style=color:#a6e22e>x</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>ifaceE2I</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>target</span>)
		}
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>flagIndir</span> | <span style=color:#a6e22e>flag</span>(<span style=color:#a6e22e>Interface</span>)}
	}
	panic(<span style=color:#a6e22e>context</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: value of type &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>String</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; is not assignable to type &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>String</span>())
}
</code></pre></div><p><a href=/golang/tree/reflect.Value.assignTo><code>reflect.Value.assignTo</code></a> 会根据当前和被设置的反射对象类型创建一个新的 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 结构体：</p><ul><li>如果两个反射对象的类型是可以被直接替换，就会直接返回目标反射对象；</li><li>如果当前反射对象是接口并且目标对象实现了接口，就会把目标对象简单包装成接口值；</li></ul><p>在变量更新的过程中，<a href=/golang/tree/reflect.Value.assignTo><code>reflect.Value.assignTo</code></a> 返回的 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 中的指针会覆盖当前反射对象中的指针实现变量的更新。</p><h2 id=434-实现协议>4.3.4 实现协议
<a class=anchor href=#434-%e5%ae%9e%e7%8e%b0%e5%8d%8f%e8%ae%ae>#</a></h2><p><a href=https://golang.org/pkg/reflect/><code>reflect</code></a> 包还为我们提供了 <a href=/golang/tree/reflect.rtype.Implements><code>reflect.rtype.Implements</code></a> 方法可以用于判断某些类型是否遵循特定的接口。在 Go 语言中获取结构体的反射类型 <a href=/golang/tree/reflect.Type><code>reflect.Type</code></a> 还是比较容易的，但是想要获得接口类型需要通过以下方式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>((<span style=color:#f92672>*</span>&lt;<span style=color:#66d9ef>interface</span>&gt;)(<span style=color:#66d9ef>nil</span>)).<span style=color:#a6e22e>Elem</span>()
</code></pre></div><p>我们通过一个例子在介绍如何判断一个类型是否实现了某个接口。假设我们需要判断如下代码中的 <code>CustomError</code> 是否实现了 Go 语言标准库中的 <code>error</code> 接口：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CustomError</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>CustomError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>typeOfError</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>((<span style=color:#f92672>*</span><span style=color:#66d9ef>error</span>)(<span style=color:#66d9ef>nil</span>)).<span style=color:#a6e22e>Elem</span>()
	<span style=color:#a6e22e>customErrorPtr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>CustomError</span>{})
	<span style=color:#a6e22e>customError</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>CustomError</span>{})

	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>customErrorPtr</span>.<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>typeOfError</span>)) <span style=color:#75715e>// #=&gt; true
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>customError</span>.<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>typeOfError</span>)) <span style=color:#75715e>// #=&gt; false
</span><span style=color:#75715e></span>}
</code></pre></div><p>上述代码的运行结果正如我们在<a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>接口</a>一节中介绍的：</p><ul><li><code>CustomError</code> 类型并没有实现 <code>error</code> 接口；</li><li><code>*CustomError</code> 指针类型实现了 <code>error</code> 接口；</li></ul><p>抛开上述的执行结果不谈，我们来分析一下 <a href=/golang/tree/reflect.rtype.Implements><code>reflect.rtype.Implements</code></a> 方法的工作原理：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>) <span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>u</span> <span style=color:#a6e22e>Type</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>u</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#e6db74>&#34;reflect: nil type passed to Type.Implements&#34;</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>Interface</span> {
		panic(<span style=color:#e6db74>&#34;reflect: non-interface type passed to Type.Implements&#34;</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>implements</span>(<span style=color:#a6e22e>u</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>), <span style=color:#a6e22e>t</span>)
}
</code></pre></div><p><a href=/golang/tree/reflect.rtype.Implements><code>reflect.rtype.Implements</code></a> 会检查传入的类型是不是接口，如果不是接口或者是空值就会直接崩溃并中止当前程序。在参数没有问题的情况下，上述方法会调用私有函数 <a href=/golang/tree/reflect.implements><code>reflect.implements</code></a> 判断类型之间是否有实现关系：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>implements</span>(<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>V</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>interfaceType</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>T</span>))
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>methods</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
	}
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>V</span>.<span style=color:#a6e22e>uncommon</span>()
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>vmethods</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>methods</span>()
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> &lt; int(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>mcount</span>); <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>tm</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>methods</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#a6e22e>tmName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>nameOff</span>(<span style=color:#a6e22e>tm</span>.<span style=color:#a6e22e>name</span>)
		<span style=color:#a6e22e>vm</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vmethods</span>[<span style=color:#a6e22e>j</span>]
		<span style=color:#a6e22e>vmName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>V</span>.<span style=color:#a6e22e>nameOff</span>(<span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>name</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>vmName</span>.<span style=color:#a6e22e>name</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>tmName</span>.<span style=color:#a6e22e>name</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>V</span>.<span style=color:#a6e22e>typeOff</span>(<span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>mtyp</span>) <span style=color:#f92672>==</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>typeOff</span>(<span style=color:#a6e22e>tm</span>.<span style=color:#a6e22e>typ</span>) {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> len(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>methods</span>) {
				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
			}
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
}
</code></pre></div><p>如果接口中不包含任何方法，就意味着这是一个空的接口，任意类型都自动实现该接口，这时会直接返回 <code>true</code>。</p><p><img src=https://img.draveness.me/golang-type-implements-interface.png alt=golang-type-implements-interface></p><p><strong>图 4-19 类型实现接口</strong></p><p>在其他情况下，由于方法都是按照字母序存储的，<a href=/golang/tree/reflect.implements><code>reflect.implements</code></a> 会维护两个用于遍历接口和类型方法的索引 <code>i</code> 和 <code>j</code> 判断类型是否实现了接口，因为最多只会进行 <code>n</code> 次比较（类型的方法数量），所以整个过程的时间复杂度是 $O(n)$。</p><h2 id=435-方法调用>4.3.5 方法调用
<a class=anchor href=#435-%e6%96%b9%e6%b3%95%e8%b0%83%e7%94%a8>#</a></h2><p>作为一门静态语言，如果我们想要通过 <a href=https://golang.org/pkg/reflect/><code>reflect</code></a> 包利用反射在运行期间执行方法不是一件容易的事情，下面的十几行代码就使用反射来执行 <code>Add(0, 1)</code> 函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span> }

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>Add</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Func</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Type</span>()
	<span style=color:#a6e22e>argv</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>NumIn</span>())
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>argv</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>In</span>(<span style=color:#a6e22e>i</span>).<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int</span> {
			<span style=color:#66d9ef>return</span>
		}
		<span style=color:#a6e22e>argv</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>i</span>)
	}
	<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Call</span>(<span style=color:#a6e22e>argv</span>)
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>result</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>result</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>result</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Int</span>()) <span style=color:#75715e>// #=&gt; 1
</span><span style=color:#75715e></span>}
</code></pre></div><ol><li>通过 <a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 获取函数 <code>Add</code> 对应的反射对象；</li><li>调用 <a href=/golang/tree/reflect.rtype.NumIn><code>reflect.rtype.NumIn</code></a> 获取函数的入参个数；</li><li>多次调用 <a href=/golang/tree/reflect.ValueOf><code>reflect.ValueOf</code></a> 函数逐一设置 <code>argv</code> 数组中的各个参数；</li><li>调用反射对象 <code>Add</code> 的 <a href=/golang/tree/reflect.Value.Call><code>reflect.Value.Call</code></a> 方法并传入参数列表；</li><li>获取返回值数组、验证数组的长度以及类型并打印其中的数据；</li></ol><p>使用反射来调用方法非常复杂，原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成，但这也是在静态语言中使用动态特性需要付出的成本。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Call</span>(<span style=color:#a6e22e>in</span> []<span style=color:#a6e22e>Value</span>) []<span style=color:#a6e22e>Value</span> {
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>mustBe</span>(<span style=color:#a6e22e>Func</span>)
	<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>mustBeExported</span>()
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>call</span>(<span style=color:#e6db74>&#34;Call&#34;</span>, <span style=color:#a6e22e>in</span>)
}
</code></pre></div><p><a href=/golang/tree/reflect.Value.Call><code>reflect.Value.Call</code></a> 是运行时调用方法的入口，它通过两个 <code>MustBe</code> 开头的方法确定了当前反射对象的类型是函数以及可见性，随后调用 <a href=/golang/tree/reflect.Value.call><code>reflect.Value.call</code></a> 完成方法调用，这个私有方法的执行过程会分成以下的几个部分：</p><ol><li>检查输入参数以及类型的合法性；</li><li>将传入的 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 参数数组设置到栈上；</li><li>通过函数指针和输入参数调用函数；</li><li>从栈上获取函数的返回值；</li></ol><p>我们将按照上面的顺序分析使用 <a href=https://golang.org/pkg/reflect/><code>reflect</code></a> 进行函数调用的几个过程。</p><h3 id=参数检查>参数检查
<a class=anchor href=#%e5%8f%82%e6%95%b0%e6%a3%80%e6%9f%a5>#</a></h3><p>参数检查是通过反射调用方法的第一步，在参数检查期间我们会从反射对象中取出当前的函数指针 <code>unsafe.Pointer</code>，如果该函数指针是方法，那么我们会通过 <a href=/golang/tree/reflect.methodReceiver><code>reflect.methodReceiver</code></a> 获取方法的接收者和函数指针。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>op</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>in</span> []<span style=color:#a6e22e>Value</span>) []<span style=color:#a6e22e>Value</span> {
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>funcType</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>typ</span>))
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>flag</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>flagMethod</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>rcvr</span> = <span style=color:#a6e22e>v</span>
		<span style=color:#a6e22e>rcvrtype</span>, <span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>fn</span> = <span style=color:#a6e22e>methodReceiver</span>(<span style=color:#a6e22e>op</span>, <span style=color:#a6e22e>v</span>, int(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>flag</span>)<span style=color:#f92672>&gt;&gt;</span><span style=color:#a6e22e>flagMethodShift</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#f92672>...</span>
	}
	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>NumIn</span>()
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>in</span>) &lt; <span style=color:#a6e22e>n</span> {
		panic(<span style=color:#e6db74>&#34;reflect: Call with too few input arguments&#34;</span>)
	}
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>in</span>) &gt; <span style=color:#a6e22e>n</span> {
		panic(<span style=color:#e6db74>&#34;reflect: Call with too many input arguments&#34;</span>)
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>xt</span>, <span style=color:#a6e22e>targ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>in</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Type</span>(), <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>In</span>(<span style=color:#a6e22e>i</span>); !<span style=color:#a6e22e>xt</span>.<span style=color:#a6e22e>AssignableTo</span>(<span style=color:#a6e22e>targ</span>) {
			panic(<span style=color:#e6db74>&#34;reflect: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; using &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>xt</span>.<span style=color:#a6e22e>String</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; as type &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>targ</span>.<span style=color:#a6e22e>String</span>())
		}
	}
</code></pre></div><p>上述方法还会检查传入参数的个数以及参数的类型与函数签名中的类型是否可以匹配，任何参数的不匹配都会导致整个程序的崩溃中止。</p><h3 id=准备参数>准备参数
<a class=anchor href=#%e5%87%86%e5%a4%87%e5%8f%82%e6%95%b0>#</a></h3><p>当我们已经对当前方法的参数完成验证后，就会进入函数调用的下一个阶段，为函数调用准备参数，在前面函数调用一节中，我们已经介绍过 Go 语言的函数调用惯例，函数或者方法在调用时，所有的参数都会被依次放到栈上。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>nout</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>NumOut</span>()
	<span style=color:#a6e22e>frametype</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>retOffset</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>framePool</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>funcLayout</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>rcvrtype</span>)

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>args</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nout</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>args</span> = <span style=color:#a6e22e>framePool</span>.<span style=color:#a6e22e>Get</span>().(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>args</span> = <span style=color:#a6e22e>unsafe_New</span>(<span style=color:#a6e22e>frametype</span>)
	}
	<span style=color:#a6e22e>off</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rcvrtype</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>storeRcvr</span>(<span style=color:#a6e22e>rcvr</span>, <span style=color:#a6e22e>args</span>)
		<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>ptrSize</span>
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>in</span> {
		<span style=color:#a6e22e>targ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>In</span>(<span style=color:#a6e22e>i</span>).(<span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>)
		<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>targ</span>.<span style=color:#a6e22e>align</span>)
		<span style=color:#a6e22e>off</span> = (<span style=color:#a6e22e>off</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;^</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
		<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>targ</span>.<span style=color:#a6e22e>size</span>
		<span style=color:#f92672>...</span>
		<span style=color:#a6e22e>addr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>off</span>, <span style=color:#e6db74>&#34;n &gt; 0&#34;</span>)
		<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>assignTo</span>(<span style=color:#e6db74>&#34;reflect.Value.Call&#34;</span>, <span style=color:#a6e22e>targ</span>, <span style=color:#a6e22e>addr</span>)
		<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>addr</span>) = <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>ptr</span>
		<span style=color:#a6e22e>off</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>n</span>
	}
</code></pre></div><ol><li>通过 <a href=/golang/tree/reflect.funcLayout><code>reflect.funcLayout</code></a> 计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小；</li><li>如果当前函数有返回值，需要为当前函数的参数和返回值分配一片内存空间 <code>args</code>；</li><li>如果当前函数是方法，需要向将方法的接收接收者者拷贝到 <code>args</code> 内存中；</li><li>将所有函数的参数按照顺序依次拷贝到对应 <code>args</code> 内存中<ol><li>使用 <a href=/golang/tree/reflect.funcLayout><code>reflect.funcLayout</code></a> 返回的参数计算参数在内存中的位置；</li><li>将参数拷贝到内存空间中；</li></ol></li></ol><p>准备参数是计算各个参数和返回值占用的内存空间并将所有的参数都拷贝内存空间对应位置的过程，该过程会考虑函数和方法、返回值数量以及参数类型带来的差异。</p><h3 id=调用函数>调用函数
<a class=anchor href=#%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0>#</a></h3><p>准备好调用函数需要的全部参数后，就会通过下面的代码执行函数指针了。我们会向该函数传入栈类型、函数指针、参数和返回值的内存空间、栈的大小以及返回值的偏移量：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>frametype</span>, <span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>args</span>, uint32(<span style=color:#a6e22e>frametype</span>.<span style=color:#a6e22e>size</span>), uint32(<span style=color:#a6e22e>retOffset</span>))
</code></pre></div><p>上述函数实际上并不存在，它会在编译期间链接到 <a href=/golang/tree/reflect.reflectcall><code>reflect.reflectcall</code></a> 这个用汇编实现的函数上，我们在这里不会分析该函数的具体实现，感兴趣的读者可以自行了解其实现原理。</p><h3 id=处理返回值>处理返回值
<a class=anchor href=#%e5%a4%84%e7%90%86%e8%bf%94%e5%9b%9e%e5%80%bc>#</a></h3><p>当函数调用结束之后，就会开始处理函数的返回值：</p><ul><li>如果函数没有任何返回值，会直接清空 <code>args</code> 中的全部内容来释放内存空间；</li><li>如果当前函数有返回值；<ol><li>将 <code>args</code> 中与输入参数有关的内存空间清空；</li><li>创建一个 <code>nout</code> 长度的切片用于保存由反射对象构成的返回值数组；</li><li>从函数对象中获取返回值的类型和内存大小，将 <code>args</code> 内存中的数据转换成 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 类型并存储到切片中；</li></ol></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ret</span> []<span style=color:#a6e22e>Value</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nout</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>frametype</span>, <span style=color:#a6e22e>args</span>)
		<span style=color:#a6e22e>framePool</span>.<span style=color:#a6e22e>Put</span>(<span style=color:#a6e22e>args</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>typedmemclrpartial</span>(<span style=color:#a6e22e>frametype</span>, <span style=color:#a6e22e>args</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>retOffset</span>)
		<span style=color:#a6e22e>ret</span> = make([]<span style=color:#a6e22e>Value</span>, <span style=color:#a6e22e>nout</span>)
		<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>retOffset</span>
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>nout</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
			<span style=color:#a6e22e>tv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Out</span>(<span style=color:#a6e22e>i</span>)
			<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Align</span>())
			<span style=color:#a6e22e>off</span> = (<span style=color:#a6e22e>off</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;^</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Size</span>() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
				<span style=color:#a6e22e>fl</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flagIndir</span> | <span style=color:#a6e22e>flag</span>(<span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Kind</span>())
				<span style=color:#a6e22e>ret</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>common</span>(), <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>off</span>, <span style=color:#e6db74>&#34;tv.Size() != 0&#34;</span>), <span style=color:#a6e22e>fl</span>}
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>ret</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>Zero</span>(<span style=color:#a6e22e>tv</span>)
			}
			<span style=color:#a6e22e>off</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Size</span>()
		}
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ret</span>
}
</code></pre></div><p>由 <a href=/golang/tree/reflect.Value><code>reflect.Value</code></a> 构成的 <code>ret</code> 数组会被返回到调用方，到这里为止使用反射实现函数调用的过程就结束了。</p><h2 id=436-小结>4.3.6 小结
<a class=anchor href=#436-%e5%b0%8f%e7%bb%93>#</a></h2><p>Go 语言的 <a href=https://golang.org/pkg/reflect/><code>reflect</code></a> 包为我们提供了多种能力，包括如何使用反射来动态修改变量、判断类型是否实现了某些接口以及动态调用方法等功能，通过分析反射包中方法的原理能帮助我们理解之前看起来比较怪异、令人困惑的现象。</p><h2 id=437-延伸阅读>4.3.7 延伸阅读
<a class=anchor href=#437-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=https://blog.golang.org/laws-of-reflection>The Laws of Reflection</a></li><li><a href=https://github.com/golang/go/commit/3d1699ea787f38be6088f9a098d6e08dafca9387>runtime: new itab lookup table</a></li><li><a href=https://github.com/golang/go/issues/20505>runtime: need a better itab table</a></li></ul><p><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/ class=book-btn>上一节</a>
<a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Package reflect <a href=https://golang.org/pkg/reflect/>https://golang.org/pkg/reflect/</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>谈元编程与表达能力 <a href=/metaprogramming>/metaprogramming</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>The Laws of Reflection <a href=https://blog.golang.org/laws-of-reflection>https://blog.golang.org/laws-of-reflection</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-reflect data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-reflect",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#43-反射>4.3 反射</a><ul><li><a href=#431-三大法则>4.3.1 三大法则</a><ul><li><a href=#第一法则>第一法则</a></li><li><a href=#第二法则>第二法则</a></li><li><a href=#第三法则>第三法则</a></li></ul></li><li><a href=#432-类型和值>4.3.2 类型和值</a></li><li><a href=#433-更新变量>4.3.3 更新变量</a></li><li><a href=#434-实现协议>4.3.4 实现协议</a></li><li><a href=#435-方法调用>4.3.5 方法调用</a><ul><li><a href=#参数检查>参数检查</a></li><li><a href=#准备参数>准备参数</a></li><li><a href=#调用函数>调用函数</a></li><li><a href=#处理返回值>处理返回值</a></li></ul></li><li><a href=#436-小结>4.3.6 小结</a></li><li><a href=#437-延伸阅读>4.3.7 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>