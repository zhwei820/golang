<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="4.1 函数调用 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执行过程。
4.1.1 调用惯例 #  无论是系统级编程语言 C 和 Go，还是脚本语言 Ruby 和 Python，这些编程语言在调用函数时往往都使用相同的语法：
somefunction(arg0, arg1) 虽然它们调用函数的语法很相似，但是它们的调用惯例却可能大不相同。调用惯例是调用方和被调用方对于参数和返回值传递的约定，本节将为各位读者介绍 C 和 Go 语言的调用惯例。
C 语言 #  我们先来研究 C 语言的调用惯例，使用 gcc1 或者 clang2 将 C 语言编译成汇编代码是分析其调用惯例的最好方法，从汇编语言中可以了解函数调用的具体过程。
gcc 和 clang 编译相同 C 语言代码可能会生成不同的汇编指令，不过生成的代码在结构上不会有太大的区别，所以对只想理解调用惯例的人来说没有太多影响。作者在本节中选择使用 gcc 编译器来编译 C 语言：
$ gcc --version gcc (Ubuntu 4.8.2-19ubuntu1) 4.8.2 Copyright (C) 2013 Free Software Foundation, Inc."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="理解 Go 语言的函数调用"><meta property="og:description" content="4.1 函数调用 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执行过程。
4.1.1 调用惯例 #  无论是系统级编程语言 C 和 Go，还是脚本语言 Ruby 和 Python，这些编程语言在调用函数时往往都使用相同的语法：
somefunction(arg0, arg1) 虽然它们调用函数的语法很相似，但是它们的调用惯例却可能大不相同。调用惯例是调用方和被调用方对于参数和返回值传递的约定，本节将为各位读者介绍 C 和 Go 语言的调用惯例。
C 语言 #  我们先来研究 C 语言的调用惯例，使用 gcc1 或者 clang2 将 C 语言编译成汇编代码是分析其调用惯例的最好方法，从汇编语言中可以了解函数调用的具体过程。
gcc 和 clang 编译相同 C 语言代码可能会生成不同的汇编指令，不过生成的代码在结构上不会有太大的区别，所以对只想理解调用惯例的人来说没有太多影响。作者在本节中选择使用 gcc 编译器来编译 C 语言：
$ gcc --version gcc (Ubuntu 4.8.2-19ubuntu1) 4.8.2 Copyright (C) 2013 Free Software Foundation, Inc."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part2-foundation/ch04-basic/golang-function-call/"><title>理解 Go 语言的函数调用 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>理解 Go 语言的函数调用</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#41-函数调用>4.1 函数调用</a><ul><li><a href=#411-调用惯例>4.1.1 调用惯例</a><ul><li><a href=#c-语言>C 语言</a></li><li><a href=#go-语言>Go 语言</a></li><li><a href=#对比>对比</a></li></ul></li><li><a href=#412-参数传递>4.1.2 参数传递</a><ul><li><a href=#整型和数组>整型和数组</a></li><li><a href=#结构体和指针>结构体和指针</a></li><li><a href=#传值>传值</a></li></ul></li><li><a href=#413-小结>4.1.3 小结</a></li><li><a href=#414-延伸阅读>4.1.4 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=41-函数调用>4.1 函数调用
<a class=anchor href=#41-%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执行过程。</p><h2 id=411-调用惯例>4.1.1 调用惯例
<a class=anchor href=#411-%e8%b0%83%e7%94%a8%e6%83%af%e4%be%8b>#</a></h2><p>无论是系统级编程语言 C 和 Go，还是脚本语言 Ruby 和 Python，这些编程语言在调用函数时往往都使用相同的语法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>somefunction(arg0, arg1)
</code></pre></div><p>虽然它们调用函数的语法很相似，但是它们的调用惯例却可能大不相同。调用惯例是调用方和被调用方对于参数和返回值传递的约定，本节将为各位读者介绍 C 和 Go 语言的调用惯例。</p><h3 id=c-语言>C 语言
<a class=anchor href=#c-%e8%af%ad%e8%a8%80>#</a></h3><p>我们先来研究 C 语言的调用惯例，使用 <a href=https://gcc.gnu.org/>gcc</a><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> 或者 <a href=https://clang.llvm.org/>clang</a><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 将 C 语言编译成汇编代码是分析其调用惯例的最好方法，从汇编语言中可以了解函数调用的具体过程。</p><p>gcc 和 clang 编译相同 C 语言代码可能会生成不同的汇编指令，不过生成的代码在结构上不会有太大的区别，所以对只想理解调用惯例的人来说没有太多影响。作者在本节中选择使用 gcc 编译器来编译 C 语言：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ gcc --version
gcc <span style=color:#f92672>(</span>Ubuntu 4.8.2-19ubuntu1<span style=color:#f92672>)</span> 4.8.2
Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> <span style=color:#ae81ff>2013</span> Free Software Foundation, Inc.
This is free software; see the source <span style=color:#66d9ef>for</span> copying conditions.  There is NO
warranty; not even <span style=color:#66d9ef>for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre></div><p>假设我们有以下的 C 语言代码，代码中只包含两个函数，其中一个是主函数 <code>main</code>，另一个是我们定义的函数 <code>my_function</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// ch04/my_function.c
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>my_function</span>(<span style=color:#66d9ef>int</span> arg1, <span style=color:#66d9ef>int</span> arg2) {
    <span style=color:#66d9ef>return</span> arg1 <span style=color:#f92672>+</span> arg2;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> my_function(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
}
</code></pre></div><p>我们可以使用 <code>cc -S my_function.c</code> 命令将上述文件编译成如下所示的汇编代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>main:
	pushq	<span style=color:#f92672>%</span>rbp
	movq	<span style=color:#f92672>%</span>rsp, <span style=color:#f92672>%</span>rbp
	subq	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>16</span>, <span style=color:#f92672>%</span>rsp
	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#f92672>%</span>esi  <span style=color:#75715e>// 设置第二个参数
</span><span style=color:#75715e></span>	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>%</span>edi  <span style=color:#75715e>// 设置第一个参数
</span><span style=color:#75715e></span>	call	my_function
	movl	<span style=color:#f92672>%</span>eax, <span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>(<span style=color:#f92672>%</span>rbp)
my_function:
	pushq	<span style=color:#f92672>%</span>rbp
	movq	<span style=color:#f92672>%</span>rsp, <span style=color:#f92672>%</span>rbp
	movl	<span style=color:#f92672>%</span>edi, <span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>(<span style=color:#f92672>%</span>rbp)    <span style=color:#75715e>// 取出第一个参数，放到栈上
</span><span style=color:#75715e></span>	movl	<span style=color:#f92672>%</span>esi, <span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>(<span style=color:#f92672>%</span>rbp)    <span style=color:#75715e>// 取出第二个参数，放到栈上
</span><span style=color:#75715e></span>	movl	<span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>(<span style=color:#f92672>%</span>rbp), <span style=color:#f92672>%</span>eax    <span style=color:#75715e>// eax = esi = 1
</span><span style=color:#75715e></span>	movl	<span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>(<span style=color:#f92672>%</span>rbp), <span style=color:#f92672>%</span>edx    <span style=color:#75715e>// edx = edi = 2
</span><span style=color:#75715e></span>	addl	<span style=color:#f92672>%</span>edx, <span style=color:#f92672>%</span>eax        <span style=color:#75715e>// eax = eax + edx = 1 + 2 = 3
</span><span style=color:#75715e></span>	popq	<span style=color:#f92672>%</span>rbp
</code></pre></div><p>我们按照调用前、调用时以及调用后的顺序分析上述调用过程：</p><ul><li>在 <code>my_function</code> 调用前，调用方 <code>main</code> 函数将 <code>my_function</code> 的两个参数分别存到 edi 和 esi 寄存器中；</li><li>在 <code>my_function</code> 调用时，它会将寄存器 edi 和 esi 中的数据存储到 eax 和 edx 两个寄存器中，随后通过汇编指令 <code>addl</code> 计算两个入参之和；</li><li>在 <code>my_function</code> 调用后，使用寄存器 eax 传递返回值，<code>main</code> 函数将 <code>my_function</code> 的返回值存储到栈上的 <code>i</code> 变量中；</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>my_function</span>(<span style=color:#66d9ef>int</span> arg1, <span style=color:#66d9ef>int</span> arg2, <span style=color:#66d9ef>int</span> ... arg8) {
    <span style=color:#66d9ef>return</span> arg1 <span style=color:#f92672>+</span> arg2 <span style=color:#f92672>+</span> ... <span style=color:#f92672>+</span> arg8;
}
</code></pre></div><p>如上述代码所示，当 <code>my_function</code> 函数的入参增加至八个时，重新编译当前程序可以会得到不同的汇编代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>main:
	pushq	<span style=color:#f92672>%</span>rbp
	movq	<span style=color:#f92672>%</span>rsp, <span style=color:#f92672>%</span>rbp
	subq	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>16</span>, <span style=color:#f92672>%</span>rsp     <span style=color:#75715e>// 为参数传递申请 16 字节的栈空间
</span><span style=color:#75715e></span>	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>(<span style=color:#f92672>%</span>rsp)   <span style=color:#75715e>// 传递第 8 个参数
</span><span style=color:#75715e></span>	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>7</span>, (<span style=color:#f92672>%</span>rsp)    <span style=color:#75715e>// 传递第 7 个参数
</span><span style=color:#75715e></span>	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>6</span>, <span style=color:#f92672>%</span>r9d
	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>5</span>, <span style=color:#f92672>%</span>r8d
	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>4</span>, <span style=color:#f92672>%</span>ecx
	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>3</span>, <span style=color:#f92672>%</span>edx
	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#f92672>%</span>esi
	movl	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>%</span>edi
	call	my_function
</code></pre></div><p><code>main</code> 函数调用 <code>my_function</code> 时，前六个参数会使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递。寄存器的使用顺序也是调用惯例的一部分，函数的第一个参数一定会使用 edi 寄存器，第二个参数使用 esi 寄存器，以此类推。</p><p>最后的两个参数与前面的完全不同，调用方 <code>main</code> 函数通过栈传递这两个参数，下图展示了 <code>main</code> 函数在调用 <code>my_function</code> 前的栈信息：</p><p><img src=https://img.draveness.me/2019-01-20-c-function-call-stack.png alt=c-function-call-stack></p><p><strong>图 4-1 C 语言 main 函数的调用栈</strong></p><p>上图中 rbp 寄存器会存储函数调用栈的基址指针，即属于 <code>main</code> 函数的栈空间的起始位置，而另一个寄存器 rsp 存储的是 <code>main</code> 函数调用栈结束的位置，这两个寄存器共同表示了函数的栈空间。</p><p>在调用 <code>my_function</code> 之前，<code>main</code> 函数通过 <code>subq $16, %rsp</code> 指令分配了 16 个字节的栈地址，随后将第六个以上的参数按照从右到左的顺序存入栈中，即第八个和第七个，余下的六个参数会通过寄存器传递，接下来运行的 <code>call my_function</code> 指令会调用 <code>my_function</code> 函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>my_function:
	pushq	<span style=color:#f92672>%</span>rbp
	movq	<span style=color:#f92672>%</span>rsp, <span style=color:#f92672>%</span>rbp
	movl	<span style=color:#f92672>%</span>edi, <span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>(<span style=color:#f92672>%</span>rbp)    <span style=color:#75715e>// rbp-4 = edi = 1
</span><span style=color:#75715e></span>	movl	<span style=color:#f92672>%</span>esi, <span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>(<span style=color:#f92672>%</span>rbp)    <span style=color:#75715e>// rbp-8 = esi = 2
</span><span style=color:#75715e></span>	...
	movl	<span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>(<span style=color:#f92672>%</span>rbp), <span style=color:#f92672>%</span>eax    <span style=color:#75715e>// eax = 2
</span><span style=color:#75715e></span>	movl	<span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>(<span style=color:#f92672>%</span>rbp), <span style=color:#f92672>%</span>edx    <span style=color:#75715e>// edx = 1
</span><span style=color:#75715e></span>	addl	<span style=color:#f92672>%</span>eax, <span style=color:#f92672>%</span>edx        <span style=color:#75715e>// edx = eax + edx = 3
</span><span style=color:#75715e></span>	...
	movl	<span style=color:#ae81ff>16</span>(<span style=color:#f92672>%</span>rbp), <span style=color:#f92672>%</span>eax    <span style=color:#75715e>// eax = 7
</span><span style=color:#75715e></span>	addl	<span style=color:#f92672>%</span>eax, <span style=color:#f92672>%</span>edx        <span style=color:#75715e>// edx = eax + edx = 28
</span><span style=color:#75715e></span>	movl	<span style=color:#ae81ff>24</span>(<span style=color:#f92672>%</span>rbp), <span style=color:#f92672>%</span>eax    <span style=color:#75715e>// eax = 8
</span><span style=color:#75715e></span>	addl	<span style=color:#f92672>%</span>edx, <span style=color:#f92672>%</span>eax        <span style=color:#75715e>// edx = eax + edx = 36
</span><span style=color:#75715e></span>	popq	<span style=color:#f92672>%</span>rbp
</code></pre></div><p><code>my_function</code> 会先将寄存器中的全部数据转移到栈上，然后利用 eax 寄存器计算所有入参的和并返回结果。</p><p>我们可以将本节的发现和分析简单总结成 — 当我们在 x86_64 的机器上使用 C 语言中调用函数时，参数都是通过寄存器和栈传递的，其中：</p><ul><li>六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；</li><li>六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中；</li></ul><p>而函数的返回值是通过 eax 寄存器进行传递的，由于只使用一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。</p><h3 id=go-语言>Go 语言
<a class=anchor href=#go-%e8%af%ad%e8%a8%80>#</a></h3><p>分析了 C 语言函数的调用惯例之后，我们再来剖析一下 Go 语言函数的调用惯例。我们以下面这个非常简单的代码片段为例简单分析一下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>b</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>myFunction</span>(<span style=color:#ae81ff>66</span>, <span style=color:#ae81ff>77</span>)
}
</code></pre></div><p>上述的 <code>myFunction</code> 函数接受两个整数并返回两个整数，<code>main</code> 函数在调用 <code>myFunction</code> 时将 66 和 77 两个参数传递到当前函数中，使用 <code>go tool compile -S -N -l main.go</code> 编译上述代码可以得到如下所示的汇编指令：</p><blockquote><p>如果编译时不使用 -N -l 参数，编译器会对汇编代码进行优化，编译结果会有较大差别。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>main</span> <span style=color:#a6e22e>STEXT</span> <span style=color:#a6e22e>size</span>=<span style=color:#ae81ff>68</span> <span style=color:#a6e22e>args</span>=<span style=color:#ae81ff>0x0</span> <span style=color:#a6e22e>locals</span>=<span style=color:#ae81ff>0x28</span>
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>7</span>)	<span style=color:#a6e22e>MOVQ</span>	(<span style=color:#a6e22e>TLS</span>), <span style=color:#a6e22e>CX</span>
	<span style=color:#ae81ff>0x0009</span> <span style=color:#ae81ff>0000</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>7</span>)	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#a6e22e>SP</span>, <span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>CX</span>)
	<span style=color:#ae81ff>0x000d</span> <span style=color:#ae81ff>00013</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>7</span>)	<span style=color:#a6e22e>JLS</span>	<span style=color:#ae81ff>61</span>
	<span style=color:#ae81ff>0x000f</span> <span style=color:#ae81ff>00015</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>7</span>)	<span style=color:#a6e22e>SUBQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>40</span>, <span style=color:#a6e22e>SP</span>      <span style=color:#75715e>// 分配 40 字节栈空间
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0013</span> <span style=color:#ae81ff>0001</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>7</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>BP</span>, <span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>SP</span>)   <span style=color:#75715e>// 将基址指针存储到栈上
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0018</span> <span style=color:#ae81ff>00024</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>7</span>)	<span style=color:#a6e22e>LEAQ</span>	<span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>BP</span>
	<span style=color:#ae81ff>0x001d</span> <span style=color:#ae81ff>0002</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>8</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>66</span>, (<span style=color:#a6e22e>SP</span>)    <span style=color:#75715e>// 第一个参数
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0025</span> <span style=color:#ae81ff>00037</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>8</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>77</span>, <span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>)   <span style=color:#75715e>// 第二个参数
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x002e</span> <span style=color:#ae81ff>00046</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>8</span>)	<span style=color:#a6e22e>CALL</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#ae81ff>0x0033</span> <span style=color:#ae81ff>00051</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>BP</span>
	<span style=color:#ae81ff>0x0038</span> <span style=color:#ae81ff>00056</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>ADDQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>40</span>, <span style=color:#a6e22e>SP</span>
	<span style=color:#ae81ff>0x003c</span> <span style=color:#ae81ff>00060</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>RET</span>
</code></pre></div><p>根据 <code>main</code> 函数生成的汇编指令，我们可以分析出 <code>main</code> 函数调用 <code>myFunction</code> 之前的栈：</p><p><img src=https://img.draveness.me/2019-01-20-golang-function-call-stack-before-calling.png alt=golang-function-call-stack-before-calling></p><p><strong>图 4-2 Go 语言 main 函数的调用栈</strong></p><p><code>main</code> 函数通过 <code>SUBQ $40, SP</code> 指令一共在栈上分配了 40 字节的内存空间：</p><table><thead><tr><th>空间</th><th>大小</th><th>作用</th></tr></thead><tbody><tr><td>SP+32 ~ BP</td><td>8 字节</td><td><code>main</code> 函数的栈基址指针</td></tr><tr><td>SP+16 ~ SP+32</td><td>16 字节</td><td>函数 <code>myFunction</code> 的两个返回值</td></tr><tr><td>SP ~ SP+16</td><td>16 字节</td><td>函数 <code>myFunction</code> 的两个参数</td></tr></tbody></table><p><strong>表 4-1 主函数调用栈</strong></p><p><code>myFunction</code> 入参的压栈顺序和 C 语言一样，都是从右到左，即第一个参数 66 在栈顶的 SP ~ SP+8，第二个参数存储在 SP+8 ~ SP+16 的空间中。</p><p>当我们准备好函数的入参之后，会调用汇编指令 <code>CALL "".myFunction(SB)</code>，这个指令首先会将 <code>main</code> 的返回地址存入栈中，然后改变当前的栈指针 SP 并执行 <code>myFunction</code> 的汇编指令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>myFunction</span> <span style=color:#a6e22e>STEXT</span> <span style=color:#a6e22e>nosplit</span> <span style=color:#a6e22e>size</span>=<span style=color:#ae81ff>49</span> <span style=color:#a6e22e>args</span>=<span style=color:#ae81ff>0x20</span> <span style=color:#a6e22e>locals</span>=<span style=color:#ae81ff>0x0</span>
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>3</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// 初始化第一个返回值
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0009</span> <span style=color:#ae81ff>0000</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>3</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// 初始化第二个返回值
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0012</span> <span style=color:#ae81ff>0001</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>    <span style=color:#75715e>// AX = 66
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0017</span> <span style=color:#ae81ff>00023</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>ADDQ</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>b</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>   <span style=color:#75715e>// AX = AX + 77 = 143
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x001c</span> <span style=color:#ae81ff>0002</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// (24)SP = AX = 143
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0021</span> <span style=color:#ae81ff>00033</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>    <span style=color:#75715e>// AX = 66
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0026</span> <span style=color:#ae81ff>0003</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>SUBQ</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>b</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>   <span style=color:#75715e>// AX = AX - 77 = -11
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x002b</span> <span style=color:#ae81ff>00043</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// (32)SP = AX = -11
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0030</span> <span style=color:#ae81ff>0004</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>RET</span>
</code></pre></div><p>从上述的汇编代码中我们可以看出，当前函数在执行时首先会将 <code>main</code> 函数中预留的两个返回值地址置成 <code>int</code> 类型的默认值 0，然后根据栈的相对位置获取参数并进行加减操作并将值存回栈中，在 <code>myFunction</code> 函数返回之间，栈中的数据如下图所示：</p><p><img src=https://img.draveness.me/2019-01-20-golang-function-call-stack-before-return.png alt=golang-function-call-stack-before-return></p><p><strong>图 4-3 myFunction 函数返回前的栈</strong></p><p>在 <code>myFunction</code> 返回后，<code>main</code> 函数会通过以下的指令来恢复栈基址指针并销毁已经失去作用的 40 字节栈内存：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    <span style=color:#ae81ff>0x0033</span> <span style=color:#ae81ff>00051</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>BP</span>
    <span style=color:#ae81ff>0x0038</span> <span style=color:#ae81ff>00056</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>ADDQ</span>    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>40</span>, <span style=color:#a6e22e>SP</span>
    <span style=color:#ae81ff>0x003c</span> <span style=color:#ae81ff>00060</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>RET</span>
</code></pre></div><p>通过分析 Go 语言编译后的汇编指令，我们发现 Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。</p><h3 id=对比>对比
<a class=anchor href=#%e5%af%b9%e6%af%94>#</a></h3><p>C 语言和 Go 语言在设计函数的调用惯例时选择了不同的实现。C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。我们可以对比一下这两种设计的优点和缺点：</p><ul><li>C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；<ul><li>CPU 访问栈的开销比访问寄存器高几十倍<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>；</li><li>需要单独处理函数参数过多的情况；</li></ul></li><li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；<ul><li>不需要考虑超过寄存器数量的参数应该如何传递；</li><li>不需要考虑不同架构上的寄存器差异；</li><li>函数入参和出参的内存空间需要在栈上进行分配；</li></ul></li></ul><p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p><h2 id=412-参数传递>4.1.2 参数传递
<a class=anchor href=#412-%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92>#</a></h2><p>除了函数的调用惯例之外，Go 语言在传递参数时是传值还是传引用也是一个有趣的问题，不同的选择会影响我们在函数中修改入参时是否会影响调用方看到的数据。我们先来介绍一下传值和传引用两者的区别：</p><ul><li>传值：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据；</li><li>传引用：函数调用时会传递参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。</li></ul><p>不同语言会选择不同的方式传递参数，Go 语言选择了传值的方式，<strong>无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</strong>。本节剩下的内容将会验证这个结论的正确性。</p><h3 id=整型和数组>整型和数组
<a class=anchor href=#%e6%95%b4%e5%9e%8b%e5%92%8c%e6%95%b0%e7%bb%84>#</a></h3><p>我们先来分析 Go 语言是如何传递基本类型和数组的。如下所示的函数 <code>myFunction</code> 接收了两个参数，整型变量 <code>i</code> 和数组 <code>arr</code>，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 <code>myFunction</code> 函数调用前后分别打印两个参数的地址：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>arr</span> [<span style=color:#ae81ff>2</span>]<span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;in my_funciton - i=(%d, %p) arr=(%v, %p)\n&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>arr</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arr</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>30</span>
	<span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>2</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>66</span>, <span style=color:#ae81ff>77</span>}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;before calling - i=(%d, %p) arr=(%v, %p)\n&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>arr</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arr</span>)
	<span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>arr</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;after  calling - i=(%d, %p) arr=(%v, %p)\n&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>arr</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arr</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>before</span> <span style=color:#a6e22e>calling</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>=(<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>0xc00009a000</span>) <span style=color:#a6e22e>arr</span>=([<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>77</span>], <span style=color:#ae81ff>0xc00009a010</span>)
<span style=color:#a6e22e>in</span> <span style=color:#a6e22e>my_funciton</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>=(<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>0xc00009a008</span>) <span style=color:#a6e22e>arr</span>=([<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>77</span>], <span style=color:#ae81ff>0xc00009a020</span>)
<span style=color:#a6e22e>after</span>  <span style=color:#a6e22e>calling</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>=(<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>0xc00009a000</span>) <span style=color:#a6e22e>arr</span>=([<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>77</span>], <span style=color:#ae81ff>0xc00009a010</span>)
</code></pre></div><p>当我们通过命令运行这段代码时会发现，<code>main</code> 函数和被调用者 <code>myFunction</code> 中参数的地址是完全不同的。</p><p>不过从 <code>main</code> 函数的角度来看，在调用 <code>myFunction</code> 前后，整数 <code>i</code> 和数组 <code>arr</code> 两个参数的地址都没有变化。那么如果我们在 <code>myFunction</code> 函数内部对参数进行修改是否会影响 <code>main</code> 函数中的变量呢？这里更新 <code>myFunction</code> 函数并重新执行这段代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>arr</span> [<span style=color:#ae81ff>2</span>]<span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>29</span>
	<span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>1</span>] = <span style=color:#ae81ff>88</span>
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;in my_funciton - i=(%d, %p) arr=(%v, %p)\n&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>arr</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arr</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>before</span> <span style=color:#a6e22e>calling</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>=(<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>0xc000072008</span>) <span style=color:#a6e22e>arr</span>=([<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>77</span>], <span style=color:#ae81ff>0xc000072010</span>)
<span style=color:#a6e22e>in</span> <span style=color:#a6e22e>my_funciton</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>=(<span style=color:#ae81ff>29</span>, <span style=color:#ae81ff>0xc000072028</span>) <span style=color:#a6e22e>arr</span>=([<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>88</span>], <span style=color:#ae81ff>0xc000072040</span>)
<span style=color:#a6e22e>after</span>  <span style=color:#a6e22e>calling</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>=(<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>0xc000072008</span>) <span style=color:#a6e22e>arr</span>=([<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>77</span>], <span style=color:#ae81ff>0xc000072010</span>)
</code></pre></div><p>我们可以看到在 <code>myFunction</code> 中对参数的修改也仅仅影响了当前函数，并没有影响调用方 <code>main</code> 函数，所以能得出如下结论：<strong>Go 语言的整型和数组类型都是值传递的</strong>，也就是在调用函数时会对内容进行拷贝。需要注意的是如果当前数组的大小非常的大，这种传值的方式会对性能造成比较大的影响。</p><h3 id=结构体和指针>结构体和指针
<a class=anchor href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%92%8c%e6%8c%87%e9%92%88>#</a></h3><p>接下来我们继续分析 Go 语言另外两种常见类型 — 结构体和指针。下面这段代码中定义了一个结构体 <code>MyStruct</code> 以及接受两个参数的 <code>myFunction</code> 方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyStruct</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>a</span> <span style=color:#a6e22e>MyStruct</span>, <span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyStruct</span>) {
	<span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>31</span>
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>41</span>
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;in my_function - a=(%d, %p) b=(%v, %p)\n&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>MyStruct</span>{<span style=color:#a6e22e>i</span>: <span style=color:#ae81ff>30</span>}
	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>MyStruct</span>{<span style=color:#a6e22e>i</span>: <span style=color:#ae81ff>40</span>}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;before calling - a=(%d, %p) b=(%v, %p)\n&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>)
	<span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;after calling  - a=(%d, %p) b=(%v, %p)\n&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>before</span> <span style=color:#a6e22e>calling</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>a</span>=({<span style=color:#ae81ff>30</span>}, <span style=color:#ae81ff>0xc000018178</span>) <span style=color:#a6e22e>b</span>=(<span style=color:#f92672>&amp;</span>{<span style=color:#ae81ff>40</span>}, <span style=color:#ae81ff>0xc00000c028</span>)
<span style=color:#a6e22e>in</span> <span style=color:#a6e22e>my_function</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>a</span>=({<span style=color:#ae81ff>31</span>}, <span style=color:#ae81ff>0xc000018198</span>) <span style=color:#a6e22e>b</span>=(<span style=color:#f92672>&amp;</span>{<span style=color:#ae81ff>41</span>}, <span style=color:#ae81ff>0xc00000c038</span>)
<span style=color:#a6e22e>after</span> <span style=color:#a6e22e>calling</span>  <span style=color:#f92672>-</span> <span style=color:#a6e22e>a</span>=({<span style=color:#ae81ff>30</span>}, <span style=color:#ae81ff>0xc000018178</span>) <span style=color:#a6e22e>b</span>=(<span style=color:#f92672>&amp;</span>{<span style=color:#ae81ff>41</span>}, <span style=color:#ae81ff>0xc00000c028</span>)
</code></pre></div><p>从上述运行的结果我们可以得出如下结论：</p><ul><li>传递结构体时：会拷贝结构体中的全部内容；</li><li>传递结构体指针时：会拷贝结构体指针；</li></ul><p>修改结构体指针是改变了指针指向的结构体，<code>b.i</code> 可以被理解成 <code>(*b).i</code>，也就是我们先获取指针 <code>b</code> 背后的结构体，再修改结构体的成员变量。我们简单修改上述代码，分析一下 Go 语言结构体在内存中的布局：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyStruct</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>ms</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyStruct</span>) {
	<span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>ms</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>2</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>((uintptr(<span style=color:#a6e22e>ptr</span>) <span style=color:#f92672>+</span> uintptr(<span style=color:#ae81ff>8</span><span style=color:#f92672>*</span><span style=color:#a6e22e>i</span>))))
		<span style=color:#f92672>*</span><span style=color:#a6e22e>c</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%p] %d\n&#34;</span>, <span style=color:#a6e22e>c</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>c</span>)
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>MyStruct</span>{<span style=color:#a6e22e>i</span>: <span style=color:#ae81ff>40</span>, <span style=color:#a6e22e>j</span>: <span style=color:#ae81ff>50</span>}
	<span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>a</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%p] %v\n&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>a</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
[<span style=color:#ae81ff>0xc000018180</span>] <span style=color:#ae81ff>41</span>
[<span style=color:#ae81ff>0xc000018188</span>] <span style=color:#ae81ff>52</span>
[<span style=color:#ae81ff>0xc000018180</span>] <span style=color:#f92672>&amp;</span>{<span style=color:#ae81ff>41</span> <span style=color:#ae81ff>52</span>}
</code></pre></div><p>在这段代码中，我们通过指针修改结构体中的成员变量，结构体在内存中是一片连续的空间，指向结构体的指针也是指向这个结构体的首地址。将 <code>MyStruct</code> 指针修改成 <code>int</code> 类型的，那么访问新指针就会返回整型变量 <code>i</code>，将指针移动 8 个字节之后就能获取下一个成员变量 <code>j</code>。</p><p>如果我们将上述代码简化成如下所示的代码片段并使用 <code>go tool compile</code> 进行编译会得到如下的结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyStruct</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>ms</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyStruct</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>MyStruct</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ms</span>
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>tool</span> <span style=color:#a6e22e>compile</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>S</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>N</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>l</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>myFunction</span> <span style=color:#a6e22e>STEXT</span> <span style=color:#a6e22e>nosplit</span> <span style=color:#a6e22e>size</span>=<span style=color:#ae81ff>20</span> <span style=color:#a6e22e>args</span>=<span style=color:#ae81ff>0x10</span> <span style=color:#a6e22e>locals</span>=<span style=color:#ae81ff>0x0</span>
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>8</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// 初始化返回值
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0009</span> <span style=color:#ae81ff>0000</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>ms</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>   <span style=color:#75715e>// 复制引用
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x000e</span> <span style=color:#ae81ff>00014</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// 返回引用
</span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x0013</span> <span style=color:#ae81ff>0001</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>RET</span>
</code></pre></div><p>在这段汇编语言中，我们发现当参数是指针时，也会使用 <code>MOVQ "".ms+8(SP), AX</code> 指令复制引用，然后将复制后的指针作为返回值传递回调用方。</p><p><img src=https://img.draveness.me/2019-01-21-golang-pointer-as-argument.png alt=golang-pointer-as-argument></p><p><strong>图 4-4 Go 语言指针参数</strong></p><p>所以将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中传指针也是传值。</p><h3 id=传值>传值
<a class=anchor href=#%e4%bc%a0%e5%80%bc>#</a></h3><p>当我们验证了 Go 语言中大多数常见的数据结构之后，其实能够推测出 Go 语言在传递参数时使用了传值的方式，接收方收到参数时会对这些参数进行复制；了解到这一点之后，在传递数组或者内存占用非常大的结构体时，我们应该尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能。</p><h2 id=413-小结>4.1.3 小结
<a class=anchor href=#413-%e5%b0%8f%e7%bb%93>#</a></h2><p>这一节我们详细分析了 Go 语言的调用惯例，包括传递参数和返回值的过程和原理。Go 通过栈传递函数的参数和返回值，在调用函数之前会在栈上为返回值分配合适的内存空间，随后将入参从右到左按顺序压栈并拷贝参数，返回值会被存储到调用方预留好的栈空间上，我们可以简单总结出以下几条规则：</p><ol><li>通过堆栈传递参数，入栈的顺序是从右到左，而参数的计算是从左到右；</li><li>函数返回值通过堆栈传递并由调用者预先分配内存空间；</li><li>调用函数时都是传值，接收方会对入参进行复制再计算；</li></ol><h2 id=414-延伸阅读>4.1.4 延伸阅读
<a class=anchor href=#414-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html>The Function Stack</a></li><li><a href=https://stackoverflow.com/questions/16453314/why-do-byte-spills-occur-and-what-do-they-achieve>Why do byte spills occur and what do they achieve?</a></li><li><a href=https://mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html>Friday Q&A 2011-12-16: Disassembling the Assembly, Part 1</a></li><li><a href=https://en.wikipedia.org/wiki/X86_calling_conventions>x86 calling conventions</a></li><li><a href=https://en.wikipedia.org/wiki/Call_stack>Call Stack</a></li><li><a href=https://github.com/teh-cmc/go-internals/blob/master/chapter1_assembly_primer/README.md>Chapter I: A Primer on Go Assembly</a></li></ul><p><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/ class=book-btn>上一节</a>
<a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>GCC, the GNU Compiler Collection <a href=https://gcc.gnu.org/>https://gcc.gnu.org/</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Clang: a C language family frontend for LLVM <a href=https://clang.llvm.org/>https://clang.llvm.org/</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Understanding CPU caching and performance <a href=https://arstechnica.com/gadgets/2002/07/caching/2/>https://arstechnica.com/gadgets/2002/07/caching/2/</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-function-call data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-function-call",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#41-函数调用>4.1 函数调用</a><ul><li><a href=#411-调用惯例>4.1.1 调用惯例</a><ul><li><a href=#c-语言>C 语言</a></li><li><a href=#go-语言>Go 语言</a></li><li><a href=#对比>对比</a></li></ul></li><li><a href=#412-参数传递>4.1.2 参数传递</a><ul><li><a href=#整型和数组>整型和数组</a></li><li><a href=#结构体和指针>结构体和指针</a></li><li><a href=#传值>传值</a></li></ul></li><li><a href=#413-小结>4.1.3 小结</a></li><li><a href=#414-延伸阅读>4.1.4 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>