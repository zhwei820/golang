<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="5.1 for 和 range #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等集合类型。本节将深入分析 Go 语言的两种循环，也就是 for 循环和 for-range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理，
for 循环能够将代码中的数据和逻辑分离，让同一份代码能够多次复用相同的处理逻辑。我们先来看一下 Go 语言 for 循环对应的汇编代码，下面是一段经典的三段式循环的代码，我们将它编译成汇编指令：
package main func main() { for i := 0; i < 10; i++ { println(i) } } &#34;&#34;.main STEXT size=98 args=0x0 locals=0x18 00000 (main.go:3)	TEXT	&#34;&#34;.main(SB), $24-0 ... 00029 (main.go:3)	XORL	AX, AX ;; i := 0 00031 (main."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言 for 和 range 的实现"><meta property="og:description" content="5.1 for 和 range #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等集合类型。本节将深入分析 Go 语言的两种循环，也就是 for 循环和 for-range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理，
for 循环能够将代码中的数据和逻辑分离，让同一份代码能够多次复用相同的处理逻辑。我们先来看一下 Go 语言 for 循环对应的汇编代码，下面是一段经典的三段式循环的代码，我们将它编译成汇编指令：
package main func main() { for i := 0; i < 10; i++ { println(i) } } &#34;&#34;.main STEXT size=98 args=0x0 locals=0x18 00000 (main.go:3)	TEXT	&#34;&#34;.main(SB), $24-0 ... 00029 (main.go:3)	XORL	AX, AX ;; i := 0 00031 (main."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part2-foundation/ch05-keyword/golang-for-range/"><title>Go 语言 for 和 range 的实现 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言 for 和 range 的实现</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#51-for-和-range>5.1 for 和 range</a><ul><li><a href=#511-现象>5.1.1 现象</a><ul><li><a href=#循环永动机>循环永动机</a></li><li><a href=#神奇的指针>神奇的指针</a></li><li><a href=#遍历清空数组>遍历清空数组</a></li><li><a href=#随机遍历>随机遍历</a></li></ul></li><li><a href=#512-经典循环>5.1.2 经典循环</a></li><li><a href=#513-范围循环>5.1.3 范围循环</a><ul><li><a href=#数组和切片>数组和切片</a></li><li><a href=#哈希表>哈希表</a></li><li><a href=#字符串>字符串</a></li><li><a href=#通道>通道</a></li></ul></li><li><a href=#514-小结>5.1.4 小结</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=51-for-和-range>5.1 for 和 range
<a class=anchor href=#51-for-%e5%92%8c-range>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 <code>range</code> 帮助我们快速遍历数组、切片、哈希表以及 Channel 等集合类型。本节将深入分析 Go 语言的两种循环，也就是 for 循环和 for-range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理，</p><p>for 循环能够将代码中的数据和逻辑分离，让同一份代码能够多次复用相同的处理逻辑。我们先来看一下 Go 语言 for 循环对应的汇编代码，下面是一段经典的三段式循环的代码，我们将它编译成汇编指令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		println(<span style=color:#a6e22e>i</span>)
	}
}

<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>main</span> <span style=color:#a6e22e>STEXT</span> <span style=color:#a6e22e>size</span>=<span style=color:#ae81ff>98</span> <span style=color:#a6e22e>args</span>=<span style=color:#ae81ff>0x0</span> <span style=color:#a6e22e>locals</span>=<span style=color:#ae81ff>0x18</span>
	<span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>3</span>)	<span style=color:#a6e22e>TEXT</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>main</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>24</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>
	<span style=color:#f92672>...</span>
	<span style=color:#ae81ff>0002</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>3</span>)	<span style=color:#a6e22e>XORL</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>AX</span>                   ;; <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#ae81ff>00031</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>JMP</span>	<span style=color:#ae81ff>75</span>
	<span style=color:#ae81ff>00033</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>)
	<span style=color:#ae81ff>0003</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>printlock</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#ae81ff>00043</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>
	<span style=color:#ae81ff>0004</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, (<span style=color:#a6e22e>SP</span>)
	<span style=color:#ae81ff>00052</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>printint</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#ae81ff>00057</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>printnl</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#ae81ff>00062</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>printunlock</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#ae81ff>00067</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>
	<span style=color:#ae81ff>00072</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>INCQ</span>	<span style=color:#a6e22e>AX</span>                       ;; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
	<span style=color:#ae81ff>00075</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>10</span>                  ;; <span style=color:#a6e22e>比较变量</span> <span style=color:#a6e22e>i</span> <span style=color:#a6e22e>和</span> <span style=color:#ae81ff>10</span>
	<span style=color:#ae81ff>0007</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>JLT</span>	<span style=color:#ae81ff>33</span>                           ;; <span style=color:#a6e22e>跳转到</span> <span style=color:#ae81ff>33</span> <span style=color:#a6e22e>行如果</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>
	<span style=color:#f92672>...</span>
</code></pre></div><p>这里将上述汇编指令的执行过程分成三个部分进行分析：</p><ol><li>0029 ~ 0031 行负责循环的初始化；<ol><li>对寄存器 <code>AX</code> 中的变量 <code>i</code> 进行初始化并执行 <code>JMP 75</code> 指令跳转到 0075 行；</li></ol></li><li>0075 ~ 0079 行负责检查循环的终止条件，将寄存器中存储的数据 <code>i</code> 与 10 比较；<ol><li><code>JLT 33</code> 命令会在变量的值小于 10 时跳转到 0033 行执行循环主体；</li><li><code>JLT 33</code> 命令会在变量的值大于 10 时跳出循环体执行下面的代码；</li></ol></li><li>0033 ~ 0072 行是循环内部的语句；<ol><li>通过多个汇编指令打印变量中的内容；</li><li><code>INCQ AX</code> 指令会将变量加一，然后再与 10 进行比较，回到第二步；</li></ol></li></ol><p>经过优化的 for-range 循环的汇编代码有着相同的结构。无论是变量的初始化、循环体的执行还是最后的条件判断都是完全一样的，所以这里也就不展开分析对应的汇编指令了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
		println(<span style=color:#a6e22e>i</span>)
	}
}
</code></pre></div><p>在汇编语言中，无论是经典的 for 循环还是 for-range 循环都会使用 <code>JMP</code> 等命令跳回循环体的开始位置复用代码。从不同循环具有相同的汇编代码可以猜到，使用 for-range 的控制结构最终也会被 Go 语言编译器转换成普通的 for 循环，后面的分析也会印证这一点。</p><h2 id=511-现象>5.1.1 现象
<a class=anchor href=#511-%e7%8e%b0%e8%b1%a1>#</a></h2><p>在深入语言源代码了解两种不同循环的实现之前，我们可以先来看一下使用 <code>for</code> 和 <code>range</code> 会遇到的一些问题，我们可以带着问题去源代码中寻找答案，这样能更高效地理解它们的实现原理。</p><h3 id=循环永动机>循环永动机
<a class=anchor href=#%e5%be%aa%e7%8e%af%e6%b0%b8%e5%8a%a8%e6%9c%ba>#</a></h3><p>如果我们在遍历数组的同时修改数组的元素，能否得到一个永远都不会停止的循环呢？你可以尝试运行下面的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
		<span style=color:#a6e22e>arr</span> = append(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>v</span>)
	}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>
</code></pre></div><p>上述代码的输出意味着循环只遍历了原始切片中的三个元素，我们在遍历切片时追加的元素不会增加循环的执行次数，所以循环最终还是停了下来。</p><h3 id=神奇的指针>神奇的指针
<a class=anchor href=#%e7%a5%9e%e5%a5%87%e7%9a%84%e6%8c%87%e9%92%88>#</a></h3><p>第二个例子是使用 Go 语言经常会犯的错误<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。当我们在遍历一个数组时，如果获取 <code>range</code> 返回变量的地址并保存到另一个数组或者哈希时，会遇到令人困惑的现象，下面的代码会输出 &ldquo;3 3 3&rdquo;：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
	<span style=color:#a6e22e>newArr</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>{}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
		<span style=color:#a6e22e>newArr</span> = append(<span style=color:#a6e22e>newArr</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>v</span>)
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>newArr</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>v</span>)
	}
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>3</span>
</code></pre></div><p>一些有经验的开发者不经意也会犯这种错误，正确的做法应该是使用 <code>&arr[i]</code> 替代 <code>&v</code>，我们会在下面分析这一现象背后的原因。</p><h3 id=遍历清空数组>遍历清空数组
<a class=anchor href=#%e9%81%8d%e5%8e%86%e6%b8%85%e7%a9%ba%e6%95%b0%e7%bb%84>#</a></h3><p>当我们想要在 Go 语言中清空一个切片或者哈希时，一般都会使用以下的方法将切片中的元素置零：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
		<span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>0</span>
	}
}
</code></pre></div><p>依次遍历切片和哈希看起来是非常耗费性能的，因为数组、切片和哈希占用的内存空间都是连续的，所以最快的方法是直接清空这片内存中的内容，当我们编译上述代码时会得到以下的汇编指令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>main</span> <span style=color:#a6e22e>STEXT</span> <span style=color:#a6e22e>size</span>=<span style=color:#ae81ff>93</span> <span style=color:#a6e22e>args</span>=<span style=color:#ae81ff>0x0</span> <span style=color:#a6e22e>locals</span>=<span style=color:#ae81ff>0x30</span>
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>3</span>)	<span style=color:#a6e22e>TEXT</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>main</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>48</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>
	<span style=color:#f92672>...</span>
	<span style=color:#ae81ff>0x001d</span> <span style=color:#ae81ff>0002</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>statictmp_0</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>AX</span>
	<span style=color:#ae81ff>0x0024</span> <span style=color:#ae81ff>00036</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>)
	<span style=color:#ae81ff>0x0029</span> <span style=color:#ae81ff>00041</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVUPS</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>statictmp_0</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>X0</span>
	<span style=color:#ae81ff>0x0030</span> <span style=color:#ae81ff>0004</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVUPS</span>	<span style=color:#a6e22e>X0</span>, <span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>SP</span>)
	<span style=color:#ae81ff>0x0035</span> <span style=color:#ae81ff>00053</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>
	<span style=color:#ae81ff>0x0035</span> <span style=color:#ae81ff>00053</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>LEAQ</span>	<span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>
	<span style=color:#ae81ff>0x003a</span> <span style=color:#ae81ff>0005</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
	<span style=color:#ae81ff>0x003a</span> <span style=color:#ae81ff>0005</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, (<span style=color:#a6e22e>SP</span>)
	<span style=color:#ae81ff>0x003e</span> <span style=color:#ae81ff>00062</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>24</span>, <span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>)
	<span style=color:#ae81ff>0x0047</span> <span style=color:#ae81ff>00071</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>memclrNoHeapPointers</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#f92672>...</span>
</code></pre></div><p>从生成的汇编代码我们可以看出，编译器会直接使用 <a href=/golang/tree/runtime.memclrNoHeapPointers><code>runtime.memclrNoHeapPointers</code></a> 清空切片中的数据，这也是我们在下面的小节会介绍的内容。</p><h3 id=随机遍历>随机遍历
<a class=anchor href=#%e9%9a%8f%e6%9c%ba%e9%81%8d%e5%8e%86>#</a></h3><p>当我们在 Go 语言中使用 <code>range</code> 遍历哈希表时，往往都会使用如下的代码结构，但是这段代码在每次运行时都会打印出不同的结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>{
		<span style=color:#e6db74>&#34;1&#34;</span>: <span style=color:#ae81ff>1</span>,
		<span style=color:#e6db74>&#34;2&#34;</span>: <span style=color:#ae81ff>2</span>,
		<span style=color:#e6db74>&#34;3&#34;</span>: <span style=color:#ae81ff>3</span>,
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>hash</span> {
		println(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
	}
}
</code></pre></div><p>两次运行上述代码可能会得到不同的结果，第一次会打印 <code>2 3 1</code>，第二次会打印 <code>1 2 3</code>，如果我们运行的次数足够多，最后会得到几种不同的遍历顺序。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go run main.go
<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span>
<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>3</span>
<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>

$ go run main.go
<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span>
<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>3</span>
</code></pre></div><p>Go 语言在运行时为哈希表的遍历引入了不确定性，也是告诉所有 Go 语言的使用者，程序不要依赖于哈希表的稳定遍历，我们在下面的小节会介绍在遍历的过程是如何引入不确定性的。</p><h2 id=512-经典循环>5.1.2 经典循环
<a class=anchor href=#512-%e7%bb%8f%e5%85%b8%e5%be%aa%e7%8e%af>#</a></h2><p>Go 语言中的经典循环在编译器看来是一个 <code>OFOR</code> 类型的节点，这个节点由以下四个部分组成：</p><ol><li>初始化循环的 <code>Ninit</code>；</li><li>循环的继续条件 <code>Left</code>；</li><li>循环体结束时执行的 <code>Right</code>；</li><li>循环体 <code>NBody</code>：</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>Ninit</span>; <span style=color:#a6e22e>Left</span>; <span style=color:#a6e22e>Right</span> {
    <span style=color:#a6e22e>NBody</span>
}
</code></pre></div><p>在生成 SSA 中间代码的阶段，<a href=/golang/tree/cmd/compile/internal/gc.state.stmt><code>cmd/compile/internal/gc.state.stmt</code></a> 方法在发现传入的节点类型是 <code>OFOR</code> 时会执行以下的代码块，这段代码会将循环中的代码分成不同的块：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>stmt</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OFOR</span>, <span style=color:#a6e22e>OFORUNTIL</span>:
		<span style=color:#a6e22e>bCond</span>, <span style=color:#a6e22e>bBody</span>, <span style=color:#a6e22e>bIncr</span>, <span style=color:#a6e22e>bEnd</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>...</span>

		<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>endBlock</span>()
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>AddEdgeTo</span>(<span style=color:#a6e22e>bCond</span>)
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>startBlock</span>(<span style=color:#a6e22e>bCond</span>)
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>condBranch</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>bBody</span>, <span style=color:#a6e22e>bEnd</span>, <span style=color:#ae81ff>1</span>)

		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>startBlock</span>(<span style=color:#a6e22e>bBody</span>)
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>stmtList</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Nbody</span>)

		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>AddEdgeTo</span>(<span style=color:#a6e22e>bIncr</span>)
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>startBlock</span>(<span style=color:#a6e22e>bIncr</span>)
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>stmt</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>)
		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>AddEdgeTo</span>(<span style=color:#a6e22e>bCond</span>)
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>startBlock</span>(<span style=color:#a6e22e>bEnd</span>)
	}
}
</code></pre></div><p>一个常见的 for 循环代码会被 <a href=/golang/tree/cmd/compile/internal/gc.state.stmt><code>cmd/compile/internal/gc.state.stmt</code></a> 转换成下面的控制结构，该结构中包含了 4 个不同的块，这些代码块之间的连接表示汇编语言中的跳转关系，与我们理解的 for 循环控制结构没有太多的差别。</p><p><img src=https://img.draveness.me/2020-01-17-15792766877627-golang-for-loop-ssa.png alt=golang-for-loop-ssa></p><p><strong>图 5-1 Go 语言循环生成的 SSA 代码</strong></p><p><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>机器码生成</a>阶段会将这些代码块转换成机器码，以及指定 CPU 架构上运行的机器语言，就是我们在前面编译得到的汇编指令。</p><h2 id=513-范围循环>5.1.3 范围循环
<a class=anchor href=#513-%e8%8c%83%e5%9b%b4%e5%be%aa%e7%8e%af>#</a></h2><p>与简单的经典循环相比，范围循环在 Go 语言中更常见、实现也更复杂。这种循环同时使用 <code>for</code> 和 <code>range</code> 两个关键字，编译器会在编译期间将所有 for-range 循环变成经典循环。从编译器的视角来看，就是将 <code>ORANGE</code> 类型的节点转换成 <code>OFOR</code> 节点:</p><p><img src=https://img.draveness.me/2020-01-17-15792766926441-Golang-For-Range-Loop.png alt=Golang-For-Range-Loop></p><p><strong>图 5-2 范围循环、普通循环和 SSA</strong></p><p>节点类型的转换过程都发生在中间代码生成阶段，所有的 for-range 循环都会被 <a href=/golang/tree/cmd/compile/internal/gc.walkrange><code>cmd/compile/internal/gc.walkrange</code></a> 转换成不包含复杂结构、只包含基本表达式的语句。接下来，我们按照循环遍历的元素类型依次介绍遍历数组和切片、哈希表、字符串以及管道时的过程。</p><h3 id=数组和切片>数组和切片
<a class=anchor href=#%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87>#</a></h3><p>对于数组和切片来说，Go 语言有三种不同的遍历方式，这三种不同的遍历方式分别对应着代码中的不同条件，它们会在 <a href=/golang/tree/cmd/compile/internal/gc.walkrange><code>cmd/compile/internal/gc.walkrange</code></a> 函数中转换成不同的控制逻辑，我们会分成几种情况分析该函数的逻辑：</p><ol><li>分析遍历数组和切片清空元素的情况；</li><li>分析使用 <code>for range a {}</code> 遍历数组和切片，不关心索引和数据的情况；</li><li>分析使用 <code>for i := range a {}</code> 遍历数组和切片，只关心索引的情况；</li><li>分析使用 <code>for i, elem := range a {}</code> 遍历数组和切片，关心索引和数据的情况；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkrange</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Etype</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TARRAY</span>, <span style=color:#a6e22e>TSLICE</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arrayClear</span>(<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>v1</span>, <span style=color:#a6e22e>v2</span>, <span style=color:#a6e22e>a</span>) {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
		}
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/gc.arrayClear><code>cmd/compile/internal/gc.arrayClear</code></a> 是一个非常有趣的优化，它会优化 Go 语言遍历数组或者切片并删除全部元素的逻辑：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 原代码
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>a</span> {
	<span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>zero</span>
}

<span style=color:#75715e>// 优化后
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>a</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
	<span style=color:#a6e22e>hp</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>[<span style=color:#ae81ff>0</span>]
	<span style=color:#a6e22e>hn</span> = len(<span style=color:#a6e22e>a</span>)<span style=color:#f92672>*</span><span style=color:#a6e22e>sizeof</span>(<span style=color:#a6e22e>elem</span>(<span style=color:#a6e22e>a</span>))
	<span style=color:#a6e22e>memclrNoHeapPointers</span>(<span style=color:#a6e22e>hp</span>, <span style=color:#a6e22e>hn</span>)
	<span style=color:#a6e22e>i</span> = len(<span style=color:#a6e22e>a</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
}
</code></pre></div><p>相比于依次清除数组或者切片中的数据，Go 语言会直接使用 <a href=/golang/tree/runtime.memclrNoHeapPointers><code>runtime.memclrNoHeapPointers</code></a> 或者 <a href=/golang/tree/runtime.memclrHasPointers><code>runtime.memclrHasPointers</code></a> 清除目标数组内存空间中的全部数据，并在执行完成后更新遍历数组的索引，这也印证了我们在遍历清空数组一节中观察到的现象。</p><p>处理了这种特殊的情况之后，我们可以回到 <code>ORANGE</code> 节点的处理过程了。这里会设置 for 循环的 <code>Left</code> 和 <code>Right</code> 字段，也就是终止条件和循环体每次执行结束后运行的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>		<span style=color:#a6e22e>ha</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>

		<span style=color:#a6e22e>hv1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>temp</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TINT</span>])
		<span style=color:#a6e22e>hn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>temp</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TINT</span>])

		<span style=color:#a6e22e>init</span> = append(<span style=color:#a6e22e>init</span>, <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OAS</span>, <span style=color:#a6e22e>hv1</span>, <span style=color:#66d9ef>nil</span>))
		<span style=color:#a6e22e>init</span> = append(<span style=color:#a6e22e>init</span>, <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OAS</span>, <span style=color:#a6e22e>hn</span>, <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OLEN</span>, <span style=color:#a6e22e>ha</span>, <span style=color:#66d9ef>nil</span>)))

		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OLT</span>, <span style=color:#a6e22e>hv1</span>, <span style=color:#a6e22e>hn</span>)
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OAS</span>, <span style=color:#a6e22e>hv1</span>, <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OADD</span>, <span style=color:#a6e22e>hv1</span>, <span style=color:#a6e22e>nodintconst</span>(<span style=color:#ae81ff>1</span>)))

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v1</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>break</span>
		}
</code></pre></div><p>如果循环是 <code>for range a {}</code>，那么就满足了上述代码中的条件 <code>v1 == nil</code>，即循环不关心数组的索引和数据，这种循环会被编译器转换成如下形式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ha</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>
<span style=color:#a6e22e>hv1</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
<span style=color:#a6e22e>hn</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>ha</span>)
<span style=color:#a6e22e>v1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hv1</span>
<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>hv1</span> &lt; <span style=color:#a6e22e>hn</span>; <span style=color:#a6e22e>hv1</span><span style=color:#f92672>++</span> {
    <span style=color:#f92672>...</span>
}
</code></pre></div><p>这是 <code>ORANGE</code> 结构在编译期间被转换的最简单形式，由于原代码不需要获取数组的索引和元素，只需要使用数组或者切片的数量执行对应次数的循环，所以会生成一个最简单的 for 循环。</p><p>如果我们在遍历数组时需要使用索引 <code>for i := range a {}</code>，那么编译器会继续会执行下面的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v2</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>body</span> = []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OAS</span>, <span style=color:#a6e22e>v1</span>, <span style=color:#a6e22e>hv1</span>)}
			<span style=color:#66d9ef>break</span>
		}
</code></pre></div><p><code>v2 == nil</code> 意味着调用方不关心数组的元素，只关心遍历数组使用的索引。它会将 <code>for i := range a {}</code> 转换成下面的逻辑，与第一种循环相比，这种循环在循环体中添加了 <code>v1 := hv1</code> 语句，传递遍历数组时的索引：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ha</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>
<span style=color:#a6e22e>hv1</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
<span style=color:#a6e22e>hn</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>ha</span>)
<span style=color:#a6e22e>v1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hv1</span>
<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>hv1</span> &lt; <span style=color:#a6e22e>hn</span>; <span style=color:#a6e22e>hv1</span><span style=color:#f92672>++</span> {
    <span style=color:#a6e22e>v1</span> = <span style=color:#a6e22e>hv1</span>
    <span style=color:#f92672>...</span>
}
</code></pre></div><p>上面两种情况虽然也是使用 range 会经常遇到的情况，但是同时去遍历索引和元素也很常见。处理这种情况会使用下面这段的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>		<span style=color:#a6e22e>tmp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OINDEX</span>, <span style=color:#a6e22e>ha</span>, <span style=color:#a6e22e>hv1</span>)
		<span style=color:#a6e22e>tmp</span>.<span style=color:#a6e22e>SetBounded</span>(<span style=color:#66d9ef>true</span>)
		<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OAS2</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>)
		<span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Set2</span>(<span style=color:#a6e22e>v1</span>, <span style=color:#a6e22e>v2</span>)
		<span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>Rlist</span>.<span style=color:#a6e22e>Set2</span>(<span style=color:#a6e22e>hv1</span>, <span style=color:#a6e22e>tmp</span>)
		<span style=color:#a6e22e>body</span> = []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>a</span>}
	}
	<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Ninit</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>init</span><span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Nbody</span>.<span style=color:#a6e22e>Prepend</span>(<span style=color:#a6e22e>body</span><span style=color:#f92672>...</span>)

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
}
</code></pre></div><p>这段代码处理的使用者同时关心索引和切片的情况。它不仅会在循环体中插入更新索引的语句，还会插入赋值操作让循环体内部的代码能够访问数组中的元素：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ha</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>
<span style=color:#a6e22e>hv1</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
<span style=color:#a6e22e>hn</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>ha</span>)
<span style=color:#a6e22e>v1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hv1</span>
<span style=color:#a6e22e>v2</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>nil</span>
<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>hv1</span> &lt; <span style=color:#a6e22e>hn</span>; <span style=color:#a6e22e>hv1</span><span style=color:#f92672>++</span> {
    <span style=color:#a6e22e>tmp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ha</span>[<span style=color:#a6e22e>hv1</span>]
    <span style=color:#a6e22e>v1</span>, <span style=color:#a6e22e>v2</span> = <span style=color:#a6e22e>hv1</span>, <span style=color:#a6e22e>tmp</span>
    <span style=color:#f92672>...</span>
}
</code></pre></div><p>对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新变量 <code>ha</code>，在赋值的过程中就发生了拷贝，而我们又通过 <code>len</code> 关键字预先获取了切片的长度，所以在循环中追加新的元素也不会改变循环执行的次数，这也就解释了循环永动机一节提到的现象。</p><p>而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 <code>v2</code> 变量存储切片中的元素，<strong>循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，赋值时也会触发拷贝</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
	<span style=color:#a6e22e>newArr</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>{}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
		<span style=color:#a6e22e>newArr</span> = append(<span style=color:#a6e22e>newArr</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>])
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>newArr</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>v</span>)
	}
}
</code></pre></div><p>因为在循环中获取返回变量的地址都完全相同，所以会发生神奇的指针一节中的现象。因此当我们想要访问数组中元素所在的地址时，不应该直接获取 range 返回的变量地址 <code>&v2</code>，而应该使用 <code>&a[index]</code> 这种形式。</p><h3 id=哈希表>哈希表
<a class=anchor href=#%e5%93%88%e5%b8%8c%e8%a1%a8>#</a></h3><p>在遍历哈希表时，编译器会使用 <a href=/golang/tree/runtime.mapiterinit><code>runtime.mapiterinit</code></a> 和 <a href=/golang/tree/runtime.mapiternext><code>runtime.mapiternext</code></a> 两个运行时函数重写原始的 for-range 循环：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ha</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>
<span style=color:#a6e22e>hit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hiter</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>)
<span style=color:#a6e22e>th</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hit</span>.<span style=color:#a6e22e>Type</span>
<span style=color:#a6e22e>mapiterinit</span>(<span style=color:#a6e22e>typename</span>(<span style=color:#a6e22e>t</span>), <span style=color:#a6e22e>ha</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hit</span>)
<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>hit</span>.<span style=color:#a6e22e>key</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>mapiternext</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hit</span>) {
    <span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hit</span>.<span style=color:#a6e22e>key</span>
    <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hit</span>.<span style=color:#a6e22e>val</span>
}
</code></pre></div><p>上述代码是展开 <code>for key, val := range hash {}</code> 后的结果，在 <a href=/golang/tree/cmd/compile/internal/gc.walkrange><code>cmd/compile/internal/gc.walkrange</code></a> 处理 <code>TMAP</code> 节点时，编译器会根据 range 返回值的数量在循环体中插入需要的赋值语句：</p><p><img src=https://img.draveness.me/2020-01-17-15792766877639-golang-range-map.png alt=golang-range-map></p><p><strong>图 5-3 不同方式遍历哈希插入的语句</strong></p><p>这三种不同的情况分别向循环体插入了不同的赋值语句。遍历哈希表时会使用 <a href=/golang/tree/runtime.mapiterinit><code>runtime.mapiterinit</code></a> 函数初始化遍历开始的元素：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapiterinit</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>it</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hiter</span>) {
	<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>t</span> = <span style=color:#a6e22e>t</span>
	<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>h</span> = <span style=color:#a6e22e>h</span>
	<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>B</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>
	<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>

	<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>fastrand</span>())
	<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>startBucket</span> = <span style=color:#a6e22e>r</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
	<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>offset</span> = uint8(<span style=color:#a6e22e>r</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>&amp;</span> (<span style=color:#a6e22e>bucketCnt</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
	<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>bucket</span> = <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>startBucket</span>
	<span style=color:#a6e22e>mapiternext</span>(<span style=color:#a6e22e>it</span>)
}
</code></pre></div><p>该函数会初始化 <a href=/golang/tree/runtime.hiter><code>runtime.hiter</code></a> 结构体中的字段，并通过 <a href=/golang/tree/runtime.fastrand><code>runtime.fastrand</code></a> 生成一个随机数帮助我们随机选择一个遍历桶的起始位置。Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以引入了随机数保证遍历的随机性。</p><p>遍历哈希会使用 <a href=/golang/tree/runtime.mapiternext><code>runtime.mapiternext</code></a>，我们在这里简化了很多逻辑，省去了一些边界条件以及哈希表扩容时的兼容操作，这里只需要关注处理遍历逻辑的核心代码，我们会将该函数分成桶的选择和桶内元素的遍历两部分，首先是桶的选择过程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapiternext</span>(<span style=color:#a6e22e>it</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hiter</span>) {
	<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>h</span>
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>t</span>
	<span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>bucket</span>
	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>bptr</span>
	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>i</span>
	<span style=color:#a6e22e>alg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>alg</span>

<span style=color:#a6e22e>next</span>:
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bucket</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>startBucket</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>wrapped</span> {
			<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>key</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>value</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#66d9ef>return</span>
		}
		<span style=color:#a6e22e>b</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>bucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
		<span style=color:#a6e22e>bucket</span><span style=color:#f92672>++</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bucket</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>bucketShift</span>(<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>B</span>) {
			<span style=color:#a6e22e>bucket</span> = <span style=color:#ae81ff>0</span>
			<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>wrapped</span> = <span style=color:#66d9ef>true</span>
		}
		<span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>0</span>
	}
</code></pre></div><p>这段代码主要有两个作用：</p><ol><li>在待遍历的桶为空时，选择需要遍历的新桶；</li><li>在不存在待遍历的桶时。返回 <code>(nil, nil)</code> 键值对并中止遍历；</li></ol><p><a href=/golang/tree/runtime.mapiternext><code>runtime.mapiternext</code></a> 剩余代码的作用是从桶中找到下一个遍历的元素，在大多数情况下都会直接操作内存获取目标键值的内存地址，不过如果哈希表处于扩容期间就会调用 <a href=/golang/tree/runtime.mapaccessK><code>runtime.mapaccessK</code></a> 获取键值对：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>offi</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>offset</span>) <span style=color:#f92672>&amp;</span> (<span style=color:#a6e22e>bucketCnt</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
		<span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span>uintptr(<span style=color:#a6e22e>offi</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
		<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span>uintptr(<span style=color:#a6e22e>offi</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>valuesize</span>))
		<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>offi</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>evacuatedX</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>offi</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>evacuatedY</span>) <span style=color:#f92672>||</span>
			!(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>reflexivekey</span>() <span style=color:#f92672>||</span> <span style=color:#a6e22e>alg</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>k</span>)) {
			<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>key</span> = <span style=color:#a6e22e>k</span>
			<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>value</span> = <span style=color:#a6e22e>v</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>rk</span>, <span style=color:#a6e22e>rv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mapaccessK</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>k</span>)
			<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>key</span> = <span style=color:#a6e22e>rk</span>
			<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>value</span> = <span style=color:#a6e22e>rv</span>
		}
		<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>bucket</span> = <span style=color:#a6e22e>bucket</span>
		<span style=color:#a6e22e>it</span>.<span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>)
	<span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>next</span>
}
</code></pre></div><p>当上述函数已经遍历了正常桶后，会通过 <a href=/golang/tree/runtime.bmap.overflow><code>runtime.bmap.overflow</code></a> 遍历哈希中的溢出桶。</p><p><img src=https://img.draveness.me/2020-01-17-15792766877646-golang-range-map-and-buckets.png alt=golang-range-map-and-buckets></p><p><strong>图 5-4 哈希表的遍历过程</strong></p><p>简单总结一下哈希表遍历的顺序，首先会选出一个绿色的正常桶开始遍历，随后遍历所有黄色的溢出桶，最后依次按照索引顺序遍历哈希表中其他的桶，直到所有的桶都被遍历完成。</p><h3 id=字符串>字符串
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2>#</a></h3><p>遍历字符串的过程与数组、切片和哈希表非常相似，只是在遍历时会获取字符串中索引对应的字节并将字节转换成 <code>rune</code>。我们在遍历字符串时拿到的值都是 <code>rune</code> 类型的变量，<code>for i, r := range s {}</code> 的结构都会被转换成如下所示的形式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ha</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>hv1</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>hv1</span> &lt; len(<span style=color:#a6e22e>ha</span>); {
    <span style=color:#a6e22e>hv1t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hv1</span>
    <span style=color:#a6e22e>hv2</span> <span style=color:#f92672>:=</span> rune(<span style=color:#a6e22e>ha</span>[<span style=color:#a6e22e>hv1</span>])
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>hv2</span> &lt; <span style=color:#a6e22e>utf8</span>.<span style=color:#a6e22e>RuneSelf</span> {
        <span style=color:#a6e22e>hv1</span><span style=color:#f92672>++</span>
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>hv2</span>, <span style=color:#a6e22e>hv1</span> = <span style=color:#a6e22e>decoderune</span>(<span style=color:#a6e22e>ha</span>, <span style=color:#a6e22e>hv1</span>)
    }
    <span style=color:#a6e22e>v1</span>, <span style=color:#a6e22e>v2</span> = <span style=color:#a6e22e>hv1t</span>, <span style=color:#a6e22e>hv2</span>
}
</code></pre></div><p>在前面的字符串一节中我们曾经介绍过字符串是一个只读的字节数组切片，所以范围循环在编译期间生成的框架与切片非常类似，只是细节有一些不同。</p><p>使用下标访问字符串中的元素时得到的就是字节，但是这段代码会将当前的字节转换成 <code>rune</code> 类型。如果当前的 <code>rune</code> 是 ASCII 的，那么只会占用一个字节长度，每次循环体运行之后只需要将索引加一，但是如果当前 <code>rune</code> 占用了多个字节就会使用 <a href=/golang/tree/runtime.decoderune><code>runtime.decoderune</code></a> 函数解码，具体的过程就不在这里详细介绍了。</p><h3 id=通道>通道
<a class=anchor href=#%e9%80%9a%e9%81%93>#</a></h3><p>使用 range 遍历 Channel 也是比较常见的做法，一个形如 <code>for v := range ch {}</code> 的语句最终会被转换成如下的格式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ha</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>
<span style=color:#a6e22e>hv1</span>, <span style=color:#a6e22e>hb</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ha</span>
<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>hb</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>false</span>; <span style=color:#a6e22e>hv1</span>, <span style=color:#a6e22e>hb</span> = <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ha</span> {
    <span style=color:#a6e22e>v1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hv1</span>
    <span style=color:#a6e22e>hv1</span> = <span style=color:#66d9ef>nil</span>
    <span style=color:#f92672>...</span>
}
</code></pre></div><p>这里的代码可能与编译器生成的稍微有一些出入，但是结构和效果是完全相同的。该循环会使用 <code>&lt;-ch</code> 从管道中取出等待处理的值，这个操作会调用 <a href=/golang/tree/runtime.chanrecv2><code>runtime.chanrecv2</code></a> 并阻塞当前的协程，当 <a href=/golang/tree/runtime.chanrecv2><code>runtime.chanrecv2</code></a> 返回时会根据布尔值 <code>hb</code> 判断当前的值是否存在：</p><ul><li>如果不存在当前值，意味着当前的管道已经被关闭；</li><li>如果存在当前值，会为 <code>v1</code> 赋值并清除 <code>hv1</code> 变量中的数据，然后重新陷入阻塞等待新数据；</li></ul><h2 id=514-小结>5.1.4 小结
<a class=anchor href=#514-%e5%b0%8f%e7%bb%93>#</a></h2><p>这一节介绍的两个关键字 <code>for</code> 和 <code>range</code> 都是我们在学习和使用 Go 语言中无法绕开的，通过分析和研究它们的底层原理，让我们对实现细节有了更清楚的认识，包括 Go 语言遍历数组和切片时会复用变量、哈希表的随机遍历原理以及底层的一些优化，这都能帮助我们更好地理解和使用 Go 语言。</p><p><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/ class=book-btn>上一节</a>
<a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>CommonMistakes · Go <a href=https://github.com/golang/go/wiki/CommonMistakes>https://github.com/golang/go/wiki/CommonMistakes</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-for-range data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-for-range",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#51-for-和-range>5.1 for 和 range</a><ul><li><a href=#511-现象>5.1.1 现象</a><ul><li><a href=#循环永动机>循环永动机</a></li><li><a href=#神奇的指针>神奇的指针</a></li><li><a href=#遍历清空数组>遍历清空数组</a></li><li><a href=#随机遍历>随机遍历</a></li></ul></li><li><a href=#512-经典循环>5.1.2 经典循环</a></li><li><a href=#513-范围循环>5.1.3 范围循环</a><ul><li><a href=#数组和切片>数组和切片</a></li><li><a href=#哈希表>哈希表</a></li><li><a href=#字符串>字符串</a></li><li><a href=#通道>通道</a></li></ul></li><li><a href=#514-小结>5.1.4 小结</a></li></ul></li></ul></nav></aside></main></body></html>