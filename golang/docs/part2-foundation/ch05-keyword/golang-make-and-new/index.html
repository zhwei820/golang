<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="5.5 make 和 new #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — make 和 new。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑1，但是它们两者能够初始化的变量却有较大的不同。
 make 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel2； new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针3；  我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：
slice := make([]int, 0, 100) hash := make(map[int]bool, 10) ch := make(chan int, 5)  slice 是一个包含 data、cap 和 len 的结构体 reflect.SliceHeader； hash 是一个指向 runtime.hmap 结构体的指针； ch 是一个指向 runtime.hchan 结构体的指针；  相比与复杂的 make 关键字，new 的功能就简单多了，它只能接收类型作为参数然后返回一个指向该类型的指针：
i := new(int) var v int i := &v 上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 int 零值的指针。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言中的 make 和 new"><meta property="og:description" content="5.5 make 和 new #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — make 和 new。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑1，但是它们两者能够初始化的变量却有较大的不同。
 make 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel2； new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针3；  我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：
slice := make([]int, 0, 100) hash := make(map[int]bool, 10) ch := make(chan int, 5)  slice 是一个包含 data、cap 和 len 的结构体 reflect.SliceHeader； hash 是一个指向 runtime.hmap 结构体的指针； ch 是一个指向 runtime.hchan 结构体的指针；  相比与复杂的 make 关键字，new 的功能就简单多了，它只能接收类型作为参数然后返回一个指向该类型的指针：
i := new(int) var v int i := &v 上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 int 零值的指针。"><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/"><title>Go 语言中的 make 和 new | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言中的 make 和 new</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#55-make-和-new>5.5 make 和 new</a><ul><li><a href=#551-make>5.5.1 make</a></li><li><a href=#552-new>5.5.2 new</a></li><li><a href=#553-小结>5.5.3 小结</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=55-make-和-new>5.5 make 和 new
<a class=anchor href=#55-make-%e5%92%8c-new>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — <code>make</code> 和 <code>new</code>。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，但是它们两者能够初始化的变量却有较大的不同。</p><ul><li><code>make</code> 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>；</li><li><code>new</code> 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>；</li></ul><p>我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>slice</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>)
<span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>10</span>)
<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span>)
</code></pre></div><ol><li><code>slice</code> 是一个包含 <code>data</code>、<code>cap</code> 和 <code>len</code> 的结构体 <a href=/golang/tree/reflect.SliceHeader><code>reflect.SliceHeader</code></a>；</li><li><code>hash</code> 是一个指向 <a href=/golang/tree/runtime.hmap><code>runtime.hmap</code></a> 结构体的指针；</li><li><code>ch</code> 是一个指向 <a href=/golang/tree/runtime.hchan><code>runtime.hchan</code></a> 结构体的指针；</li></ol><p>相比与复杂的 <code>make</code> 关键字，<code>new</code> 的功能就简单多了，它只能接收类型作为参数然后返回一个指向该类型的指针：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> new(<span style=color:#66d9ef>int</span>)

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>v</span>
</code></pre></div><p>上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 <code>int</code> 零值的指针。</p><p><img src=https://img.draveness.me/golang-make-and-new.png alt=golang-make-and-new></p><p><strong>图 5-14 make 和 new 初始化的类型</strong></p><p>接下来我们将分别介绍 <code>make</code> 和 <code>new</code> 初始化不同数据结构的过程，我们会从编译期间和运行时两个不同阶段理解这两个关键字的原理，不过由于前面的章节已经详细地分析过 <code>make</code> 的原理，所以这里会将重点放在另一个关键字 <code>new</code> 上。</p><h2 id=551-make>5.5.1 make
<a class=anchor href=#551-make>#</a></h2><p>在前面的章节中我们已经谈到过 <code>make</code> 在创建切片、哈希表和 Channel 的具体过程，所以在这一小节，我们只是会简单提及 <code>make</code> 相关的数据结构的初始化原理。</p><p><img src=https://img.draveness.me/golang-make-typecheck.png alt=golang-make-typecheck></p><p><strong>图 5-15 make 关键字的类型检查</strong></p><p>在编译期间的类型检查阶段，Go 语言会将代表 <code>make</code> 关键字的 <code>OMAKE</code> 节点根据参数类型的不同转换成了 <code>OMAKESLICE</code>、<code>OMAKEMAP</code> 和 <code>OMAKECHAN</code> 三种不同类型的节点，这些节点会调用不同的运行时函数来初始化相应的数据结构。</p><h2 id=552-new>5.5.2 new
<a class=anchor href=#552-new>#</a></h2><p>编译器会在中间代码生成阶段通过以下两个函数处理该关键字：</p><ol><li><a href=/golang/tree/cmd/compile/internal/gc.callnew><code>cmd/compile/internal/gc.callnew</code></a> 会将关键字转换成 <code>ONEWOBJ</code> 类型的节点<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>；</li><li><a href=/golang/tree/cmd/compile/internal/gc.state.expr><code>cmd/compile/internal/gc.state.expr</code></a> 会根据申请空间的大小分两种情况处理：<ol><li>如果申请的空间为 0，就会返回一个表示空指针的 <code>zerobase</code> 变量；</li><li>在遇到其他情况时会将关键字转换成 <a href=/golang/tree/runtime.newobject><code>runtime.newobject</code></a> 函数：</li></ol></li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>callnew</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Type</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>ONEWOBJ</span>, <span style=color:#a6e22e>typename</span>(<span style=color:#a6e22e>t</span>), <span style=color:#66d9ef>nil</span>)
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>expr</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ONEWOBJ</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>Elem</span>().<span style=color:#a6e22e>Size</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>newValue1A</span>(<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>OpAddr</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>zerobaseSym</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>sb</span>)
		}
		<span style=color:#a6e22e>typ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>expr</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>)
		<span style=color:#a6e22e>vv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>rtcall</span>(<span style=color:#a6e22e>newobject</span>, <span style=color:#66d9ef>true</span>, []<span style=color:#f92672>*</span><span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Type</span>{<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>}, <span style=color:#a6e22e>typ</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>vv</span>[<span style=color:#ae81ff>0</span>]
	}
}
</code></pre></div><p>需要注意的是，无论是直接使用 <code>new</code>，还是使用 <code>var</code> 初始化变量，它们在编译器看来都是 <code>ONEW</code> 和 <code>ODCL</code> 节点。如果变量会逃逸到堆上，这些节点在这一阶段都会被 <a href=/golang/tree/cmd/compile/internal/gc.walkstmt><code>cmd/compile/internal/gc.walkstmt</code></a> 转换成通过 <a href=/golang/tree/runtime.newobject><code>runtime.newobject</code></a> 函数并在堆上申请内存：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkstmt</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ODCL</span>:
		<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Class</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>PAUTOHEAP</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>prealloc</span>[<span style=color:#a6e22e>v</span>] <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>prealloc</span>[<span style=color:#a6e22e>v</span>] = <span style=color:#a6e22e>callnew</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Type</span>)
			}
			<span style=color:#a6e22e>nn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OAS</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Name</span>.<span style=color:#a6e22e>Param</span>.<span style=color:#a6e22e>Heapaddr</span>, <span style=color:#a6e22e>prealloc</span>[<span style=color:#a6e22e>v</span>])
			<span style=color:#a6e22e>nn</span>.<span style=color:#a6e22e>SetColas</span>(<span style=color:#66d9ef>true</span>)
			<span style=color:#a6e22e>nn</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>nn</span>, <span style=color:#a6e22e>ctxStmt</span>)
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>walkstmt</span>(<span style=color:#a6e22e>nn</span>)
		}
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ONEW</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Esc</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>EscNone</span> {
			<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>temp</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>Elem</span>())
			<span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OAS</span>, <span style=color:#a6e22e>r</span>, <span style=color:#66d9ef>nil</span>)
			<span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>ctxStmt</span>)
			<span style=color:#a6e22e>init</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>r</span>)
			<span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OADDR</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#66d9ef>nil</span>)
			<span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>ctxExpr</span>)
			<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>r</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>callnew</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>Elem</span>())
		}
	}
}
</code></pre></div><p>不过这也不是绝对的，如果通过 <code>var</code> 或者 <code>new</code> 创建的变量不需要在当前作用域外生存，例如不用作为返回值返回给调用方，那么就不需要初始化在堆上。</p><p><a href=/golang/tree/runtime.newobject><code>runtime.newobject</code></a> 函数会获取传入类型占用空间的大小，调用 <a href=/golang/tree/runtime.mallocgc><code>runtime.mallocgc</code></a> 在堆上申请一片内存空间并返回指向这片内存空间的指针：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>typ</span>.<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>typ</span>, <span style=color:#66d9ef>true</span>)
}
</code></pre></div><p><a href=/golang/tree/runtime.mallocgc><code>runtime.mallocgc</code></a> 函数的实现大概有 200 多行代码，我们会在后面的章节中详细分析 Go 语言的内存管理机制。</p><h2 id=553-小结>5.5.3 小结
<a class=anchor href=#553-%e5%b0%8f%e7%bb%93>#</a></h2><p>这里我们简单总结一下 Go 语言中 <code>make</code> 和 <code>new</code> 关键字的实现原理，<code>make</code> 关键字的作用是创建切片、哈希表和 Channel 等内置的数据结构，而 <code>new</code> 的作用是为类型申请一片内存空间，并返回指向这片内存的指针。</p><p><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/ class=book-btn>上一节</a>
<a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Make and new <a href=https://groups.google.com/forum/#!topic/golang-nuts/kWXYU95XN04/discussion%5B1-25%5D>https://groups.google.com/forum/#!topic/golang-nuts/kWXYU95XN04/discussion%5B1-25%5D</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Allocation with make <a href=https://golang.org/doc/effective_go.html#allocation_make>https://golang.org/doc/effective_go.html#allocation_make</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Allocation with new <a href=https://golang.org/doc/effective_go.html#allocation_new>https://golang.org/doc/effective_go.html#allocation_new</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-make-and-new data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-make-and-new",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#55-make-和-new>5.5 make 和 new</a><ul><li><a href=#551-make>5.5.1 make</a></li><li><a href=#552-new>5.5.2 new</a></li><li><a href=#553-小结>5.5.3 小结</a></li></ul></li></ul></nav></aside></main></body></html>