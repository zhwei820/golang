<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="5.3 defer #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。这一节会深入 Go 语言的源代码介绍 defer 关键字的实现原理，相信读者读完这一节会对 defer 的数据结构、实现以及调用过程有着更清晰的理解。
作为一个编程语言中的关键字，defer 的实现一定是由编译器和运行时共同完成的，不过在深入源码分析它的实现之前我们还是需要了解 defer 关键字的常见使用场景以及使用时的注意事项。
使用 defer 的最常见场景是在函数调用结束后完成一些收尾工作，例如在 defer 中回滚数据库的事务：
func createPost(db *gorm.DB) error { tx := db.Begin() defer tx.Rollback() if err := tx.Create(&Post{Author: &#34;Draveness&#34;}).Error; err != nil { return err } return tx.Commit().Error } 在使用数据库事务时，我们可以使用上面的代码在创建事务后就立刻调用 Rollback 保证事务一定会回滚。哪怕事务真的执行成功了，那么调用 tx.Commit() 之后再执行 tx.Rollback() 也不会影响已经提交的事务。
5.3.1 现象 #  我们在 Go 语言中使用 defer 时会遇到两个常见问题，这里会介绍具体的场景并分析这两个现象背后的设计原理："><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="理解 Go 语言 defer 关键字的原理"><meta property="og:description" content="5.3 defer #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。这一节会深入 Go 语言的源代码介绍 defer 关键字的实现原理，相信读者读完这一节会对 defer 的数据结构、实现以及调用过程有着更清晰的理解。
作为一个编程语言中的关键字，defer 的实现一定是由编译器和运行时共同完成的，不过在深入源码分析它的实现之前我们还是需要了解 defer 关键字的常见使用场景以及使用时的注意事项。
使用 defer 的最常见场景是在函数调用结束后完成一些收尾工作，例如在 defer 中回滚数据库的事务：
func createPost(db *gorm.DB) error { tx := db.Begin() defer tx.Rollback() if err := tx.Create(&Post{Author: &#34;Draveness&#34;}).Error; err != nil { return err } return tx.Commit().Error } 在使用数据库事务时，我们可以使用上面的代码在创建事务后就立刻调用 Rollback 保证事务一定会回滚。哪怕事务真的执行成功了，那么调用 tx.Commit() 之后再执行 tx.Rollback() 也不会影响已经提交的事务。
5.3.1 现象 #  我们在 Go 语言中使用 defer 时会遇到两个常见问题，这里会介绍具体的场景并分析这两个现象背后的设计原理："><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part2-foundation/ch05-keyword/golang-defer/"><title>理解 Go 语言 defer 关键字的原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>理解 Go 语言 defer 关键字的原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#53-defer>5.3 defer</a><ul><li><a href=#531-现象>5.3.1 现象</a><ul><li><a href=#作用域>作用域</a></li><li><a href=#预计算参数>预计算参数</a></li></ul></li><li><a href=#532-数据结构>5.3.2 数据结构</a></li><li><a href=#533-执行机制>5.3.3 执行机制</a></li><li><a href=#534-堆上分配>5.3.4 堆上分配</a><ul><li><a href=#创建延迟调用>创建延迟调用</a></li><li><a href=#执行延迟调用>执行延迟调用</a></li></ul></li><li><a href=#535-栈上分配>5.3.5 栈上分配</a></li><li><a href=#535-开放编码>5.3.5 开放编码</a><ul><li><a href=#启用优化>启用优化</a></li><li><a href=#延迟记录>延迟记录</a></li></ul></li><li><a href=#537-小结>5.3.7 小结</a></li><li><a href=#538-延伸阅读>5.3.8 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=53-defer>5.3 defer
<a class=anchor href=#53-defer>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>很多现代的编程语言中都有 <code>defer</code> 关键字，Go 语言的 <code>defer</code> 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。这一节会深入 Go 语言的源代码介绍 <code>defer</code> 关键字的实现原理，相信读者读完这一节会对 <code>defer</code> 的数据结构、实现以及调用过程有着更清晰的理解。</p><p>作为一个编程语言中的关键字，<code>defer</code> 的实现一定是由编译器和运行时共同完成的，不过在深入源码分析它的实现之前我们还是需要了解 <code>defer</code> 关键字的常见使用场景以及使用时的注意事项。</p><p>使用 <code>defer</code> 的最常见场景是在函数调用结束后完成一些收尾工作，例如在 <code>defer</code> 中回滚数据库的事务：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createPost</span>(<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>DB</span>) <span style=color:#66d9ef>error</span> {
    <span style=color:#a6e22e>tx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Begin</span>()
    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Rollback</span>()
    
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Create</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Post</span>{<span style=color:#a6e22e>Author</span>: <span style=color:#e6db74>&#34;Draveness&#34;</span>}).<span style=color:#a6e22e>Error</span>; <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
    }
    
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Commit</span>().<span style=color:#a6e22e>Error</span>
}
</code></pre></div><p>在使用数据库事务时，我们可以使用上面的代码在创建事务后就立刻调用 <code>Rollback</code> 保证事务一定会回滚。哪怕事务真的执行成功了，那么调用 <code>tx.Commit()</code> 之后再执行 <code>tx.Rollback()</code> 也不会影响已经提交的事务。</p><h2 id=531-现象>5.3.1 现象
<a class=anchor href=#531-%e7%8e%b0%e8%b1%a1>#</a></h2><p>我们在 Go 语言中使用 <code>defer</code> 时会遇到两个常见问题，这里会介绍具体的场景并分析这两个现象背后的设计原理：</p><ul><li><code>defer</code> 关键字的调用时机以及多次调用 <code>defer</code> 时执行顺序是如何确定的；</li><li><code>defer</code> 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果；</li></ul><h3 id=作用域>作用域
<a class=anchor href=#%e4%bd%9c%e7%94%a8%e5%9f%9f>#</a></h3><p>向 <code>defer</code> 关键字传入的函数会在函数返回之前运行。假设我们在 <code>for</code> 循环中多次调用 <code>defer</code> 关键字：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
	}
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#ae81ff>4</span>
<span style=color:#ae81ff>3</span>
<span style=color:#ae81ff>2</span>
<span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>0</span>
</code></pre></div><p>运行上述代码会倒序执行传入 <code>defer</code> 关键字的所有表达式，因为最后一次调用 <code>defer</code> 时传入了 <code>fmt.Println(4)</code>，所以这段代码会优先打印 4。我们可以通过下面这个简单例子强化对 <code>defer</code> 执行时机的理解：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    {
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;defer runs&#34;</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;block ends&#34;</span>)
    }
    
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main ends&#34;</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>block</span> <span style=color:#a6e22e>ends</span>
<span style=color:#a6e22e>main</span> <span style=color:#a6e22e>ends</span>
<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>runs</span>
</code></pre></div><p>从上述代码的输出我们会发现，<code>defer</code> 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用。</p><h3 id=预计算参数>预计算参数
<a class=anchor href=#%e9%a2%84%e8%ae%a1%e7%ae%97%e5%8f%82%e6%95%b0>#</a></h3><p>Go 语言中所有的函数调用都是传值的，虽然 <code>defer</code> 是关键字，但是也继承了这个特性。假设我们想要计算 <code>main</code> 函数运行的时间，可能会写出以下的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>startedAt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>startedAt</span>))
	
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#ae81ff>0</span><span style=color:#a6e22e>s</span>
</code></pre></div><p>然而上述代码的运行结果并不符合我们的预期，这个现象背后的原因是什么呢？经过分析，我们会发现调用 <code>defer</code> 关键字会立刻拷贝函数中引用的外部参数，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出 0s。</p><p>想要解决这个问题的方法非常简单，我们只需要向 <code>defer</code> 关键字传入匿名函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>startedAt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>startedAt</span>)) }()
	
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#ae81ff>1</span><span style=color:#a6e22e>s</span>
</code></pre></div><p>虽然调用 <code>defer</code> 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 <code>time.Since(startedAt)</code> 会在 <code>main</code> 函数返回前调用并打印出符合预期的结果。</p><h2 id=532-数据结构>5.3.2 数据结构
<a class=anchor href=#532-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p>在介绍 <code>defer</code> 函数的执行过程与实现原理之前，我们首先来了解一下 <code>defer</code> 关键字在 Go 语言源代码中对应的数据结构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_defer</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>siz</span>       <span style=color:#66d9ef>int32</span>
	<span style=color:#a6e22e>started</span>   <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>openDefer</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>sp</span>        <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>pc</span>        <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>fn</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>funcval</span>
	<span style=color:#a6e22e>_panic</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>
	<span style=color:#a6e22e>link</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>
}
</code></pre></div><p><a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体是延迟调用链表上的一个元素，所有的结构体都会通过 <code>link</code> 字段串联成链表。</p><p><img src=https://img.draveness.me/2020-01-19-15794017184603-golang-defer-link.png alt=golang-defer-link></p><p><strong>图 5-10 延迟调用链表</strong></p><p>我们简单介绍一下 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体中的几个字段：</p><ul><li><code>siz</code> 是参数和结果的内存大小；</li><li><code>sp</code> 和 <code>pc</code> 分别代表栈指针和调用方的程序计数器；</li><li><code>fn</code> 是 <code>defer</code> 关键字中传入的函数；</li><li><code>_panic</code> 是触发延迟调用的结构体，可能为空；</li><li><code>openDefer</code> 表示当前 <code>defer</code> 是否经过开放编码的优化；</li></ul><p>除了上述的这些字段之外，<a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 中还包含一些垃圾回收机制使用的字段，这里为了减少理解的成本就都省去了。</p><h2 id=533-执行机制>5.3.3 执行机制
<a class=anchor href=#533-%e6%89%a7%e8%a1%8c%e6%9c%ba%e5%88%b6>#</a></h2><p>中间代码生成阶段的 <a href=/golang/tree/cmd/compile/internal/gc.state.stmt><code>cmd/compile/internal/gc.state.stmt</code></a> 会负责处理程序中的 <code>defer</code>，该函数会根据条件的不同，使用三种不同的机制处理该关键字：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>stmt</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ODEFER</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>hasOpenDefers</span> {
			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>openDeferRecord</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>) <span style=color:#75715e>// 开放编码
</span><span style=color:#75715e></span>		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>callDefer</span> <span style=color:#75715e>// 堆分配
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Esc</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>EscNever</span> {
				<span style=color:#a6e22e>d</span> = <span style=color:#a6e22e>callDeferStack</span> <span style=color:#75715e>// 栈分配
</span><span style=color:#75715e></span>			}
			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>callResult</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>d</span>)
		}
	}
}
</code></pre></div><p>堆分配、栈分配和开放编码是处理 <code>defer</code> 关键字的三种方法，早期的 Go 语言会在堆上分配 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体，不过该实现的性能较差，Go 语言在 1.13 中引入栈上分配的结构体，减少了 30% 的额外开销<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，并在 1.14 中引入了基于开放编码的 <code>defer</code>，使得该关键字的额外开销可以忽略不计<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，我们在一节中会分别介绍三种不同类型 <code>defer</code> 的设计与实现原理。</p><h2 id=534-堆上分配>5.3.4 堆上分配
<a class=anchor href=#534-%e5%a0%86%e4%b8%8a%e5%88%86%e9%85%8d>#</a></h2><p>根据 <a href=/golang/tree/cmd/compile/internal/gc.state.stmt><code>cmd/compile/internal/gc.state.stmt</code></a> 方法对 <code>defer</code> 的处理我们可以看出，堆上分配的 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体是默认的兜底方案，当该方案被启用时，编译器会调用 <a href=/golang/tree/cmd/compile/internal/gc.state.callResult><code>cmd/compile/internal/gc.state.callResult</code></a> 和 <a href=/golang/tree/cmd/compile/internal/gc.state.call><code>cmd/compile/internal/gc.state.call</code></a>，这表示 <code>defer</code> 在编译器看来也是函数调用。</p><p><a href=/golang/tree/cmd/compile/internal/gc.state.call><code>cmd/compile/internal/gc.state.call</code></a> 会负责为所有函数和方法调用生成中间代码，它的工作包括以下内容：</p><ol><li>获取需要执行的函数名、闭包指针、代码指针和函数调用的接收方；</li><li>获取栈地址并将函数或者方法的参数写入栈中；</li><li>使用 <a href=/golang/tree/cmd/compile/internal/gc.state.newValue1A><code>cmd/compile/internal/gc.state.newValue1A</code></a> 以及相关函数生成函数调用的中间代码；</li><li>如果当前调用的函数是 <code>defer</code>，那么会单独生成相关的结束代码块；</li><li>获取函数的返回值地址并结束当前调用；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>k</span> <span style=color:#a6e22e>callKind</span>, <span style=color:#a6e22e>returnResultAddr</span> <span style=color:#66d9ef>bool</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>call</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>callDeferStack</span> {
		<span style=color:#75715e>// 在栈上初始化 defer 结构体
</span><span style=color:#75715e></span>		<span style=color:#f92672>...</span>
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>switch</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>callDefer</span>:
			<span style=color:#a6e22e>aux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>StaticAuxCall</span>(<span style=color:#a6e22e>deferproc</span>, <span style=color:#a6e22e>ACArgs</span>, <span style=color:#a6e22e>ACResults</span>)
			<span style=color:#a6e22e>call</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>newValue1A</span>(<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>OpStaticCall</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>TypeMem</span>, <span style=color:#a6e22e>aux</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mem</span>())
		<span style=color:#f92672>...</span>
		}
		<span style=color:#a6e22e>call</span>.<span style=color:#a6e22e>AuxInt</span> = <span style=color:#a6e22e>stksize</span>
	}
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>vars</span>[<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>memVar</span>] = <span style=color:#a6e22e>call</span>
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>从上述代码中我们能看到，<code>defer</code> 关键字在运行期间会调用 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a>，这个函数接收了参数的大小和闭包所在的地址两个参数。</p><p>编译器不仅将 <code>defer</code> 关键字都转换成 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 函数，它还会通过以下三个步骤为所有调用 <code>defer</code> 的函数末尾插入 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 的函数调用：</p><ol><li><a href=/golang/tree/cmd/compile/internal/gc.walkstmt><code>cmd/compile/internal/gc.walkstmt</code></a> 在遇到 <code>ODEFER</code> 节点时会执行 <code>Curfn.Func.SetHasDefer(true)</code> 设置当前函数的 <code>hasdefer</code> 属性；</li><li><a href=/golang/tree/cmd/compile/internal/gc.buildssa><code>cmd/compile/internal/gc.buildssa</code></a> 会执行 <code>s.hasdefer = fn.Func.HasDefer()</code> 更新 <code>state</code> 的 <code>hasdefer</code>；</li><li><a href=/golang/tree/cmd/compile/internal/gc.state.exit><code>cmd/compile/internal/gc.state.exit</code></a> 会根据 <code>state</code> 的 <code>hasdefer</code> 在函数返回之前插入 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 的函数调用；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>exit</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Block</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>hasdefer</span> {
		<span style=color:#f92672>...</span>
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>rtcall</span>(<span style=color:#a6e22e>Deferreturn</span>, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>nil</span>)
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>当运行时将 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 分配到堆上时，Go 语言的编译器不仅将 <code>defer</code> 转换成了 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a>，还在所有调用 <code>defer</code> 的函数结尾插入了 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a>。上述两个运行时函数是 <code>defer</code> 关键字运行时机制的入口，它们分别承担了不同的工作：</p><ul><li><a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 负责创建新的延迟调用；</li><li><a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 负责在函数调用结束时执行所有的延迟调用；</li></ul><p>我们以上述两个函数为入口介绍 <code>defer</code> 关键字在运行时的执行过程与工作原理。</p><h3 id=创建延迟调用>创建延迟调用
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e5%bb%b6%e8%bf%9f%e8%b0%83%e7%94%a8>#</a></h3><p><a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 会为 <code>defer</code> 创建一个新的 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体、设置它的函数指针 <code>fn</code>、程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并将相关的参数拷贝到相邻的内存空间中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferproc</span>(<span style=color:#a6e22e>siz</span> <span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>funcval</span>) {
	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallersp</span>()
	<span style=color:#a6e22e>argp</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>fn</span>)) <span style=color:#f92672>+</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>fn</span>)
	<span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()

	<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newdefer</span>(<span style=color:#a6e22e>siz</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;deferproc: d.panic != nil after newdefer&#34;</span>)
	}
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> = <span style=color:#a6e22e>fn</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>pc</span> = <span style=color:#a6e22e>callerpc</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>sp</span>
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>siz</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span>:
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PtrSize</span>:
		<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>deferArgs</span>(<span style=color:#a6e22e>d</span>)) = <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>argp</span>))
	<span style=color:#66d9ef>default</span>:
		<span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>deferArgs</span>(<span style=color:#a6e22e>d</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>argp</span>), uintptr(<span style=color:#a6e22e>siz</span>))
	}

	<span style=color:#a6e22e>return0</span>()
}
</code></pre></div><p>最后调用的 <a href=/golang/tree/runtime.return0><code>runtime.return0</code></a> 是唯一一个不会触发延迟调用的函数，它可以避免递归 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 的递归调用。</p><p><a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 中 <a href=/golang/tree/runtime.newdefer><code>runtime.newdefer</code></a> 的作用是想尽办法获得 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体，这里包含三种路径：</p><ol><li>从调度器的延迟调用缓存池 <code>sched.deferpool</code> 中取出结构体并将该结构体追加到当前 Goroutine 的缓存池中；</li><li>从 Goroutine 的延迟调用缓存池 <code>pp.deferpool</code> 中取出结构体；</li><li>通过 <a href=/golang/tree/runtime.mallocgc><code>runtime.mallocgc</code></a> 在堆上创建一个新的结构体；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newdefer</span>(<span style=color:#a6e22e>siz</span> <span style=color:#66d9ef>int32</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>
	<span style=color:#a6e22e>sc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>deferclass</span>(uintptr(<span style=color:#a6e22e>siz</span>))
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sc</span> &lt; uintptr(len(<span style=color:#a6e22e>p</span>{}.<span style=color:#a6e22e>deferpool</span>)) {
		<span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>()
		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>]) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>]) &lt; cap(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>])<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>]
				<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>] = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span>
				<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>] = append(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>], <span style=color:#a6e22e>d</span>)
			}
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>]); <span style=color:#a6e22e>n</span> &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>d</span> = <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>][<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
			<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>][<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] = <span style=color:#66d9ef>nil</span>
			<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>] = <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>sc</span>][:<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
		}
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>total</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>roundupsize</span>(<span style=color:#a6e22e>totaldefersize</span>(uintptr(<span style=color:#a6e22e>siz</span>)))
		<span style=color:#a6e22e>d</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>total</span>, <span style=color:#a6e22e>deferType</span>, <span style=color:#66d9ef>true</span>))
	}
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>siz</span> = <span style=color:#a6e22e>siz</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>d</span>
}
</code></pre></div><p>无论使用哪种方式，只要获取到 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体，它都会被追加到所在 Goroutine <code>_defer</code> 链表的最前面。</p><p><img src=https://img.draveness.me/2020-01-19-15794017184614-golang-new-defer.png alt=golang-new-defer></p><p><strong>图 5-11 追加新的延迟调用</strong></p><p><code>defer</code> 关键字的插入顺序是从后向前的，而 <code>defer</code> 关键字执行是从前向后的，这也是为什么后调用的 <code>defer</code> 会优先执行。</p><h3 id=执行延迟调用>执行延迟调用
<a class=anchor href=#%e6%89%a7%e8%a1%8c%e5%bb%b6%e8%bf%9f%e8%b0%83%e7%94%a8>#</a></h3><p><a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 会从 Goroutine 的 <code>_defer</code> 链表中取出最前面的 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 并调用 <a href=/golang/tree/runtime.jmpdefer><code>runtime.jmpdefer</code></a> 传入需要执行的函数和参数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferreturn</span>(<span style=color:#a6e22e>arg0</span> <span style=color:#66d9ef>uintptr</span>) {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallersp</span>()
	<span style=color:#f92672>...</span>

	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>siz</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span>:
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PtrSize</span>:
		<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arg0</span>)) = <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>deferArgs</span>(<span style=color:#a6e22e>d</span>))
	<span style=color:#66d9ef>default</span>:
		<span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arg0</span>), <span style=color:#a6e22e>deferArgs</span>(<span style=color:#a6e22e>d</span>), uintptr(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>siz</span>))
	}
	<span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span>
	<span style=color:#a6e22e>freedefer</span>(<span style=color:#a6e22e>d</span>)
	<span style=color:#a6e22e>jmpdefer</span>(<span style=color:#a6e22e>fn</span>, uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arg0</span>)))
}
</code></pre></div><p><a href=/golang/tree/runtime.jmpdefer><code>runtime.jmpdefer</code></a> 是一个用汇编语言实现的运行时函数，它的主要工作是跳转到 <code>defer</code> 所在的代码段并在执行结束之后跳转回 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>jmpdefer</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>
	<span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>fv</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>DX</span>	<span style=color:#75715e>// fn
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>argp</span><span style=color:#f92672>+</span><span style=color:#ae81ff>4</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>BX</span>	<span style=color:#75715e>// caller sp
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>LEAL</span>	<span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>SP</span>	<span style=color:#75715e>// caller sp after CALL
</span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>ifdef</span> <span style=color:#a6e22e>GOBUILDMODE_shared</span>
	<span style=color:#a6e22e>SUBL</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>16</span>, (<span style=color:#a6e22e>SP</span>)	<span style=color:#75715e>// return to CALL again
</span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#66d9ef>else</span>
	<span style=color:#a6e22e>SUBL</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>5</span>, (<span style=color:#a6e22e>SP</span>)	<span style=color:#75715e>// return to CALL again
</span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>endif</span>
	<span style=color:#a6e22e>MOVL</span>	<span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>DX</span>), <span style=color:#a6e22e>BX</span>
	<span style=color:#a6e22e>JMP</span>	<span style=color:#a6e22e>BX</span>	<span style=color:#75715e>// but first run the deferred function
</span></code></pre></div><p><a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 会多次判断当前 Goroutine 的 <code>_defer</code> 链表中是否有未执行的结构体，该函数只有在所有延迟函数都执行后才会返回。</p><h2 id=535-栈上分配>5.3.5 栈上分配
<a class=anchor href=#535-%e6%a0%88%e4%b8%8a%e5%88%86%e9%85%8d>#</a></h2><p>在默认情况下，我们可以看到 Go 语言中 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体都会在堆上分配，如果我们能够将部分结构体分配到栈上就可以节约内存分配带来的额外开销。</p><p>Go 语言团队在 1.13 中对 <code>defer</code> 关键字进行了优化，当该关键字在函数体中最多执行一次时，编译期间的 <a href=/golang/tree/cmd/compile/internal/gc.state.call><code>cmd/compile/internal/gc.state.call</code></a> 会将结构体分配到栈上并调用 <a href=/golang/tree/runtime.deferprocStack><code>runtime.deferprocStack</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>k</span> <span style=color:#a6e22e>callKind</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>call</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>callDeferStack</span> {
		<span style=color:#75715e>// 在栈上创建 _defer 结构体
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>deferstruct</span>(<span style=color:#a6e22e>stksize</span>)
		<span style=color:#f92672>...</span>

		<span style=color:#a6e22e>ACArgs</span> = append(<span style=color:#a6e22e>ACArgs</span>, <span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Param</span>{<span style=color:#a6e22e>Type</span>: <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TUINTPTR</span>], <span style=color:#a6e22e>Offset</span>: int32(<span style=color:#a6e22e>Ctxt</span>.<span style=color:#a6e22e>FixedFrameSize</span>())})
		<span style=color:#a6e22e>aux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>StaticAuxCall</span>(<span style=color:#a6e22e>deferprocStack</span>, <span style=color:#a6e22e>ACArgs</span>, <span style=color:#a6e22e>ACResults</span>) <span style=color:#75715e>// 调用 deferprocStack
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>arg0</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>constOffPtrSP</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TUINTPTR</span>], <span style=color:#a6e22e>Ctxt</span>.<span style=color:#a6e22e>FixedFrameSize</span>())
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>store</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TUINTPTR</span>], <span style=color:#a6e22e>arg0</span>, <span style=color:#a6e22e>addr</span>)
		<span style=color:#a6e22e>call</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>newValue1A</span>(<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>OpStaticCall</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>TypeMem</span>, <span style=color:#a6e22e>aux</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mem</span>())
		<span style=color:#a6e22e>call</span>.<span style=color:#a6e22e>AuxInt</span> = <span style=color:#a6e22e>stksize</span>
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#f92672>...</span>
	}
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>vars</span>[<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>memVar</span>] = <span style=color:#a6e22e>call</span>
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>因为在编译期间我们已经创建了 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体，所以在运行期间 <a href=/golang/tree/runtime.deferprocStack><code>runtime.deferprocStack</code></a> 只需要设置一些未在编译期间初始化的字段，就可以将栈上的 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 追加到函数的链表上：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferprocStack</span>(<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>) {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>started</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>heap</span> = <span style=color:#66d9ef>false</span> <span style=color:#75715e>// 栈上分配的 _defer
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>openDefer</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>getcallersp</span>()
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>pc</span> = <span style=color:#a6e22e>getcallerpc</span>()
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>framepc</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>varp</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span>)) = <span style=color:#ae81ff>0</span>
	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fd</span>)) = <span style=color:#ae81ff>0</span>
	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span>)) = uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span>))
	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span>)) = uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>d</span>))

	<span style=color:#a6e22e>return0</span>()
}
</code></pre></div><p>除了分配位置的不同，栈上分配和堆上分配的 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 并没有本质的不同，而该方法可以适用于绝大多数的场景，与堆上分配的 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 相比，该方法可以将 <code>defer</code> 关键字的额外开销降低 ~30%。</p><h2 id=535-开放编码>5.3.5 开放编码
<a class=anchor href=#535-%e5%bc%80%e6%94%be%e7%bc%96%e7%a0%81>#</a></h2><p>Go 语言在 1.14 中通过开放编码（Open Coded）实现 <code>defer</code> 关键字，该设计使用代码内联优化 <code>defer</code> 关键的额外开销并引入函数数据 <code>funcdata</code> 管理 <code>panic</code> 的调用<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，该优化可以将 <code>defer</code> 的调用开销从 1.13 版本的 ~35ns 降低至 ~6ns 左右：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>With</span> <span style=color:#a6e22e>normal</span> (<span style=color:#a6e22e>stack</span><span style=color:#f92672>-</span><span style=color:#a6e22e>allocated</span>) <span style=color:#a6e22e>defers</span> <span style=color:#a6e22e>only</span>:         <span style=color:#ae81ff>35.4</span>  <span style=color:#a6e22e>ns</span><span style=color:#f92672>/</span><span style=color:#a6e22e>op</span>
<span style=color:#a6e22e>With</span> <span style=color:#a6e22e>open</span><span style=color:#f92672>-</span><span style=color:#a6e22e>coded</span> <span style=color:#a6e22e>defers</span>:                             <span style=color:#ae81ff>5.6</span>  <span style=color:#a6e22e>ns</span><span style=color:#f92672>/</span><span style=color:#a6e22e>op</span>
<span style=color:#a6e22e>Cost</span> <span style=color:#a6e22e>of</span> <span style=color:#a6e22e>function</span> <span style=color:#a6e22e>call</span> <span style=color:#a6e22e>alone</span> (<span style=color:#a6e22e>remove</span> <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>keyword</span>): <span style=color:#ae81ff>4.4</span>  <span style=color:#a6e22e>ns</span><span style=color:#f92672>/</span><span style=color:#a6e22e>op</span>
</code></pre></div><p>然而开放编码作为一种优化 <code>defer</code> 关键字的方法，它不是在所有的场景下都会开启的，开放编码只会在满足以下的条件时启用：</p><ol><li>函数的 <code>defer</code> 数量少于或者等于 8 个；</li><li>函数的 <code>defer</code> 关键字不能在循环中执行；</li><li>函数的 <code>return</code> 语句与 <code>defer</code> 语句的乘积小于或者等于 15 个；</li></ol><p>初看上述几个条件可能会觉得不明所以，但是当我们深入理解基于开放编码的优化就可以明白上述限制背后的原因，除了上述几个条件之外，也有其他的条件会限制开放编码的使用，不过这些都是不太重要的细节，我们在这里也不会深究。</p><h3 id=启用优化>启用优化
<a class=anchor href=#%e5%90%af%e7%94%a8%e4%bc%98%e5%8c%96>#</a></h3><p>Go 语言会在编译期间就确定是否启用开放编码，在编译器生成中间代码之前，我们会使用 <a href=/golang/tree/cmd/compile/internal/gc.walkstmt><code>cmd/compile/internal/gc.walkstmt</code></a> 修改已经生成的抽象语法树，设置函数体上的 <code>OpenCodedDeferDisallowed</code> 属性：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maxOpenDefers</span> = <span style=color:#ae81ff>8</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkstmt</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ODEFER</span>:
		<span style=color:#a6e22e>Curfn</span>.<span style=color:#a6e22e>Func</span>.<span style=color:#a6e22e>SetHasDefer</span>(<span style=color:#66d9ef>true</span>)
		<span style=color:#a6e22e>Curfn</span>.<span style=color:#a6e22e>Func</span>.<span style=color:#a6e22e>numDefers</span><span style=color:#f92672>++</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>Curfn</span>.<span style=color:#a6e22e>Func</span>.<span style=color:#a6e22e>numDefers</span> &gt; <span style=color:#a6e22e>maxOpenDefers</span> {
			<span style=color:#a6e22e>Curfn</span>.<span style=color:#a6e22e>Func</span>.<span style=color:#a6e22e>SetOpenCodedDeferDisallowed</span>(<span style=color:#66d9ef>true</span>)
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Esc</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>EscNever</span> {
			<span style=color:#a6e22e>Curfn</span>.<span style=color:#a6e22e>Func</span>.<span style=color:#a6e22e>SetOpenCodedDeferDisallowed</span>(<span style=color:#66d9ef>true</span>)
		}
		<span style=color:#66d9ef>fallthrough</span>
	<span style=color:#f92672>...</span>
	}
}
</code></pre></div><p>就像我们上面提到的，如果函数中 <code>defer</code> 关键字的数量多于 8 个或者 <code>defer</code> 关键字处于 <code>for</code> 循环中，那么我们在这里都会禁用开放编码优化，使用上两节提到的方法处理 <code>defer</code>。</p><p>在 SSA 中间代码生成阶段的 <a href=/golang/tree/cmd/compile/internal/gc.buildssa><code>cmd/compile/internal/gc.buildssa</code></a> 中，我们也能够看到启用开放编码优化的其他条件，也就是返回语句的数量与 <code>defer</code> 数量的乘积需要小于 15：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>buildssa</span>(<span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>worker</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Func</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>hasOpenDefers</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>hasdefer</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>curfn</span>.<span style=color:#a6e22e>Func</span>.<span style=color:#a6e22e>OpenCodedDeferDisallowed</span>()
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>hasOpenDefers</span> <span style=color:#f92672>&amp;&amp;</span>
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>curfn</span>.<span style=color:#a6e22e>Func</span>.<span style=color:#a6e22e>numReturns</span><span style=color:#f92672>*</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>curfn</span>.<span style=color:#a6e22e>Func</span>.<span style=color:#a6e22e>numDefers</span> &gt; <span style=color:#ae81ff>15</span> {
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>hasOpenDefers</span> = <span style=color:#66d9ef>false</span>
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>中间代码生成的这两个步骤会决定当前函数是否应该使用开放编码优化 <code>defer</code> 关键字，一旦确定使用开放编码，就会在编译期间初始化延迟比特和延迟记录。</p><h3 id=延迟记录>延迟记录
<a class=anchor href=#%e5%bb%b6%e8%bf%9f%e8%ae%b0%e5%bd%95>#</a></h3><p>延迟比特和延迟记录是使用开放编码实现 <code>defer</code> 的两个最重要结构，一旦决定使用开放编码，<a href=/golang/tree/cmd/compile/internal/gc.buildssa><code>cmd/compile/internal/gc.buildssa</code></a> 会在编译期间在栈上初始化大小为 8 个比特的 <code>deferBits</code> 变量：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>buildssa</span>(<span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>worker</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Func</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>hasOpenDefers</span> {
		<span style=color:#a6e22e>deferBitsTemp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tempAt</span>(<span style=color:#a6e22e>src</span>.<span style=color:#a6e22e>NoXPos</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>curfn</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TUINT8</span>]) <span style=color:#75715e>// 初始化延迟比特
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>deferBitsTemp</span> = <span style=color:#a6e22e>deferBitsTemp</span>
		<span style=color:#a6e22e>startDeferBits</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>entryNewValue0</span>(<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>OpConst8</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TUINT8</span>])
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>vars</span>[<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>deferBitsVar</span>] = <span style=color:#a6e22e>startDeferBits</span>
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>deferBitsAddr</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>addr</span>(<span style=color:#a6e22e>deferBitsTemp</span>)
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>store</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TUINT8</span>], <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>deferBitsAddr</span>, <span style=color:#a6e22e>startDeferBits</span>)
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>vars</span>[<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>memVar</span>] = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>newValue1Apos</span>(<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>OpVarLive</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>TypeMem</span>, <span style=color:#a6e22e>deferBitsTemp</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mem</span>(), <span style=color:#66d9ef>false</span>)
	}
}
</code></pre></div><p>延迟比特中的每一个比特位都表示该位对应的 <code>defer</code> 关键字是否需要被执行，如下图所示，其中 8 个比特的倒数第二个比特在函数返回前被设置成了 1，那么该比特位对应的函数会在函数返回前执行：</p><p><img src=https://img.draveness.me/2020-10-31-16041438704362/golang-defer-bits.png alt=golang-defer-bits></p><p><strong>图 5-12 延迟比特</strong></p><p>因为不是函数中所有的 <code>defer</code> 语句都会在函数返回前执行，如下所示的代码只会在 <code>if</code> 语句的条件为真时，其中的 <code>defer</code> 语句才会在结尾被执行<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 初始化 deferBits
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>_f1</span>, <span style=color:#a6e22e>_a1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f1</span>, <span style=color:#a6e22e>a1</span>  <span style=color:#75715e>// 保存函数以及参数
</span><span style=color:#75715e></span><span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 将 deferBits 最后一位置位 1
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>condition</span> {
    <span style=color:#a6e22e>_f2</span>, <span style=color:#a6e22e>_a2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f2</span>, <span style=color:#a6e22e>a2</span>  <span style=color:#75715e>// 保存函数以及参数
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 将 deferBits 倒数第二位置位 1
</span><span style=color:#75715e></span>}
<span style=color:#a6e22e>exit</span>:

<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
    <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>
    <span style=color:#a6e22e>_f2</span>(<span style=color:#a6e22e>a2</span>)
}

<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
    <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>0</span>
    <span style=color:#a6e22e>_f1</span>(<span style=color:#a6e22e>a1</span>)
}
</code></pre></div><p>延迟比特的作用就是标记哪些 <code>defer</code> 关键字在函数中被执行，这样在函数返回时可以根据对应 <code>deferBits</code> 的内容确定执行的函数，而正是因为 <code>deferBits</code> 的大小仅为 8 比特，所以该优化的启用条件为函数中的 <code>defer</code> 关键字少于 8 个。</p><p>上述伪代码展示了开放编码的实现原理，但是仍然缺少了一些细节，例如：传入 <code>defer</code> 关键字的函数和参数都会存储在如下所示的 <a href=/golang/tree/cmd/compile/internal/gc.openDeferInfo><code>cmd/compile/internal/gc.openDeferInfo</code></a> 结构体中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>openDeferInfo</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>n</span>           <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>
	<span style=color:#a6e22e>closure</span>     <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span>
	<span style=color:#a6e22e>closureNode</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>
	<span style=color:#a6e22e>rcvr</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span>
	<span style=color:#a6e22e>rcvrNode</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>
	<span style=color:#a6e22e>argVals</span>     []<span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span>
	<span style=color:#a6e22e>argNodes</span>    []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>
}
</code></pre></div><p>当编译器在调用 <a href=/golang/tree/cmd/compile/internal/gc.buildssa><code>cmd/compile/internal/gc.buildssa</code></a> 构建中间代码时会通过 <a href=/golang/tree/cmd/compile/internal/gc.state.openDeferRecord><code>cmd/compile/internal/gc.state.openDeferRecord</code></a> 方法在栈上构建结构体，该结构体的 <code>closure</code> 中存储着调用的函数，<code>rcvr</code> 中存储着方法的接收者，而最后的 <code>argVals</code> 中存储了函数的参数。</p><p>很多 <code>defer</code> 语句都可以在编译期间判断是否被执行，如果函数中的 <code>defer</code> 语句都会在编译期间确定，中间代码生成阶段就会直接调用 <a href=/golang/tree/cmd/compile/internal/gc.state.openDeferExit><code>cmd/compile/internal/gc.state.openDeferExit</code></a> 在函数返回前生成判断 <code>deferBits</code> 的代码，也就是上述伪代码中的后半部分。</p><p>不过当程序遇到运行时才能判断的条件语句时，我们仍然需要由运行时的 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 决定是否执行 <code>defer</code> 关键字：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferreturn</span>(<span style=color:#a6e22e>arg0</span> <span style=color:#66d9ef>uintptr</span>) {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span>
	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallersp</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>openDefer</span> {
		<span style=color:#a6e22e>runOpenDeferFrame</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>d</span>)
		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span>
		<span style=color:#a6e22e>freedefer</span>(<span style=color:#a6e22e>d</span>)
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>该函数为开放编码做了特殊的优化，运行时会调用 <a href=/golang/tree/runtime.runOpenDeferFrame><code>runtime.runOpenDeferFrame</code></a> 执行活跃的开放编码延迟函数，该函数会执行以下的工作：</p><ol><li>从 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体中读取 <code>deferBits</code>、函数 <code>defer</code> 数量等信息；</li><li>在循环中依次读取函数的地址和参数信息并通过 <code>deferBits</code> 判断该函数是否需要被执行；</li><li>调用 <a href=/golang/tree/runtime.reflectcallSave><code>runtime.reflectcallSave</code></a> 调用需要执行的 <code>defer</code> 函数；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runOpenDeferFrame</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#a6e22e>fd</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fd</span>

	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>deferBitsOffset</span>, <span style=color:#a6e22e>fd</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>readvarintUnsafe</span>(<span style=color:#a6e22e>fd</span>)
	<span style=color:#a6e22e>nDefers</span>, <span style=color:#a6e22e>fd</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>readvarintUnsafe</span>(<span style=color:#a6e22e>fd</span>)
	<span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uint8</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>varp</span> <span style=color:#f92672>-</span> uintptr(<span style=color:#a6e22e>deferBitsOffset</span>)))

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>nDefers</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>--</span> {
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>argWidth</span>, <span style=color:#a6e22e>closureOffset</span>, <span style=color:#a6e22e>nArgs</span> <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// 读取函数的地址和参数信息
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>argWidth</span>, <span style=color:#a6e22e>fd</span> = <span style=color:#a6e22e>readvarintUnsafe</span>(<span style=color:#a6e22e>fd</span>)
		<span style=color:#a6e22e>closureOffset</span>, <span style=color:#a6e22e>fd</span> = <span style=color:#a6e22e>readvarintUnsafe</span>(<span style=color:#a6e22e>fd</span>)
		<span style=color:#a6e22e>nArgs</span>, <span style=color:#a6e22e>fd</span> = <span style=color:#a6e22e>readvarintUnsafe</span>(<span style=color:#a6e22e>fd</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>deferBits</span><span style=color:#f92672>&amp;</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#a6e22e>i</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#f92672>...</span>
			<span style=color:#66d9ef>continue</span>
		}
		<span style=color:#a6e22e>closure</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>**</span><span style=color:#a6e22e>funcval</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>varp</span> <span style=color:#f92672>-</span> uintptr(<span style=color:#a6e22e>closureOffset</span>)))
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> = <span style=color:#a6e22e>closure</span>

		<span style=color:#f92672>...</span>

		<span style=color:#a6e22e>deferBits</span> = <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>&amp;^</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>i</span>)
		<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uint8</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>varp</span> <span style=color:#f92672>-</span> uintptr(<span style=color:#a6e22e>deferBitsOffset</span>))) = <span style=color:#a6e22e>deferBits</span>
		<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span>
		<span style=color:#a6e22e>reflectcallSave</span>(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>closure</span>), <span style=color:#a6e22e>deferArgs</span>, <span style=color:#a6e22e>argWidth</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>aborted</span> {
			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>memclrNoHeapPointers</span>(<span style=color:#a6e22e>deferArgs</span>, uintptr(<span style=color:#a6e22e>argWidth</span>))
		<span style=color:#f92672>...</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>done</span>
}
</code></pre></div><p>Go 语言的编译器为了支持开放编码在中间代码生成阶段做出了很多修改，我们在这里虽然省略了很多细节，但是也可以很好地展示 <code>defer</code> 关键字的实现原理。</p><h2 id=537-小结>5.3.7 小结
<a class=anchor href=#537-%e5%b0%8f%e7%bb%93>#</a></h2><p><code>defer</code> 关键字的实现主要依靠编译器和运行时的协作，我们总结一下本节提到的三种机制：</p><ul><li>堆上分配 · 1.1 ~ 1.12<ul><li>编译期将 <code>defer</code> 关键字转换成 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 并在调用 <code>defer</code> 关键字的函数返回之前插入 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a>；</li><li>运行时调用 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 会将一个新的 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体追加到当前 Goroutine 的链表头；</li><li>运行时调用 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 会从 Goroutine 的链表中取出 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构并依次执行；</li></ul></li><li>栈上分配 · 1.13<ul><li>当该关键字在函数体中最多执行一次时，编译期间的 <a href=/golang/tree/cmd/compile/internal/gc.state.call><code>cmd/compile/internal/gc.state.call</code></a> 会将结构体分配到栈上并调用 <a href=/golang/tree/runtime.deferprocStack><code>runtime.deferprocStack</code></a>；</li></ul></li><li>开放编码 · 1.14 ~ 现在<ul><li>编译期间判断 <code>defer</code> 关键字、<code>return</code> 语句的个数确定是否开启开放编码优化；</li><li>通过 <code>deferBits</code> 和 <a href=/golang/tree/cmd/compile/internal/gc.openDeferInfo><code>cmd/compile/internal/gc.openDeferInfo</code></a> 存储 <code>defer</code> 关键字的相关信息；</li><li>如果 <code>defer</code> 关键字的执行可以在编译期间确定，会在函数返回前直接插入相应的代码，否则会由运行时的 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 处理；</li></ul></li></ul><p>我们在本节前面提到的两个现象在这里也可以解释清楚了：</p><ul><li>后调用的 <code>defer</code> 函数会先执行：<ul><li>后调用的 <code>defer</code> 函数会被追加到 Goroutine <code>_defer</code> 链表的最前面；</li><li>运行 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 时是从前到后依次执行；</li></ul></li><li>函数的参数会被预先计算；<ul><li>调用 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；</li></ul></li></ul><h2 id=538-延伸阅读>5.3.8 延伸阅读
<a class=anchor href=#538-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=https://blog.learngoprogramming.com/gotchas-of-defer-in-go-1-8d070894cb01>5 Gotchas of Defer in Go — Part I</a></li><li><a href=https://stackoverflow.com/questions/28893586/golang-defer-clarification>Golang defer clarification</a></li><li><a href=http://hustcat.github.io/dive-into-stack-defer-panic-recover-in-go/>Dive into stack and defer/panic/recover in go</a></li><li><a href=https://blog.golang.org/defer-panic-and-recover>Defer, Panic, and Recover</a></li></ul><p><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/ class=book-btn>上一节</a>
<a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>171758: cmd/compile,runtime: allocate defer records on the stack <a href=https://go-review.googlesource.com/c/go/+/171758/>https://go-review.googlesource.com/c/go/+/171758/</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>190098: cmd/compile, cmd/link, runtime: make defers low-cost through inline code and extra funcdata <a href=https://go-review.googlesource.com/c/go/+/190098/6>https://go-review.googlesource.com/c/go/+/190098/6</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Dan Scales, Keith Randall, and Austin Clements. Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case. 2019-09-23. <a href=https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md>https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Three mechanisms of Go language defer statements. <a href=https://ofstack.com/Golang/28467/three-mechanisms-of-go-language-defer-statements.html>https://ofstack.com/Golang/28467/three-mechanisms-of-go-language-defer-statements.html</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-defer data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-defer",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#53-defer>5.3 defer</a><ul><li><a href=#531-现象>5.3.1 现象</a><ul><li><a href=#作用域>作用域</a></li><li><a href=#预计算参数>预计算参数</a></li></ul></li><li><a href=#532-数据结构>5.3.2 数据结构</a></li><li><a href=#533-执行机制>5.3.3 执行机制</a></li><li><a href=#534-堆上分配>5.3.4 堆上分配</a><ul><li><a href=#创建延迟调用>创建延迟调用</a></li><li><a href=#执行延迟调用>执行延迟调用</a></li></ul></li><li><a href=#535-栈上分配>5.3.5 栈上分配</a></li><li><a href=#535-开放编码>5.3.5 开放编码</a><ul><li><a href=#启用优化>启用优化</a></li><li><a href=#延迟记录>延迟记录</a></li></ul></li><li><a href=#537-小结>5.3.7 小结</a></li><li><a href=#538-延伸阅读>5.3.8 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>