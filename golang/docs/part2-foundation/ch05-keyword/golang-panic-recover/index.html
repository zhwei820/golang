<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="5.4 panic 和 recover #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数，也提供了互补的功能。
图 5-12 panic 触发的递归延迟调用
 panic 能够改变程序的控制流，调用 panic 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 defer； recover 可以中止 panic 造成的程序崩溃。它是一个只能在 defer 中发挥作用的函数，在其他作用域中调用不会发挥作用；  5.4.1 现象 #  我们先通过几个例子了解一下使用 panic 和 recover 关键字时遇到的现象，部分现象也与上一节分析的 defer 关键字有关：
 panic 只会触发当前 Goroutine 的 defer； recover 只有在 defer 中调用才会生效； panic 允许在 defer 中嵌套多次调用；  跨协程失效 #  首先要介绍的现象是 panic 只会触发当前 Goroutine 的延迟函数调用，我们可以通过如下所示的代码了解该现象："><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言 panic 和 recover 的原理"><meta property="og:description" content="5.4 panic 和 recover #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数，也提供了互补的功能。
图 5-12 panic 触发的递归延迟调用
 panic 能够改变程序的控制流，调用 panic 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 defer； recover 可以中止 panic 造成的程序崩溃。它是一个只能在 defer 中发挥作用的函数，在其他作用域中调用不会发挥作用；  5.4.1 现象 #  我们先通过几个例子了解一下使用 panic 和 recover 关键字时遇到的现象，部分现象也与上一节分析的 defer 关键字有关：
 panic 只会触发当前 Goroutine 的 defer； recover 只有在 defer 中调用才会生效； panic 允许在 defer 中嵌套多次调用；  跨协程失效 #  首先要介绍的现象是 panic 只会触发当前 Goroutine 的延迟函数调用，我们可以通过如下所示的代码了解该现象："><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/"><title>Go 语言 panic 和 recover 的原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言 panic 和 recover 的原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#54-panic-和-recover>5.4 panic 和 recover</a><ul><li><a href=#541-现象>5.4.1 现象</a><ul><li><a href=#跨协程失效>跨协程失效</a></li><li><a href=#失效的崩溃恢复>失效的崩溃恢复</a></li><li><a href=#嵌套崩溃>嵌套崩溃</a></li></ul></li><li><a href=#542-数据结构>5.4.2 数据结构</a></li><li><a href=#543-程序崩溃>5.4.3 程序崩溃</a></li><li><a href=#544-崩溃恢复>5.4.4 崩溃恢复</a></li><li><a href=#545-小结>5.4.5 小结</a></li><li><a href=#546-延伸阅读>5.4.6 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=54-panic-和-recover>5.4 panic 和 recover
<a class=anchor href=#54-panic-%e5%92%8c-recover>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>本节将分析 Go 语言中两个经常成对出现的两个关键字 — <code>panic</code> 和 <code>recover</code>。这两个关键字与上一节提到的 <code>defer</code> 有紧密的联系，它们都是 Go 语言中的内置函数，也提供了互补的功能。</p><p><img src=https://img.draveness.me/2020-01-19-15794253208982-golang-panic.png alt=golang-panic></p><p><strong>图 5-12 panic 触发的递归延迟调用</strong></p><ul><li><code>panic</code> 能够改变程序的控制流，调用 <code>panic</code> 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 <code>defer</code>；</li><li><code>recover</code> 可以中止 <code>panic</code> 造成的程序崩溃。它是一个只能在 <code>defer</code> 中发挥作用的函数，在其他作用域中调用不会发挥作用；</li></ul><h2 id=541-现象>5.4.1 现象
<a class=anchor href=#541-%e7%8e%b0%e8%b1%a1>#</a></h2><p>我们先通过几个例子了解一下使用 <code>panic</code> 和 <code>recover</code> 关键字时遇到的现象，部分现象也与上一节分析的 <code>defer</code> 关键字有关：</p><ul><li><code>panic</code> 只会触发当前 Goroutine 的 <code>defer</code>；</li><li><code>recover</code> 只有在 <code>defer</code> 中调用才会生效；</li><li><code>panic</code> 允许在 <code>defer</code> 中嵌套多次调用；</li></ul><h3 id=跨协程失效>跨协程失效
<a class=anchor href=#%e8%b7%a8%e5%8d%8f%e7%a8%8b%e5%a4%b1%e6%95%88>#</a></h3><p>首先要介绍的现象是 <code>panic</code> 只会触发当前 Goroutine 的延迟函数调用，我们可以通过如下所示的代码了解该现象：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>defer</span> println(<span style=color:#e6db74>&#34;in main&#34;</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#66d9ef>defer</span> println(<span style=color:#e6db74>&#34;in goroutine&#34;</span>)
		panic(<span style=color:#e6db74>&#34;&#34;</span>)
	}()

	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>in</span> <span style=color:#a6e22e>goroutine</span>
<span style=color:#a6e22e>panic</span>:
<span style=color:#f92672>...</span>
</code></pre></div><p>当我们运行这段代码时会发现 <code>main</code> 函数中的 <code>defer</code> 语句并没有执行，执行的只有当前 Goroutine 中的 <code>defer</code>。</p><p>前面我们曾经介绍过 <code>defer</code> 关键字对应的 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 会将延迟调用函数与调用方所在 Goroutine 进行关联。所以当程序发生崩溃时只会调用当前 Goroutine 的延迟调用函数也是非常合理的。</p><p><img src=https://img.draveness.me/2020-01-19-15794253176199-golang-panic-and-defers.png alt=golang-panic-and-defers></p><p><strong>图 5-13 panic 触发当前 Goroutine 的延迟调用</strong></p><p>如上图所示，多个 Goroutine 之间没有太多的关联，一个 Goroutine 在 <code>panic</code> 时也不应该执行其他 Goroutine 的延迟函数。</p><h3 id=失效的崩溃恢复>失效的崩溃恢复
<a class=anchor href=#%e5%a4%b1%e6%95%88%e7%9a%84%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d>#</a></h3><p>初学 Go 语言的读者可能会写出下面的代码，在主程序中调用 <code>recover</code> 试图中止程序的崩溃，但是从运行的结果中我们也能看出，下面的程序没有正常退出。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;in main&#34;</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
	}

	panic(<span style=color:#e6db74>&#34;unknown err&#34;</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>in</span> <span style=color:#a6e22e>main</span>
<span style=color:#a6e22e>panic</span>: <span style=color:#a6e22e>unknown</span> <span style=color:#a6e22e>err</span>

<span style=color:#a6e22e>goroutine</span> <span style=color:#ae81ff>1</span> [<span style=color:#a6e22e>running</span>]:
<span style=color:#a6e22e>main</span>.<span style=color:#a6e22e>main</span>()
	<span style=color:#f92672>...</span>
<span style=color:#a6e22e>exit</span> <span style=color:#a6e22e>status</span> <span style=color:#ae81ff>2</span>
</code></pre></div><p>仔细分析一下这个过程就能理解这种现象背后的原因，<code>recover</code> 只有在发生 <code>panic</code> 之后调用才会生效。然而在上面的控制流中，<code>recover</code> 是在 <code>panic</code> 之前调用的，并不满足生效的条件，所以我们需要在 <code>defer</code> 中使用 <code>recover</code> 关键字。</p><h3 id=嵌套崩溃>嵌套崩溃
<a class=anchor href=#%e5%b5%8c%e5%a5%97%e5%b4%a9%e6%ba%83>#</a></h3><p>Go 语言中的 <code>panic</code> 是可以多次嵌套调用的。一些熟悉 Go 语言的读者很可能也不知道这个知识点，如下所示的代码就展示了如何在 <code>defer</code> 函数中多次调用 <code>panic</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;in main&#34;</span>)
	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
			panic(<span style=color:#e6db74>&#34;panic again and again&#34;</span>)
		}()
		panic(<span style=color:#e6db74>&#34;panic again&#34;</span>)
	}()

	panic(<span style=color:#e6db74>&#34;panic once&#34;</span>)
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>in</span> <span style=color:#a6e22e>main</span>
<span style=color:#a6e22e>panic</span>: <span style=color:#a6e22e>panic</span> <span style=color:#a6e22e>once</span>
	<span style=color:#a6e22e>panic</span>: <span style=color:#a6e22e>panic</span> <span style=color:#a6e22e>again</span>
	<span style=color:#a6e22e>panic</span>: <span style=color:#a6e22e>panic</span> <span style=color:#a6e22e>again</span> <span style=color:#a6e22e>and</span> <span style=color:#a6e22e>again</span>

<span style=color:#a6e22e>goroutine</span> <span style=color:#ae81ff>1</span> [<span style=color:#a6e22e>running</span>]:
<span style=color:#f92672>...</span>
<span style=color:#a6e22e>exit</span> <span style=color:#a6e22e>status</span> <span style=color:#ae81ff>2</span>
</code></pre></div><p>从上述程序输出的结果，我们可以确定程序多次调用 <code>panic</code> 也不会影响 <code>defer</code> 函数的正常执行，所以使用 <code>defer</code> 进行收尾工作一般来说都是安全的。</p><h2 id=542-数据结构>5.4.2 数据结构
<a class=anchor href=#542-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p><code>panic</code> 关键字在 Go 语言的源代码是由数据结构 <a href=/golang/tree/runtime._panic><code>runtime._panic</code></a> 表示的。每当我们调用 <code>panic</code> 都会创建一个如下所示的数据结构存储相关信息：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_panic</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>argp</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
	<span style=color:#a6e22e>arg</span>       <span style=color:#66d9ef>interface</span>{}
	<span style=color:#a6e22e>link</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>
	<span style=color:#a6e22e>recovered</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>aborted</span>   <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>pc</span>        <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>sp</span>        <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
	<span style=color:#a6e22e>goexit</span>    <span style=color:#66d9ef>bool</span>
}
</code></pre></div><ol><li><code>argp</code> 是指向 <code>defer</code> 调用时参数的指针；</li><li><code>arg</code> 是调用 <code>panic</code> 时传入的参数；</li><li><code>link</code> 指向了更早调用的 <a href=/golang/tree/runtime._panic><code>runtime._panic</code></a> 结构；</li><li><code>recovered</code> 表示当前 <a href=/golang/tree/runtime._panic><code>runtime._panic</code></a> 是否被 <code>recover</code> 恢复；</li><li><code>aborted</code> 表示当前的 <code>panic</code> 是否被强行终止；</li></ol><p>从数据结构中的 <code>link</code> 字段我们就可以推测出以下的结论：<code>panic</code> 函数可以被连续多次调用，它们之间通过 <code>link</code> 可以组成链表。</p><p>结构体中的 <code>pc</code>、<code>sp</code> 和 <code>goexit</code> 三个字段都是为了修复 <a href=/golang/tree/runtime.Goexit><code>runtime.Goexit</code></a> 带来的问题引入的<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。<a href=/golang/tree/runtime.Goexit><code>runtime.Goexit</code></a> 能够只结束调用该函数的 Goroutine 而不影响其他的 Goroutine，但是该函数会被 <code>defer</code> 中的 <code>panic</code> 和 <code>recover</code> 取消<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，引入这三个字段就是为了保证该函数的一定会生效。</p><h2 id=543-程序崩溃>5.4.3 程序崩溃
<a class=anchor href=#543-%e7%a8%8b%e5%ba%8f%e5%b4%a9%e6%ba%83>#</a></h2><p>这里先介绍分析 <code>panic</code> 函数是终止程序的实现原理。编译器会将关键字 <code>panic</code> 转换成 <a href=/golang/tree/runtime.gopanic><code>runtime.gopanic</code></a>，该函数的执行过程包含以下几个步骤：</p><ol><li>创建新的 <a href=/golang/tree/runtime._panic><code>runtime._panic</code></a> 并添加到所在 Goroutine 的 <code>_panic</code> 链表的最前面；</li><li>在循环中不断从当前 Goroutine 的 <code>_defer</code> 中链表获取 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 并调用 <a href=/golang/tree/runtime.reflectcall><code>runtime.reflectcall</code></a> 运行延迟调用函数；</li><li>调用 <a href=/golang/tree/runtime.fatalpanic><code>runtime.fatalpanic</code></a> 中止整个程序；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gopanic</span>(<span style=color:#a6e22e>e</span> <span style=color:#66d9ef>interface</span>{}) {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>_panic</span>
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>arg</span> = <span style=color:#a6e22e>e</span>
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>link</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>)(<span style=color:#a6e22e>noescape</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>)))

	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>break</span>
		}

		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>)(<span style=color:#a6e22e>noescape</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>)))

		<span style=color:#a6e22e>reflectcall</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span>), <span style=color:#a6e22e>deferArgs</span>(<span style=color:#a6e22e>d</span>), uint32(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>siz</span>), uint32(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>siz</span>))

		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span>

		<span style=color:#a6e22e>freedefer</span>(<span style=color:#a6e22e>d</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> {
			<span style=color:#f92672>...</span>
		}
	}

	<span style=color:#a6e22e>fatalpanic</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>)
	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#66d9ef>nil</span>) = <span style=color:#ae81ff>0</span>
}
</code></pre></div><p>需要注意的是，我们在上述函数中省略了三部分比较重要的代码：</p><ol><li>恢复程序的 <code>recover</code> 分支中的代码；</li><li>通过内联优化 <code>defer</code> 调用性能的代码<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>；<ul><li><a href=https://github.com/golang/go/commit/be64a19d99918c843f8555aad580221207ea35bc>runtime: make defers low-cost through inline code and extra funcdata</a></li></ul></li><li>修复 <a href=/golang/tree/runtime.Goexit><code>runtime.Goexit</code></a> 异常情况的代码；</li></ol><blockquote><p>Go 语言在 1.14 通过 <a href=https://github.com/golang/go/commit/7dcd343ed641d3b70c09153d3b041ca3fe83b25e>runtime: ensure that Goexit cannot be aborted by a recursive panic/recover</a> 提交解决了递归 <code>panic</code> 和 <code>recover</code> 与 <a href=/golang/tree/runtime.Goexit><code>runtime.Goexit</code></a> 的冲突。</p></blockquote><p><a href=/golang/tree/runtime.fatalpanic><code>runtime.fatalpanic</code></a> 实现了无法被恢复的程序崩溃，它在中止程序之前会通过 <a href=/golang/tree/runtime.printpanics><code>runtime.printpanics</code></a> 打印出全部的 <code>panic</code> 消息以及调用时传入的参数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fatalpanic</span>(<span style=color:#a6e22e>msgs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>) {
	<span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallersp</span>()
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>startpanic_m</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>msgs</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>runningPanicDefers</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
		<span style=color:#a6e22e>printpanics</span>(<span style=color:#a6e22e>msgs</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dopanic_m</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>) {
		<span style=color:#a6e22e>crash</span>()
	}

	<span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>2</span>)
}
</code></pre></div><p>打印崩溃消息后会调用 <a href=/golang/tree/runtime.exit><code>runtime.exit</code></a> 退出当前程序并返回错误码 2，程序的正常退出也是通过 <a href=/golang/tree/runtime.exit><code>runtime.exit</code></a> 实现的。</p><h2 id=544-崩溃恢复>5.4.4 崩溃恢复
<a class=anchor href=#544-%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d>#</a></h2><p>到这里我们已经掌握了 <code>panic</code> 退出程序的过程，接下来将分析 <code>defer</code> 中的 <code>recover</code> 是如何中止程序崩溃的。编译器会将关键字 <code>recover</code> 转换成 <a href=/golang/tree/runtime.gorecover><code>runtime.gorecover</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gorecover</span>(<span style=color:#a6e22e>argp</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>interface</span>{} {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>argp</span> <span style=color:#f92672>==</span> uintptr(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>argp</span>) {
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> = <span style=color:#66d9ef>true</span>
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>arg</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>该函数的实现很简单，如果当前 Goroutine 没有调用 <code>panic</code>，那么该函数会直接返回 <code>nil</code>，这也是崩溃恢复在非 <code>defer</code> 中调用会失效的原因。在正常情况下，它会修改 <a href=/golang/tree/runtime._panic><code>runtime._panic</code></a> 的 <code>recovered</code> 字段，<a href=/golang/tree/runtime.gorecover><code>runtime.gorecover</code></a> 函数中并不包含恢复程序的逻辑，程序的恢复是由 <a href=/golang/tree/runtime.gopanic><code>runtime.gopanic</code></a> 函数负责的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gopanic</span>(<span style=color:#a6e22e>e</span> <span style=color:#66d9ef>interface</span>{}) {
	<span style=color:#f92672>...</span>

	<span style=color:#66d9ef>for</span> {
		<span style=color:#75715e>// 执行延迟调用函数，可能会设置 p.recovered = true
</span><span style=color:#75715e></span>		<span style=color:#f92672>...</span>

		<span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>pc</span>
		<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sp</span>)

		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> {
			<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>link</span>
			<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>aborted</span> {
				<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>link</span>
			}
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sig</span> = <span style=color:#ae81ff>0</span>
			}
			<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode0</span> = uintptr(<span style=color:#a6e22e>sp</span>)
			<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode1</span> = <span style=color:#a6e22e>pc</span>
			<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>recovery</span>)
			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;recovery failed&#34;</span>)
		}
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>上述这段代码也省略了 <code>defer</code> 的内联优化，它从 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 中取出了程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并调用 <a href=/golang/tree/runtime.recovery><code>runtime.recovery</code></a> 函数触发 Goroutine 的调度，调度之前会准备好 <code>sp</code>、<code>pc</code> 以及函数的返回值：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>recovery</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode0</span>
	<span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode1</span>

	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>sp</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>pc</span> = <span style=color:#a6e22e>pc</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lr</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>ret</span> = <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>gogo</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>)
}
</code></pre></div><p>当我们在调用 <code>defer</code> 关键字时，调用时的栈指针 <code>sp</code> 和程序计数器 <code>pc</code> 就已经存储到了 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体中，这里的 <a href=/golang/tree/runtime.gogo><code>runtime.gogo</code></a> 函数会跳回 <code>defer</code> 关键字调用的位置。</p><p><a href=/golang/tree/runtime.recovery><code>runtime.recovery</code></a> 在调度过程中会将函数的返回值设置成 1。从 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 的注释中我们会发现，当 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 函数的返回值是 1 时，编译器生成的代码会直接跳转到调用方函数返回之前并执行 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferproc</span>(<span style=color:#a6e22e>siz</span> <span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>funcval</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>return0</span>()
}
</code></pre></div><p>跳转到 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 函数之后，程序就已经从 <code>panic</code> 中恢复了并执行正常的逻辑，而 <a href=/golang/tree/runtime.gorecover><code>runtime.gorecover</code></a> 函数也能从 <a href=/golang/tree/runtime._panic><code>runtime._panic</code></a> 结构中取出了调用 <code>panic</code> 时传入的 <code>arg</code> 参数并返回给调用方。</p><h2 id=545-小结>5.4.5 小结
<a class=anchor href=#545-%e5%b0%8f%e7%bb%93>#</a></h2><p>分析程序的崩溃和恢复过程比较棘手，代码不是特别容易理解。我们在本节的最后还是简单总结一下程序崩溃和恢复的过程：</p><ol><li>编译器会负责做转换关键字的工作；<ol><li>将 <code>panic</code> 和 <code>recover</code> 分别转换成 <a href=/golang/tree/runtime.gopanic><code>runtime.gopanic</code></a> 和 <a href=/golang/tree/runtime.gorecover><code>runtime.gorecover</code></a>；</li><li>将 <code>defer</code> 转换成 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 函数；</li><li>在调用 <code>defer</code> 的函数末尾调用 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 函数；</li></ol></li><li>在运行过程中遇到 <a href=/golang/tree/runtime.gopanic><code>runtime.gopanic</code></a> 方法时，会从 Goroutine 的链表依次取出 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体并执行；</li><li>如果调用延迟执行函数时遇到了 <a href=/golang/tree/runtime.gorecover><code>runtime.gorecover</code></a> 就会将 <code>_panic.recovered</code> 标记成 true 并返回 <code>panic</code> 的参数；<ol><li>在这次调用结束之后，<a href=/golang/tree/runtime.gopanic><code>runtime.gopanic</code></a> 会从 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a> 结构体中取出程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并调用 <a href=/golang/tree/runtime.recovery><code>runtime.recovery</code></a> 函数进行恢复程序；</li><li><a href=/golang/tree/runtime.recovery><code>runtime.recovery</code></a> 会根据传入的 <code>pc</code> 和 <code>sp</code> 跳转回 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a>；</li><li>编译器自动生成的代码会发现 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 的返回值不为 0，这时会跳回 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 并恢复到正常的执行流程；</li></ol></li><li>如果没有遇到 <a href=/golang/tree/runtime.gorecover><code>runtime.gorecover</code></a> 就会依次遍历所有的 <a href=/golang/tree/runtime._defer><code>runtime._defer</code></a>，并在最后调用 <a href=/golang/tree/runtime.fatalpanic><code>runtime.fatalpanic</code></a> 中止程序、打印 <code>panic</code> 的参数并返回错误码 2；</li></ol><p>分析的过程涉及了很多语言底层的知识，源代码阅读起来也比较晦涩，其中充斥着反常规的控制流程，通过程序计数器来回跳转，不过对于我们理解程序的执行流程还是很有帮助。</p><h2 id=546-延伸阅读>5.4.6 延伸阅读
<a class=anchor href=#546-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=http://hustcat.github.io/dive-into-stack-defer-panic-recover-in-go/>Dive into stack and defer/panic/recover in go</a></li><li><a href=https://blog.golang.org/defer-panic-and-recover>Defer, Panic, and Recover</a></li></ul><p><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/ class=book-btn>上一节</a>
<a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Dan Scales. Oct 10, 2019. runtime: ensure that Goexit cannot be aborted by a recursive panic/recover <a href=https://github.com/golang/go/commit/7dcd343ed641d3b70c09153d3b041ca3fe83b25e>https://github.com/golang/go/commit/7dcd343ed641d3b70c09153d3b041ca3fe83b25e</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>runtime: panic + recover can cancel a call to Goexit #29226 <a href=https://github.com/golang/go/issues/29226>https://github.com/golang/go/issues/29226</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Dan Scales. Jun 25, 2019. cmd/compile, cmd/link, runtime: make defers low-cost through inline code and extra funcdata <a href=https://github.com/golang/go/commit/be64a19d99918c843f8555aad580221207ea35bc>https://github.com/golang/go/commit/be64a19d99918c843f8555aad580221207ea35bc</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-panic-recover data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-panic-recover",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#54-panic-和-recover>5.4 panic 和 recover</a><ul><li><a href=#541-现象>5.4.1 现象</a><ul><li><a href=#跨协程失效>跨协程失效</a></li><li><a href=#失效的崩溃恢复>失效的崩溃恢复</a></li><li><a href=#嵌套崩溃>嵌套崩溃</a></li></ul></li><li><a href=#542-数据结构>5.4.2 数据结构</a></li><li><a href=#543-程序崩溃>5.4.3 程序崩溃</a></li><li><a href=#544-崩溃恢复>5.4.4 崩溃恢复</a></li><li><a href=#545-小结>5.4.5 小结</a></li><li><a href=#546-延伸阅读>5.4.6 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>