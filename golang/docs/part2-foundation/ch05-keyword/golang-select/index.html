<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="5.2 select #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  select 是操作系统中的系统调用，我们经常会使用 select、poll 和 epoll 等函数构建 I/O 多路复用模型提升程序的性能。Go 语言的 select 与操作系统中的 select 比较相似，本节会介绍 Go 语言 select 关键字常见的现象、数据结构以及实现原理。
C 语言的 select 系统调用可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 select 也能够让 Goroutine 同时等待多个 Channel 可读或者可写，在多个文件或者 Channel状态改变之前，select 会一直阻塞当前线程或者 Goroutine。
图 5-5 Select 和 Channel
select 是与 switch 相似的控制结构，与 switch 不同的是，select 中虽然也有多个 case，但是这些 case 中的表达式必须都是 Channel 的收发操作。下面的代码就展示了一个包含 Channel 收发操作的 select 结构：
func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c <- x: x, y = y, x+y case <-quit: fmt."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言 select 的实现原理"><meta property="og:description" content="5.2 select #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  select 是操作系统中的系统调用，我们经常会使用 select、poll 和 epoll 等函数构建 I/O 多路复用模型提升程序的性能。Go 语言的 select 与操作系统中的 select 比较相似，本节会介绍 Go 语言 select 关键字常见的现象、数据结构以及实现原理。
C 语言的 select 系统调用可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 select 也能够让 Goroutine 同时等待多个 Channel 可读或者可写，在多个文件或者 Channel状态改变之前，select 会一直阻塞当前线程或者 Goroutine。
图 5-5 Select 和 Channel
select 是与 switch 相似的控制结构，与 switch 不同的是，select 中虽然也有多个 case，但是这些 case 中的表达式必须都是 Channel 的收发操作。下面的代码就展示了一个包含 Channel 收发操作的 select 结构：
func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c <- x: x, y = y, x+y case <-quit: fmt."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part2-foundation/ch05-keyword/golang-select/"><title>Go 语言 select 的实现原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言 select 的实现原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#52-select>5.2 select</a><ul><li><a href=#521-现象>5.2.1 现象</a><ul><li><a href=#非阻塞的收发>非阻塞的收发</a></li><li><a href=#随机执行>随机执行</a></li></ul></li><li><a href=#522-数据结构>5.2.2 数据结构</a></li><li><a href=#523-实现原理>5.2.3 实现原理</a><ul><li><a href=#直接阻塞>直接阻塞</a></li><li><a href=#单一管道>单一管道</a></li><li><a href=#非阻塞操作>非阻塞操作</a></li><li><a href=#常见流程>常见流程</a></li></ul></li><li><a href=#524-小结>5.2.4 小结</a></li><li><a href=#525-延伸阅读>5.2.5 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=52-select>5.2 select
<a class=anchor href=#52-select>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p><code>select</code> 是操作系统中的系统调用，我们经常会使用 <code>select</code>、<code>poll</code> 和 <code>epoll</code> 等函数构建 I/O 多路复用模型提升程序的性能。Go 语言的 <code>select</code> 与操作系统中的 <code>select</code> 比较相似，本节会介绍 Go 语言 <code>select</code> 关键字常见的现象、数据结构以及实现原理。</p><p>C 语言的 <code>select</code> 系统调用可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 <code>select</code> 也能够让 Goroutine 同时等待多个 Channel 可读或者可写，在多个文件或者 Channel状态改变之前，<code>select</code> 会一直阻塞当前线程或者 Goroutine。</p><p><img src=https://img.draveness.me/2020-01-19-15794018429532-Golang-Select-Channels.png alt=Golang-Select-Channels></p><p><strong>图 5-5 Select 和 Channel</strong></p><p><code>select</code> 是与 <code>switch</code> 相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式必须都是 Channel 的收发操作。下面的代码就展示了一个包含 Channel 收发操作的 <code>select</code> 结构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fibonacci</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>quit</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>
	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>select</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>x</span>:
			<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> = <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>x</span><span style=color:#f92672>+</span><span style=color:#a6e22e>y</span>
		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>quit</span>:
			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;quit&#34;</span>)
			<span style=color:#66d9ef>return</span>
		}
	}
}
</code></pre></div><p>上述控制结构会等待 <code>c &lt;- x</code> 或者 <code>&lt;-quit</code> 两个表达式中任意一个返回。无论哪一个表达式返回都会立刻执行 <code>case</code> 中的代码，当 <code>select</code> 中的两个 <code>case</code> 同时被触发时，会随机执行其中的一个。</p><h2 id=521-现象>5.2.1 现象
<a class=anchor href=#521-%e7%8e%b0%e8%b1%a1>#</a></h2><p>当我们在 Go 语言中使用 <code>select</code> 控制结构时，会遇到两个有趣的现象：</p><ol><li><code>select</code> 能在 Channel 上进行非阻塞的收发操作；</li><li><code>select</code> 在遇到多个 Channel 同时响应时，会随机执行一种情况；</li></ol><p>这两个现象是学习 <code>select</code> 时经常会遇到的，我们来深入了解具体场景并分析这两个现象背后的设计原理。</p><h3 id=非阻塞的收发>非阻塞的收发
<a class=anchor href=#%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%9a%84%e6%94%b6%e5%8f%91>#</a></h3><p>在通常情况下，<code>select</code> 语句会阻塞当前 Goroutine 并等待多个 Channel 中的一个达到可以收发的状态。但是如果 <code>select</code> 控制结构中包含 <code>default</code> 语句，那么这个 <code>select</code> 语句在执行时会遇到以下两种情况：</p><ol><li>当存在可以收发的 Channel 时，直接处理该 Channel 对应的 <code>case</code>；</li><li>当不存在可以收发的 Channel 时，执行 <code>default</code> 中的语句；</li></ol><p>当我们运行下面的代码时就不会阻塞当前的 Goroutine，它会直接执行 <code>default</code> 中的代码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#66d9ef>select</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>:
		println(<span style=color:#a6e22e>i</span>)

	<span style=color:#66d9ef>default</span>:
		println(<span style=color:#e6db74>&#34;default&#34;</span>)
	}
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#66d9ef>default</span>
</code></pre></div><p>只要我们稍微想一下，就会发现 Go 语言设计的这个现象很合理。<code>select</code> 的作用是同时监听多个 <code>case</code> 是否可以执行，如果多个 Channel 都不能执行，那么运行 <code>default</code> 也是理所当然的。</p><p>非阻塞的 Channel 发送和接收操作还是很有必要的，在很多场景下我们不希望 Channel 操作阻塞当前 Goroutine，只是想看看 Channel 的可读或者可写状态，如下所示：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>errCh</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>error</span>, len(<span style=color:#a6e22e>tasks</span>))
<span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(len(<span style=color:#a6e22e>tasks</span>))
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tasks</span> {
    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tasks</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Run</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>errCh</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>err</span>
        }
    }()
}
<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()

<span style=color:#66d9ef>select</span> {
<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>errCh</span>:
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
<span style=color:#66d9ef>default</span>:
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>在上面这段代码中，我们不关心到底多少个任务执行失败了，只关心是否存在返回错误的任务，最后的 <code>select</code> 语句能很好地完成这个任务。然而使用 <code>select</code> 实现非阻塞收发不是最初的设计，Go 语言在最初版本使用 <code>x, ok := &lt;-c</code> 实现非阻塞的收发，以下是与非阻塞收发相关的提交：</p><ol><li><a href=https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546>select default</a> 提交支持了 <code>select</code> 语句中的 <code>default</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>；</li><li><a href=https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16>gc: special case code for single-op blocking and non-blocking selects</a> 提交引入了基于 <code>select</code> 的非阻塞收发<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</li><li><a href=https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059>gc: remove non-blocking send, receive syntax</a> 提交将 <code>x, ok := &lt;-c</code> 语法删除<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>；</li><li><a href=https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c>gc, runtime: replace closed(c) with x, ok := &lt;-c</a> 提交使用 <code>x, ok := &lt;-c</code> 语法替代 <code>closed(c)</code> 语法判断 Channel 的关闭状态<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>；</li></ol><p>我们可以从上面的几个提交中看到非阻塞收发从最初版本到现在的演变。</p><h3 id=随机执行>随机执行
<a class=anchor href=#%e9%9a%8f%e6%9c%ba%e6%89%a7%e8%a1%8c>#</a></h3><p>另一个使用 <code>select</code> 遇到的情况是同时有多个 <code>case</code> 就绪时，<code>select</code> 会选择哪个 <code>case</code> 执行的问题，我们通过下面的代码可以简单了解一下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#66d9ef>for</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Tick</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>) {
			<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>0</span>
		}
	}()

	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>select</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>:
			println(<span style=color:#e6db74>&#34;case1&#34;</span>)
		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>:
			println(<span style=color:#e6db74>&#34;case2&#34;</span>)
		}
	}
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>case1</span>
<span style=color:#a6e22e>case2</span>
<span style=color:#a6e22e>case1</span>
<span style=color:#f92672>...</span>
</code></pre></div><p>从上述代码输出的结果中我们可以看到，<code>select</code> 在遇到多个 <code>&lt;-ch</code> 同时满足可读或者可写条件时会随机选择一个 <code>case</code> 执行其中的代码。</p><p>这个设计是在十多年前被 <a href=https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d>select</a> 提交<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>引入并一直保留到现在的，虽然中间经历过一些修改<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>，但是语义一直都没有改变。在上面的代码中，两个 <code>case</code> 都是同时满足执行条件的，如果我们按照顺序依次判断，那么后面的条件永远都会得不到执行，而随机的引入就是为了避免饥饿问题的发生。</p><h2 id=522-数据结构>5.2.2 数据结构
<a class=anchor href=#522-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p><code>select</code> 在 Go 语言的源代码中不存在对应的结构体，但是我们使用 <a href=/golang/tree/runtime.scase><code>runtime.scase</code></a> 结构体表示 <code>select</code> 控制结构中的 <code>case</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>scase</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>c</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>         <span style=color:#75715e>// chan
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// data element
</span><span style=color:#75715e></span>}
</code></pre></div><p>因为非默认的 <code>case</code> 中都与 Channel 的发送和接收有关，所以 <a href=/golang/tree/runtime.scase><code>runtime.scase</code></a> 结构体中也包含一个 <a href=/golang/tree/runtime.hchan><code>runtime.hchan</code></a> 类型的字段存储 <code>case</code> 中使用的 Channel。</p><h2 id=523-实现原理>5.2.3 实现原理
<a class=anchor href=#523-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86>#</a></h2><p><code>select</code> 语句在编译期间会被转换成 <code>OSELECT</code> 节点。每个 <code>OSELECT</code> 节点都会持有一组 <code>OCASE</code> 节点，如果 <code>OCASE</code> 的执行条件是空，那就意味着这是一个 <code>default</code> 节点。</p><p><img src=https://img.draveness.me/2020-01-18-15793463657473-golang-oselect-and-ocases.png alt=golang-oselect-and-ocases></p><p><strong>图 5-7 OSELECT 和多个 OCASE</strong></p><p>上图展示的就是 <code>select</code> 语句在编译期间的结构，每一个 <code>OCASE</code> 既包含执行条件也包含满足条件后执行的代码。</p><p>编译器在中间代码生成期间会根据 <code>select</code> 中 <code>case</code> 的不同对控制语句进行优化，这一过程都发生在 <a href=/golang/tree/cmd/compile/internal/gc.walkselectcases><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数中，我们在这里会分四种情况介绍处理的过程和结果：</p><ol><li><code>select</code> 不存在任何的 <code>case</code>；</li><li><code>select</code> 只存在一个 <code>case</code>；</li><li><code>select</code> 存在两个 <code>case</code>，其中一个 <code>case</code> 是 <code>default</code>；</li><li><code>select</code> 存在多个 <code>case</code>；</li></ol><p>上述四种情况不仅会涉及编译器的重写和优化，还会涉及 Go 语言的运行时机制，我们会从编译期间和运行时两个角度分析上述情况。</p><h3 id=直接阻塞>直接阻塞
<a class=anchor href=#%e7%9b%b4%e6%8e%a5%e9%98%bb%e5%a1%9e>#</a></h3><p>首先介绍的是最简单的情况，也就是当 <code>select</code> 结构中不包含任何 <code>case</code>。我们截取 <a href=/golang/tree/cmd/compile/internal/gc.walkselectcases><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数的前几行代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkselectcases</span>(<span style=color:#a6e22e>cases</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cases</span>.<span style=color:#a6e22e>Len</span>()

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>mkcall</span>(<span style=color:#e6db74>&#34;block&#34;</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>)}
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>这段代码很简单并且容易理解，它直接将类似 <code>select {}</code> 的语句转换成调用 <a href=/golang/tree/runtime.block><code>runtime.block</code></a> 函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>block</span>() {
	<span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonSelectNoCases</span>, <span style=color:#a6e22e>traceEvGoStop</span>, <span style=color:#ae81ff>1</span>)
}
</code></pre></div><p><a href=/golang/tree/runtime.block><code>runtime.block</code></a> 的实现非常简单，它会调用 <a href=/golang/tree/runtime.gopark><code>runtime.gopark</code></a> 让出当前 Goroutine 对处理器的使用权并传入等待原因 <code>waitReasonSelectNoCases</code>。</p><p>简单总结一下，空的 <code>select</code> 语句会直接阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p><h3 id=单一管道>单一管道
<a class=anchor href=#%e5%8d%95%e4%b8%80%e7%ae%a1%e9%81%93>#</a></h3><p>如果当前的 <code>select</code> 条件只包含一个 <code>case</code>，那么编译器会将 <code>select</code> 改写成 <code>if</code> 条件语句。下面对比了改写前后的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 改写前
</span><span style=color:#75715e></span><span style=color:#66d9ef>select</span> {
<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>: <span style=color:#75715e>// case ch &lt;- v
</span><span style=color:#75715e></span>    <span style=color:#f92672>...</span>    
}

<span style=color:#75715e>// 改写后
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ch</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#a6e22e>block</span>()
}
<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span> <span style=color:#75715e>// case ch &lt;- v
</span><span style=color:#75715e></span><span style=color:#f92672>...</span>
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/gc.walkselectcases><code>cmd/compile/internal/gc.walkselectcases</code></a> 在处理单操作 <code>select</code> 语句时，会根据 Channel 的收发情况生成不同的语句。当 <code>case</code> 中的 Channel 是空指针时，会直接挂起当前 Goroutine 并陷入永久休眠。</p><h3 id=非阻塞操作>非阻塞操作
<a class=anchor href=#%e9%9d%9e%e9%98%bb%e5%a1%9e%e6%93%8d%e4%bd%9c>#</a></h3><p>当 <code>select</code> 中仅包含两个 <code>case</code>，并且其中一个是 <code>default</code> 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。<a href=/golang/tree/cmd/compile/internal/gc.walkselectcases><code>cmd/compile/internal/gc.walkselectcases</code></a> 会对这种情况单独处理。不过在正式优化之前，该函数会将 <code>case</code> 中的所有 Channel 都转换成指向 Channel 的地址，我们会分别介绍非阻塞发送和非阻塞接收时，编译器进行的不同优化。</p><h4 id=发送>发送
<a class=anchor href=#%e5%8f%91%e9%80%81>#</a></h4><p>首先是 Channel 的发送过程，当 <code>case</code> 中表达式的类型是 <code>OSEND</code> 时，编译器会使用条件语句和 <a href=/golang/tree/runtime.selectnbsend><code>runtime.selectnbsend</code></a> 函数改写代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>select</span> {
<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>:
    <span style=color:#f92672>...</span>
<span style=color:#66d9ef>default</span>:
    <span style=color:#f92672>...</span>
}

<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>selectnbsend</span>(<span style=color:#a6e22e>ch</span>, <span style=color:#a6e22e>i</span>) {
    <span style=color:#f92672>...</span>
} <span style=color:#66d9ef>else</span> {
    <span style=color:#f92672>...</span>
}
</code></pre></div><p>这段代码中最重要的就是 <a href=/golang/tree/runtime.selectnbsend><code>runtime.selectnbsend</code></a>，它为我们提供了向 Channel 非阻塞地发送数据的能力。我们在 Channel 一节介绍了向 Channel 发送数据的 <a href=/golang/tree/runtime.chansend><code>runtime.chansend</code></a> 函数包含一个 <code>block</code> 参数，该参数会决定这一次的发送是不是阻塞的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>selectnbsend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) (<span style=color:#a6e22e>selected</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>getcallerpc</span>())
}
</code></pre></div><p>由于我们向 <a href=/golang/tree/runtime.chansend><code>runtime.chansend</code></a> 函数传入了非阻塞，所以在不存在接收方或者缓冲区空间不足时，当前 Goroutine 都不会阻塞而是会直接返回。</p><h4 id=接收>接收
<a class=anchor href=#%e6%8e%a5%e6%94%b6>#</a></h4><p>由于从 Channel 中接收数据可能会返回一个或者两个值，所以接收数据的情况会比发送稍显复杂，不过改写的套路是差不多的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 改写前
</span><span style=color:#75715e></span><span style=color:#66d9ef>select</span> {
<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>ch</span>: <span style=color:#75715e>// case v, ok &lt;- ch:
</span><span style=color:#75715e></span>    <span style=color:#f92672>......</span>
<span style=color:#66d9ef>default</span>:
    <span style=color:#f92672>......</span>
}

<span style=color:#75715e>// 改写后
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>selectnbrecv</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ch</span>) { <span style=color:#75715e>// if selectnbrecv2(&amp;v, &amp;ok, ch) {
</span><span style=color:#75715e></span>    <span style=color:#f92672>...</span>
} <span style=color:#66d9ef>else</span> {
    <span style=color:#f92672>...</span>
}
</code></pre></div><p>返回值数量不同会导致使用函数的不同，两个用于非阻塞接收消息的函数 <a href=/golang/tree/runtime.selectnbrecv><code>runtime.selectnbrecv</code></a> 和 <a href=/golang/tree/runtime.selectnbrecv2><code>runtime.selectnbrecv2</code></a> 只是对 <a href=/golang/tree/runtime.chanrecv><code>runtime.chanrecv</code></a> 返回值的处理稍有不同：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>selectnbrecv</span>(<span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>) (<span style=color:#a6e22e>selected</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#a6e22e>selected</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>false</span>)
	<span style=color:#66d9ef>return</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>selectnbrecv2</span>(<span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>received</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>) (<span style=color:#a6e22e>selected</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#a6e22e>selected</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>received</span> = <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>false</span>)
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>因为接收方不需要，所以 <a href=/golang/tree/runtime.selectnbrecv><code>runtime.selectnbrecv</code></a> 会直接忽略返回的布尔值，而 <a href=/golang/tree/runtime.selectnbrecv2><code>runtime.selectnbrecv2</code></a> 会将布尔值回传给调用方。与 <a href=/golang/tree/runtime.chansend><code>runtime.chansend</code></a> 一样，<a href=/golang/tree/runtime.chanrecv><code>runtime.chanrecv</code></a> 也提供了一个 <code>block</code> 参数用于控制这次接收是否阻塞。</p><h3 id=常见流程>常见流程
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e6%b5%81%e7%a8%8b>#</a></h3><p>在默认的情况下，编译器会使用如下的流程处理 <code>select</code> 语句：</p><ol><li>将所有的 <code>case</code> 转换成包含 Channel 以及类型等信息的 <a href=/golang/tree/runtime.scase><code>runtime.scase</code></a> 结构体；</li><li>调用运行时函数 <a href=/golang/tree/runtime.selectgo><code>runtime.selectgo</code></a> 从多个准备就绪的 Channel 中选择一个可执行的 <a href=/golang/tree/runtime.scase><code>runtime.scase</code></a> 结构体；</li><li>通过 <code>for</code> 循环生成一组 <code>if</code> 语句，在语句中判断自己是不是被选中的 <code>case</code>；</li></ol><p>一个包含三个 <code>case</code> 的正常 <code>select</code> 语句其实会被展开成如下所示的逻辑，我们可以看到其中处理的三个部分：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>selv</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>3</span>]<span style=color:#a6e22e>scase</span>{}
<span style=color:#a6e22e>order</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>6</span>]<span style=color:#66d9ef>uint16</span>
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>cas</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>cases</span> {
    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>scase</span>{}
    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>kind</span> = <span style=color:#f92672>...</span>
    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#f92672>...</span>
    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>c</span> = <span style=color:#f92672>...</span>
}
<span style=color:#a6e22e>chosen</span>, <span style=color:#a6e22e>revcOK</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>selectgo</span>(<span style=color:#a6e22e>selv</span>, <span style=color:#a6e22e>order</span>, <span style=color:#ae81ff>3</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>chosen</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
    <span style=color:#f92672>...</span>
    <span style=color:#66d9ef>break</span>
}
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>chosen</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
    <span style=color:#f92672>...</span>
    <span style=color:#66d9ef>break</span>
}
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>chosen</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> {
    <span style=color:#f92672>...</span>
    <span style=color:#66d9ef>break</span>
}
</code></pre></div><p>展开后的代码片段中最重要的就是用于选择待执行 <code>case</code> 的运行时函数 <a href=/golang/tree/runtime.selectgo><code>runtime.selectgo</code></a>，这也是我们要关注的重点。因为这个函数的实现比较复杂， 所以这里分两部分分析它的执行过程：</p><ol><li>执行一些必要的初始化操作并确定 <code>case</code> 的处理顺序；</li><li>在循环中根据 <code>case</code> 的类型做出不同的处理；</li></ol><h4 id=初始化>初始化
<a class=anchor href=#%e5%88%9d%e5%a7%8b%e5%8c%96>#</a></h4><p><a href=/golang/tree/runtime.selectgo><code>runtime.selectgo</code></a> 函数首先会进行执行必要的初始化操作并决定处理 <code>case</code> 的两个顺序 — 轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>selectgo</span>(<span style=color:#a6e22e>cas0</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>scase</span>, <span style=color:#a6e22e>order0</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint16</span>, <span style=color:#a6e22e>ncases</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>) {
	<span style=color:#a6e22e>cas1</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span>]<span style=color:#a6e22e>scase</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>cas0</span>))
	<span style=color:#a6e22e>order1</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>17</span>]<span style=color:#66d9ef>uint16</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>order0</span>))
	
	<span style=color:#a6e22e>ncases</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nsends</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>nrecvs</span>
	<span style=color:#a6e22e>scases</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cas1</span>[:<span style=color:#a6e22e>ncases</span>:<span style=color:#a6e22e>ncases</span>]
	<span style=color:#a6e22e>pollorder</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>order1</span>[:<span style=color:#a6e22e>ncases</span>:<span style=color:#a6e22e>ncases</span>]
	<span style=color:#a6e22e>lockorder</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>order1</span>[<span style=color:#a6e22e>ncases</span>:][:<span style=color:#a6e22e>ncases</span>:<span style=color:#a6e22e>ncases</span>]

	<span style=color:#a6e22e>norder</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>scases</span> {
		<span style=color:#a6e22e>cas</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>scases</span>[<span style=color:#a6e22e>i</span>]
	}

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>ncases</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fastrandn</span>(uint32(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
		<span style=color:#a6e22e>pollorder</span>[<span style=color:#a6e22e>norder</span>] = <span style=color:#a6e22e>pollorder</span>[<span style=color:#a6e22e>j</span>]
		<span style=color:#a6e22e>pollorder</span>[<span style=color:#a6e22e>j</span>] = uint16(<span style=color:#a6e22e>i</span>)
		<span style=color:#a6e22e>norder</span><span style=color:#f92672>++</span>
	}
	<span style=color:#a6e22e>pollorder</span> = <span style=color:#a6e22e>pollorder</span>[:<span style=color:#a6e22e>norder</span>]
	<span style=color:#a6e22e>lockorder</span> = <span style=color:#a6e22e>lockorder</span>[:<span style=color:#a6e22e>norder</span>]

	<span style=color:#75715e>// 根据 Channel 的地址排序确定加锁顺序
</span><span style=color:#75715e></span>	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>sellock</span>(<span style=color:#a6e22e>scases</span>, <span style=color:#a6e22e>lockorder</span>)
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code> 分别是通过以下的方式确认的：</p><ul><li>轮询顺序：通过 <a href=/golang/tree/runtime.fastrandn><code>runtime.fastrandn</code></a> 函数引入随机性；</li><li>加锁顺序：按照 Channel 的地址排序后确定加锁顺序；</li></ul><p>随机的轮询顺序可以避免 Channel 的饥饿问题，保证公平性；而根据 Channel 的地址顺序确定加锁顺序能够避免死锁的发生。这段代码最后调用的 <a href=/golang/tree/runtime.sellock><code>runtime.sellock</code></a> 会按照之前生成的加锁顺序锁定 <code>select</code> 语句中包含所有的 Channel。</p><h4 id=循环>循环
<a class=anchor href=#%e5%be%aa%e7%8e%af>#</a></h4><p>当我们为 <code>select</code> 语句锁定了所有 Channel 之后就会进入 <a href=/golang/tree/runtime.selectgo><code>runtime.selectgo</code></a> 函数的主循环，它会分三个阶段查找或者等待某个 Channel 准备就绪：</p><ol><li>查找是否已经存在准备就绪的 Channel，即可以执行收发操作；</li><li>将当前 Goroutine 加入 Channel 对应的收发队列上并等待其他 Goroutine 的唤醒；</li><li>当前 Goroutine 被唤醒之后找到满足条件的 Channel 并进行处理；</li></ol><p><a href=/golang/tree/runtime.selectgo><code>runtime.selectgo</code></a> 函数会根据不同情况通过 <code>goto</code> 语句跳转到函数内部的不同标签执行相应的逻辑，其中包括：</p><ul><li><code>bufrecv</code>：可以从缓冲区读取数据；</li><li><code>bufsend</code>：可以向缓冲区写入数据；</li><li><code>recv</code>：可以从休眠的发送方获取数据；</li><li><code>send</code>：可以向休眠的接收方发送数据；</li><li><code>rclose</code>：可以从关闭的 Channel 读取 EOF；</li><li><code>sclose</code>：向关闭的 Channel 发送数据；</li><li><code>retc</code>：结束调用并返回；</li></ul><p>我们先来分析循环执行的第一个阶段，查找已经准备就绪的 Channel。循环会遍历所有的 <code>case</code> 并找到需要被唤起的 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 结构，在这个阶段，我们会根据 <code>case</code> 的四种类型分别处理：</p><ol><li>当 <code>case</code> 不包含 Channel 时；<ul><li>这种 <code>case</code> 会被跳过；</li></ul></li><li>当 <code>case</code> 会从 Channel 中接收数据时；<ul><li>如果当前 Channel 的 <code>sendq</code> 上有等待的 Goroutine，就会跳到 <code>recv</code> 标签并从缓冲区读取数据后将等待 Goroutine 中的数据放入到缓冲区中相同的位置；</li><li>如果当前 Channel 的缓冲区不为空，就会跳到 <code>bufrecv</code> 标签处从缓冲区获取数据；</li><li>如果当前 Channel 已经被关闭，就会跳到 <code>rclose</code> 做一些清除的收尾工作；</li></ul></li><li>当 <code>case</code> 会向 Channel 发送数据时；<ul><li>如果当前 Channel 已经被关，闭就会直接跳到 <code>sclose</code> 标签，触发 <code>panic</code> 尝试中止程序；</li><li>如果当前 Channel 的 <code>recvq</code> 上有等待的 Goroutine，就会跳到 <code>send</code> 标签向 Channel 发送数据；</li><li>如果当前 Channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区；</li></ul></li><li>当 <code>select</code> 语句中包含 <code>default</code> 时；<ul><li>表示前面的所有 <code>case</code> 都没有被执行，这里会解锁所有 Channel 并返回，意味着当前 <code>select</code> 结构中的收发都是非阻塞的；</li></ul></li></ol><p><img src=https://img.draveness.me/2020-01-18-15793463657488-golang-runtime-selectgo.png alt=golang-runtime-selectgo></p><p><strong>图 5-8 运行时 selectgo 函数</strong></p><p>第一阶段的主要职责是查找所有 <code>case</code> 中是否有可以立刻被处理的 Channel。无论是在等待的 Goroutine 上还是缓冲区中，只要存在数据满足条件就会立刻处理，如果不能立刻找到活跃的 Channel 就会进入循环的下一阶段，按照需要将当前 Goroutine 加入到 Channel 的 <code>sendq</code> 或者 <code>recvq</code> 队列中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>selectgo</span>(<span style=color:#a6e22e>cas0</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>scase</span>, <span style=color:#a6e22e>order0</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint16</span>, <span style=color:#a6e22e>ncases</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>gp</span> = <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>nextp</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>casei</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>lockorder</span> {
		<span style=color:#a6e22e>casi</span> = int(<span style=color:#a6e22e>casei</span>)
		<span style=color:#a6e22e>cas</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>scases</span>[<span style=color:#a6e22e>casi</span>]
		<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>cas</span>.<span style=color:#a6e22e>c</span>
		<span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span>
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span>

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>casi</span> &lt; <span style=color:#a6e22e>nsends</span> {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>sg</span>)
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>sg</span>)
		}
	}

	<span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>selparkcommit</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonSelect</span>, <span style=color:#a6e22e>traceEvGoBlockSelect</span>, <span style=color:#ae81ff>1</span>)
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>除了将当前 Goroutine 对应的 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 结构体加入队列之外，这些结构体都会被串成链表附着在 Goroutine 上。在入队之后会调用 <a href=/golang/tree/runtime.gopark><code>runtime.gopark</code></a> 挂起当前 Goroutine 等待调度器的唤醒。</p><p><img src=https://img.draveness.me/2020-01-19-15794018429558-Golang-Select-Waiting.png alt=Golang-Select-Waiting></p><p><strong>图 5-9 Goroutine 上等待收发的 sudog 链表</strong></p><p>等到 <code>select</code> 中的一些 Channel 准备就绪之后，当前 Goroutine 就会被调度器唤醒。这时会继续执行 <a href=/golang/tree/runtime.selectgo><code>runtime.selectgo</code></a> 函数的第三部分，从 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 中读取数据：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>selectgo</span>(<span style=color:#a6e22e>cas0</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>scase</span>, <span style=color:#a6e22e>order0</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint16</span>, <span style=color:#a6e22e>ncases</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>sg</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>)(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span>)
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>

	<span style=color:#a6e22e>casi</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>cas</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>sglist</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>casei</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>lockorder</span> {
		<span style=color:#a6e22e>k</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>scases</span>[<span style=color:#a6e22e>casei</span>]
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>sglist</span> {
			<span style=color:#a6e22e>casi</span> = int(<span style=color:#a6e22e>casei</span>)
			<span style=color:#a6e22e>cas</span> = <span style=color:#a6e22e>k</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>k</span>.<span style=color:#a6e22e>c</span>
			<span style=color:#66d9ef>if</span> int(<span style=color:#a6e22e>casei</span>) &lt; <span style=color:#a6e22e>nsends</span> {
				<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeueSudoG</span>(<span style=color:#a6e22e>sglist</span>)
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeueSudoG</span>(<span style=color:#a6e22e>sglist</span>)
			}
		}
		<span style=color:#a6e22e>sgnext</span> = <span style=color:#a6e22e>sglist</span>.<span style=color:#a6e22e>waitlink</span>
		<span style=color:#a6e22e>sglist</span>.<span style=color:#a6e22e>waitlink</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>sglist</span>)
		<span style=color:#a6e22e>sglist</span> = <span style=color:#a6e22e>sgnext</span>
	}

	<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>cas</span>.<span style=color:#a6e22e>c</span>
	<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retc</span>
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>第三次遍历全部 <code>case</code> 时，我们会先获取当前 Goroutine 接收到的参数 <code>sudog</code> 结构，我们会依次对比所有 <code>case</code> 对应的 <code>sudog</code> 结构找到被唤醒的 <code>case</code>，获取该 <code>case</code> 对应的索引并返回。</p><p>由于当前的 <code>select</code> 结构找到了一个 <code>case</code> 执行，那么剩下 <code>case</code> 中没有被用到的 <code>sudog</code> 就会被忽略并且释放掉。为了不影响 Channel 的正常使用，我们还是需要将这些废弃的 <code>sudog</code> 从 Channel 中出队。</p><p>当我们在循环中发现缓冲区中有元素或者缓冲区未满时就会通过 <code>goto</code> 关键字跳转到 <code>bufrecv</code> 和 <code>bufsend</code> 两个代码段，这两段代码的执行过程都很简单，它们只是向 Channel 中发送数据或者从缓冲区中获取新数据：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>bufrecv</span>:
	<span style=color:#a6e22e>recvOK</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#a6e22e>qp</span> = <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cas</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>cas</span>.<span style=color:#a6e22e>elem</span>, <span style=color:#a6e22e>qp</span>)
	}
	<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> = <span style=color:#ae81ff>0</span>
	}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>--</span>
	<span style=color:#a6e22e>selunlock</span>(<span style=color:#a6e22e>scases</span>, <span style=color:#a6e22e>lockorder</span>)
	<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retc</span>

<span style=color:#a6e22e>bufsend</span>:
	<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>), <span style=color:#a6e22e>cas</span>.<span style=color:#a6e22e>elem</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span><span style=color:#f92672>++</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#ae81ff>0</span>
	}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>selunlock</span>(<span style=color:#a6e22e>scases</span>, <span style=color:#a6e22e>lockorder</span>)
	<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retc</span>
</code></pre></div><p>这里在缓冲区进行的操作和直接调用 <a href=/golang/tree/runtime.chansend><code>runtime.chansend</code></a> 和 <a href=/golang/tree/runtime.chanrecv><code>runtime.chanrecv</code></a> 差不多，上述两个过程在执行结束之后都会直接跳到 <code>retc</code> 字段。</p><p>两个直接收发 Channel 的情况会调用运行时函数 <a href=/golang/tree/runtime.send><code>runtime.send</code></a> 和 <a href=/golang/tree/runtime.recv><code>runtime.recv</code></a>，这两个函数会与处于休眠状态的 Goroutine 打交道：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>recv</span>:
	<span style=color:#a6e22e>recv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>cas</span>.<span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>selunlock</span>(<span style=color:#a6e22e>scases</span>, <span style=color:#a6e22e>lockorder</span>) }, <span style=color:#ae81ff>2</span>)
	<span style=color:#a6e22e>recvOK</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retc</span>

<span style=color:#a6e22e>send</span>:
	<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>cas</span>.<span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>selunlock</span>(<span style=color:#a6e22e>scases</span>, <span style=color:#a6e22e>lockorder</span>) }, <span style=color:#ae81ff>2</span>)
	<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retc</span>
</code></pre></div><p>不过如果向关闭的 Channel 发送数据或者从关闭的 Channel 中接收数据，情况就稍微有一点复杂了：</p><ul><li>从一个关闭 Channel 中接收数据会直接清除 Channel 中的相关内容；</li><li>向一个关闭的 Channel 发送数据就会直接 <code>panic</code> 造成程序崩溃：</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>rclose</span>:
	<span style=color:#a6e22e>selunlock</span>(<span style=color:#a6e22e>scases</span>, <span style=color:#a6e22e>lockorder</span>)
	<span style=color:#a6e22e>recvOK</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cas</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>cas</span>.<span style=color:#a6e22e>elem</span>)
	}
	<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retc</span>

<span style=color:#a6e22e>sclose</span>:
	<span style=color:#a6e22e>selunlock</span>(<span style=color:#a6e22e>scases</span>, <span style=color:#a6e22e>lockorder</span>)
	panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
</code></pre></div><p>总体来看，<code>select</code> 语句中的 Channel 收发操作和直接操作 Channel 没有太多出入，只是由于 <code>select</code> 多出了 <code>default</code> 关键字所以会支持非阻塞的收发。</p><h2 id=524-小结>5.2.4 小结
<a class=anchor href=#524-%e5%b0%8f%e7%bb%93>#</a></h2><p>我们简单总结一下 <code>select</code> 结构的执行过程与实现原理，首先在编译期间，Go 语言会对 <code>select</code> 语句进行优化，它会根据 <code>select</code> 中 <code>case</code> 的不同选择不同的优化路径：</p><ol><li>空的 <code>select</code> 语句会被转换成调用 <a href=/golang/tree/runtime.block><code>runtime.block</code></a> 直接挂起当前 Goroutine；</li><li>如果 <code>select</code> 语句中只包含一个 <code>case</code>，编译器会将其转换成 <code>if ch == nil { block }; n;</code> 表达式；<ul><li>首先判断操作的 Channel 是不是空的；</li><li>然后执行 <code>case</code> 结构中的内容；</li></ul></li><li>如果 <code>select</code> 语句中只包含两个 <code>case</code> 并且其中一个是 <code>default</code>，那么会使用 <a href=/golang/tree/runtime.selectnbrecv><code>runtime.selectnbrecv</code></a> 和 <a href=/golang/tree/runtime.selectnbsend><code>runtime.selectnbsend</code></a> 非阻塞地执行收发操作；</li><li>在默认情况下会通过 <a href=/golang/tree/runtime.selectgo><code>runtime.selectgo</code></a> 获取执行 <code>case</code> 的索引，并通过多个 <code>if</code> 语句执行对应 <code>case</code> 中的代码；</li></ol><p>在编译器已经对 <code>select</code> 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 <a href=/golang/tree/runtime.selectgo><code>runtime.selectgo</code></a> 函数，该函数会按照以下的流程执行：</p><ol><li>随机生成一个遍历的轮询顺序 <code>pollOrder</code> 并根据 Channel 地址生成锁定顺序 <code>lockOrder</code>；</li><li>根据 <code>pollOrder</code> 遍历所有的 <code>case</code> 查看是否有可以立刻处理的 Channel；<ol><li>如果存在，直接获取 <code>case</code> 对应的索引并返回；</li><li>如果不存在，创建 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 <a href=/golang/tree/runtime.gopark><code>runtime.gopark</code></a> 挂起当前 Goroutine 等待调度器的唤醒；</li></ol></li><li>当调度器唤醒当前 Goroutine 时，会再次按照 <code>lockOrder</code> 遍历所有的 <code>case</code>，从中查找需要被处理的 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 对应的索引；</li></ol><p><code>select</code> 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。</p><h2 id=525-延伸阅读>5.2.5 延伸阅读
<a class=anchor href=#525-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=http://man7.org/linux/man-pages/man2/select.2.html>SELECT(2) · Linux</a></li></ul><p><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/ class=book-btn>上一节</a>
<a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Ken Thompson. Nov 6, 2008. select default. <a href=https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546#diff-fb0a5ae9dd70f0a43038d55c0204fdff>https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546#diff-fb0a5ae9dd70f0a43038d55c0204fdff</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Russ Cox. Jan 31, 2011. gc: special case code for single-op blocking and non-blocking selects. <a href=https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16>https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Russ Cox. Feb 1, 2011. gc: remove non-blocking send, receive syntax. <a href=https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059>https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Russ Cox. Mar 12, 2011. gc, runtime: replace closed(c) with x, ok := &lt;-c. <a href=https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c>https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Ken Thompson. Jul 25, 2008. select. <a href=https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d>https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>Gustavo Niemeyer. Aug 15, 2011. runtime: fix pseudo-randomness on some selects. <a href=https://github.com/golang/go/commit/175849295ce632c2ddeca7024f7c783327b5e571>https://github.com/golang/go/commit/175849295ce632c2ddeca7024f7c783327b5e571</a> <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-select data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-select",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#52-select>5.2 select</a><ul><li><a href=#521-现象>5.2.1 现象</a><ul><li><a href=#非阻塞的收发>非阻塞的收发</a></li><li><a href=#随机执行>随机执行</a></li></ul></li><li><a href=#522-数据结构>5.2.2 数据结构</a></li><li><a href=#523-实现原理>5.2.3 实现原理</a><ul><li><a href=#直接阻塞>直接阻塞</a></li><li><a href=#单一管道>单一管道</a></li><li><a href=#非阻塞操作>非阻塞操作</a></li><li><a href=#常见流程>常见流程</a></li></ul></li><li><a href=#524-小结>5.2.4 小结</a></li><li><a href=#525-延伸阅读>5.2.5 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>