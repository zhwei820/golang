<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="8.2 代码生成 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  图灵完备可能是很多工程师经常听说的术语，它的一个重要特性是计算机程序可以生成另一个程序1，本届要介绍的就是 Go 语言的代码生成机制。很多人可能认为生成代码在软件中并不常见，但是实际上它在很多场景中都扮演了重要的角色，Go 语言中的测试就使用了代码生成机制，go test 命令会扫描包中的测试用例并生成程序、编译并执行它们。
8.2.1 设计原理 #  元编程是计算机编程中一个很重要、也很有趣的概念，维基百科上将元编程描述成一种计算机程序可以将代码看待成数据的能力2。
 Metaprogramming is a programming technique in which computer programs have the ability to treat programs as their data.
 如果能够将代码看做数据，那么代码就可以像数据一样在运行时被修改、更新和替换；元编程赋予了编程语言更加强大的表达能力，能够让我们将一些计算过程从运行时挪到编译时、通过编译期间的展开生成代码或者允许程序在运行时改变自身的行为。总而言之，元编程其实是一种使用代码生成代码的方式，无论是编译期间生成代码，还是在运行时改变代码的行为都是生成代码的一种3。
图 8-3 元编程的使用
现代的编程语言大都会为我们提供不同的元编程能力，从总体来看，根据生成代码的时机不同，我们将元编程能力分为两种类型，其中一种是编译期间的元编程，例如：宏和模板；另一种是运行期间的元编程，也就是运行时，它赋予了编程语言在运行期间修改行为的能力，当然也有一些特性既可以在编译期实现，也可以在运行期间实现。
Go 语言作为编译型的编程语言，它提供了比较有限的运行时元编程能力，例如：反射特性，然而由于性能的问题，反射在很多场景下都不被推荐使用。当然除了反射之外，Go 语言还提供了另一种编译期间的代码生成机制 — go generate，它可以在代码编译之前根据源代码生成代码。
8.2.2 代码生成 #  Go 语言的代码生成机制会读取包含预编译指令的注释，然后执行注释中的命令读取包中的文件，它们将文件解析成抽象语法树并根据语法树生成新的 Go 语言代码和文件，生成的代码会在项目的编译期间与其他代码一起编译和运行。
//go:generate command argument... go generate 不会被 go build 等命令自动执行，该命令需要显式的触发，手动执行该命令时会在文件中扫描上述形式的注释并执行后面的执行命令，需要注意的是 go:generate 和前面的 // 之间没有空格，这种不包含空格的注释一般是 Go 语言的编译器指令，而我们在代码中的正常注释都应该保留这个空格4。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言的代码生成机制"><meta property="og:description" content="8.2 代码生成 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  图灵完备可能是很多工程师经常听说的术语，它的一个重要特性是计算机程序可以生成另一个程序1，本届要介绍的就是 Go 语言的代码生成机制。很多人可能认为生成代码在软件中并不常见，但是实际上它在很多场景中都扮演了重要的角色，Go 语言中的测试就使用了代码生成机制，go test 命令会扫描包中的测试用例并生成程序、编译并执行它们。
8.2.1 设计原理 #  元编程是计算机编程中一个很重要、也很有趣的概念，维基百科上将元编程描述成一种计算机程序可以将代码看待成数据的能力2。
 Metaprogramming is a programming technique in which computer programs have the ability to treat programs as their data.
 如果能够将代码看做数据，那么代码就可以像数据一样在运行时被修改、更新和替换；元编程赋予了编程语言更加强大的表达能力，能够让我们将一些计算过程从运行时挪到编译时、通过编译期间的展开生成代码或者允许程序在运行时改变自身的行为。总而言之，元编程其实是一种使用代码生成代码的方式，无论是编译期间生成代码，还是在运行时改变代码的行为都是生成代码的一种3。
图 8-3 元编程的使用
现代的编程语言大都会为我们提供不同的元编程能力，从总体来看，根据生成代码的时机不同，我们将元编程能力分为两种类型，其中一种是编译期间的元编程，例如：宏和模板；另一种是运行期间的元编程，也就是运行时，它赋予了编程语言在运行期间修改行为的能力，当然也有一些特性既可以在编译期实现，也可以在运行期间实现。
Go 语言作为编译型的编程语言，它提供了比较有限的运行时元编程能力，例如：反射特性，然而由于性能的问题，反射在很多场景下都不被推荐使用。当然除了反射之外，Go 语言还提供了另一种编译期间的代码生成机制 — go generate，它可以在代码编译之前根据源代码生成代码。
8.2.2 代码生成 #  Go 语言的代码生成机制会读取包含预编译指令的注释，然后执行注释中的命令读取包中的文件，它们将文件解析成抽象语法树并根据语法树生成新的 Go 语言代码和文件，生成的代码会在项目的编译期间与其他代码一起编译和运行。
//go:generate command argument... go generate 不会被 go build 等命令自动执行，该命令需要显式的触发，手动执行该命令时会在文件中扫描上述形式的注释并执行后面的执行命令，需要注意的是 go:generate 和前面的 // 之间没有空格，这种不包含空格的注释一般是 Go 语言的编译器指令，而我们在代码中的正常注释都应该保留这个空格4。"><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/"><title>Go 语言的代码生成机制 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言的代码生成机制</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#82-代码生成>8.2 代码生成</a><ul><li><a href=#821-设计原理>8.2.1 设计原理</a></li><li><a href=#822-代码生成>8.2.2 代码生成</a><ul><li><a href=#预编译指令>预编译指令</a></li><li><a href=#抽象语法树>抽象语法树</a></li></ul></li><li><a href=#823-小结>8.2.3 小结</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=82-代码生成>8.2 代码生成
<a class=anchor href=#82-%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>图灵完备可能是很多工程师经常听说的术语，它的一个重要特性是计算机程序可以生成另一个程序<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，本届要介绍的就是 Go 语言的代码生成机制。很多人可能认为生成代码在软件中并不常见，但是实际上它在很多场景中都扮演了重要的角色，Go 语言中的测试就使用了代码生成机制，<code>go test</code> 命令会扫描包中的测试用例并生成程序、编译并执行它们。</p><h2 id=821-设计原理>8.2.1 设计原理
<a class=anchor href=#821-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>元编程是计算机编程中一个很重要、也很有趣的概念，维基百科上将元编程描述成一种计算机程序可以将代码看待成数据的能力<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</p><blockquote><p>Metaprogramming is a programming technique in which computer programs have the ability to treat programs as their data.</p></blockquote><p>如果能够将代码看做数据，那么代码就可以像数据一样在运行时被修改、更新和替换；元编程赋予了编程语言更加强大的表达能力，能够让我们将一些计算过程从运行时挪到编译时、通过编译期间的展开生成代码或者允许程序在运行时改变自身的行为。总而言之，元编程其实是一种使用代码生成代码的方式，无论是编译期间生成代码，还是在运行时改变代码的行为都是生成代码的一种<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>。</p><p><img src=https://img.draveness.me/2020-04-18-15872063261745-metaprogramming-usage.png alt=metaprogramming-usage></p><p><strong>图 8-3 元编程的使用</strong></p><p>现代的编程语言大都会为我们提供不同的元编程能力，从总体来看，根据生成代码的时机不同，我们将元编程能力分为两种类型，其中一种是编译期间的元编程，例如：宏和模板；另一种是运行期间的元编程，也就是运行时，它赋予了编程语言在运行期间修改行为的能力，当然也有一些特性既可以在编译期实现，也可以在运行期间实现。</p><p>Go 语言作为编译型的编程语言，它提供了比较有限的运行时元编程能力，例如：反射特性，然而由于性能的问题，反射在很多场景下都不被推荐使用。当然除了反射之外，Go 语言还提供了另一种编译期间的代码生成机制 — <code>go generate</code>，它可以在代码编译之前根据源代码生成代码。</p><h2 id=822-代码生成>8.2.2 代码生成
<a class=anchor href=#822-%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90>#</a></h2><p>Go 语言的代码生成机制会读取包含预编译指令的注释，然后执行注释中的命令读取包中的文件，它们将文件解析成抽象语法树并根据语法树生成新的 Go 语言代码和文件，生成的代码会在项目的编译期间与其他代码一起编译和运行。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>//go:generate command argument...
</span></code></pre></div><p><code>go generate</code> 不会被 <code>go build</code> 等命令自动执行，该命令需要显式的触发，手动执行该命令时会在文件中扫描上述形式的注释并执行后面的执行命令，需要注意的是 <code>go:generate</code> 和前面的 <code>//</code> 之间没有空格，这种不包含空格的注释一般是 Go 语言的编译器指令，而我们在代码中的正常注释都应该保留这个空格<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>。</p><p>代码生成最常见的例子就是官方提供的 <code>stringer</code><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>，这个工具可以扫描如下所示的常量定义，然后为当前常量类型 <code>Piller</code> 生成对应的 <code>String()</code> 方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// pill.go
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>painkiller</span>

<span style=color:#75715e>//go:generate stringer -type=Pill
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Pill</span> <span style=color:#66d9ef>int</span>
<span style=color:#66d9ef>const</span> (
	<span style=color:#a6e22e>Placebo</span> <span style=color:#a6e22e>Pill</span> = <span style=color:#66d9ef>iota</span>
	<span style=color:#a6e22e>Aspirin</span>
	<span style=color:#a6e22e>Ibuprofen</span>
	<span style=color:#a6e22e>Paracetamol</span>
	<span style=color:#a6e22e>Acetaminophen</span> = <span style=color:#a6e22e>Paracetamol</span>
)
</code></pre></div><p>当我们在上述文件中加入 <code>//go:generate stringer -type=Pill</code> 注释并调用 <code>go generate</code> 命令时，在同一目录下会出现如下所示的 <code>pill_string.go</code> 文件，该文件中包含两个函数，分别是 <code>_</code> 和 <code>String</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Code generated by &#34;stringer -type=Pill&#34;; DO NOT EDIT.
</span><span style=color:#75715e></span>
<span style=color:#f92672>package</span> <span style=color:#a6e22e>painkiller</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;strconv&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_</span>() {
	<span style=color:#75715e>// An &#34;invalid array index&#34; compiler error signifies that the constant values have changed.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// Re-run the stringer command to generate them again.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> [<span style=color:#ae81ff>1</span>]<span style=color:#66d9ef>struct</span>{}
	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>x</span>[<span style=color:#a6e22e>Placebo</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>]
	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>x</span>[<span style=color:#a6e22e>Aspirin</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>x</span>[<span style=color:#a6e22e>Ibuprofen</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]
	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>x</span>[<span style=color:#a6e22e>Paracetamol</span><span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>]
}

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>_Pill_name</span> = <span style=color:#e6db74>&#34;PlaceboAspirinIbuprofenParacetamol&#34;</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_Pill_index</span> = [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>uint8</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>23</span>, <span style=color:#ae81ff>34</span>}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>i</span> <span style=color:#a6e22e>Pill</span>) <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>Pill</span>(len(<span style=color:#a6e22e>_Pill_index</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Pill(&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatInt</span>(int64(<span style=color:#a6e22e>i</span>), <span style=color:#ae81ff>10</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;)&#34;</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>_Pill_name</span>[<span style=color:#a6e22e>_Pill_index</span>[<span style=color:#a6e22e>i</span>]:<span style=color:#a6e22e>_Pill_index</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]]
}
</code></pre></div><p>这段生成的代码很值得我们学习，它通过编译器的检查提供了非常健壮的 <code>String</code> 方法。我们在这里不展示具体的使用过程，本节将重点分析从执行 <code>go generate</code> 到生成对应 <code>String</code> 方法的整个过程，帮助各位理解代码生成机制的工作原理，代码生成的过程可以分成以下两个部分：</p><ol><li>扫描 Go 语言源文件，查找待执行的 <code>//go:generate</code> 预编译指令；</li><li>执行预编译指令，再次扫描源文件并根据源文件中的代码生成代码；</li></ol><h3 id=预编译指令>预编译指令
<a class=anchor href=#%e9%a2%84%e7%bc%96%e8%af%91%e6%8c%87%e4%bb%a4>#</a></h3><p>当我们在命令行中执行 <code>go generate</code> 命令时，它会调用源代码中的 <a href=/golang/tree/cmd/go/internal/generate.runGenerate><code>cmd/go/internal/generate.runGenerate</code></a> 扫描包中的预编译指令，该函数会遍历命令行传入包中的全部文件并依次调用 <a href=/golang/tree/cmd/go/internal/generate.generate><code>cmd/go/internal/generate.generate</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runGenerate</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>cmd</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Command</span>, <span style=color:#a6e22e>args</span> []<span style=color:#66d9ef>string</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>pkg</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>load</span>.<span style=color:#a6e22e>Packages</span>(<span style=color:#a6e22e>args</span>) {
		<span style=color:#f92672>...</span>
		<span style=color:#a6e22e>pkgName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pkg</span>.<span style=color:#a6e22e>Name</span>
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>file</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>pkg</span>.<span style=color:#a6e22e>InternalGoFiles</span>() {
			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>generate</span>(<span style=color:#a6e22e>pkgName</span>, <span style=color:#a6e22e>file</span>) {
				<span style=color:#66d9ef>break</span>
			}
		}
		<span style=color:#a6e22e>pkgName</span> <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;_test&#34;</span>
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>file</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>pkg</span>.<span style=color:#a6e22e>InternalXGoFiles</span>() {
			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>generate</span>(<span style=color:#a6e22e>pkgName</span>, <span style=color:#a6e22e>file</span>) {
				<span style=color:#66d9ef>break</span>
			}
		}
	}
}
</code></pre></div><p><a href=/golang/tree/cmd/go/internal/generate.generate><code>cmd/go/internal/generate.generate</code></a> 会打开传入的文件并初始化一个用于扫描 <a href=/golang/tree/cmd/go/internal/generate.Generator><code>cmd/go/internal/generate.Generator</code></a> 的结构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>generate</span>(<span style=color:#a6e22e>pkg</span>, <span style=color:#a6e22e>absFile</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#a6e22e>fd</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>absFile</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;generate: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
	}
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fd</span>.<span style=color:#a6e22e>Close</span>()
	<span style=color:#a6e22e>g</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Generator</span>{
		<span style=color:#a6e22e>r</span>:        <span style=color:#a6e22e>fd</span>,
		<span style=color:#a6e22e>path</span>:     <span style=color:#a6e22e>absFile</span>,
		<span style=color:#a6e22e>pkg</span>:      <span style=color:#a6e22e>pkg</span>,
		<span style=color:#a6e22e>commands</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>][]<span style=color:#66d9ef>string</span>),
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>run</span>()
}
</code></pre></div><p>结构体 <a href=/golang/tree/cmd/go/internal/generate.Generator><code>cmd/go/internal/generate.Generator</code></a> 的私有方法 <a href=/golang/tree/cmd/go/internal/generate.Generator.run><code>cmd/go/internal/generate.Generator.run</code></a> 会在对应的文件中扫描指令并执行，该方法的实现原理很简单，我们在这里简单展示一下该方法的简化实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Generator</span>) <span style=color:#a6e22e>run</span>() (<span style=color:#a6e22e>ok</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#a6e22e>input</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>r</span>)
	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span>
		<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>ReadSlice</span>(<span style=color:#e6db74>&#39;\n&#39;</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>EOF</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>isGoGenerate</span>(<span style=color:#a6e22e>buf</span>) {
				<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ErrUnexpectedEOF</span>
			}
			<span style=color:#66d9ef>break</span>
		}

		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>isGoGenerate</span>(<span style=color:#a6e22e>buf</span>) {
			<span style=color:#66d9ef>continue</span>
		}

		<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>setEnv</span>()
		<span style=color:#a6e22e>words</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>split</span>(string(<span style=color:#a6e22e>buf</span>))
		<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>exec</span>(<span style=color:#a6e22e>words</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
</code></pre></div><p>上述代码片段会按行读取被扫描的文件并调用 <a href=/golang/tree/cmd/go/internal/generate.isGoGenerate><code>cmd/go/internal/generate.isGoGenerate</code></a> 判断当前行是否以 <code>//go:generate</code> 注释开头，如果该行确定以 <code>//go:generate</code> 开头，那么会解析注释中的命令和参数并调用 <a href=/golang/tree/cmd/go/internal/generate.Generator.exec><code>cmd/go/internal/generate.Generator.exec</code></a> 运行当前命令。</p><h3 id=抽象语法树>抽象语法树
<a class=anchor href=#%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91>#</a></h3><p><a href="https://pkg.go.dev/golang.org/x/tools/cmd/stringer?tab=doc"><code>stringer</code></a> 充分利用了 Go 语言标准库对编译器各种能力的支持，其中包括用于解析抽象语法树的 <a href=https://github.com/golang/go/tree/master/src/go/ast><code>go/ast</code></a>、用于格式化代码的 <a href=https://github.com/golang/go/tree/master/src/go/format><code>go/fmt</code></a> 等，Go 通过标准库中的这些包对外直接提供了编译器的相关能力，让使用者可以直接在它们上面构建复杂的代码生成机制并实施元编程技术。</p><p>作为二进制文件，<code>stringer</code> 命令的入口就是如下所示的 <a href=/golang/tree/golang/tools/main.main><code>golang/tools/main.main</code></a> 函数，在下面的代码中，我们初始化了一个用于解析源文件和生成代码的 <a href=/golang/tree/golang/tools/main.Generator><code>golang/tools/main.Generator</code></a>，然后开始拼接生成的文件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>types</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>typeNames</span>, <span style=color:#e6db74>&#34;,&#34;</span>)
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>g</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Generator</span>{
		<span style=color:#a6e22e>trimPrefix</span>:  <span style=color:#f92672>*</span><span style=color:#a6e22e>trimprefix</span>,
		<span style=color:#a6e22e>lineComment</span>: <span style=color:#f92672>*</span><span style=color:#a6e22e>linecomment</span>,
	}
	<span style=color:#f92672>...</span>

	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;// Code generated by \&#34;stringer %s\&#34;; DO NOT EDIT.\n&#34;</span>, <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>:], <span style=color:#e6db74>&#34; &#34;</span>))
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n&#34;</span>)
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;package %s&#34;</span>, <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>pkg</span>.<span style=color:#a6e22e>name</span>)
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n&#34;</span>)
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;import \&#34;strconv\&#34;\n&#34;</span>)

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>typeName</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>types</span> {
		<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>generate</span>(<span style=color:#a6e22e>typeName</span>)
	}

	<span style=color:#a6e22e>src</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>format</span>()

	<span style=color:#a6e22e>baseName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s_string.go&#34;</span>, <span style=color:#a6e22e>types</span>[<span style=color:#ae81ff>0</span>])
	<span style=color:#a6e22e>outputName</span> = <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>dir</span>, <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>(<span style=color:#a6e22e>baseName</span>))
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>WriteFile</span>(<span style=color:#a6e22e>outputName</span>, <span style=color:#a6e22e>src</span>, <span style=color:#ae81ff>0644</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;writing output: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
	}
}
</code></pre></div><p>从这段代码中我们能看到最终生成文件的轮廓，最上面的调用的几次 <a href=/golang/tree/golang/tools/main.Generator.Printf><code>golang/tools/main.Generator.Printf</code></a> 会在内存中写入文件头的注释、当前包名以及引入的包等，随后会为待处理的类型依次调用 <a href=/golang/tree/golang/tools/main.Generator.generate><code>golang/tools/main.Generator.generate</code></a>，这里会生成一个签名为 <code>_</code> 的函数，通过编译器保证枚举类型的值不会改变：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Generator</span>) <span style=color:#a6e22e>generate</span>(<span style=color:#a6e22e>typeName</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>values</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>Value</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>file</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>pkg</span>.<span style=color:#a6e22e>files</span> {
		<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>typeName</span> = <span style=color:#a6e22e>typeName</span>
		<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>values</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>file</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>ast</span>.<span style=color:#a6e22e>Inspect</span>(<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>genDecl</span>)
			<span style=color:#a6e22e>values</span> = append(<span style=color:#a6e22e>values</span>, <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>values</span><span style=color:#f92672>...</span>)
		}
	}
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;func _() {\n&#34;</span>)
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\t// An \&#34;invalid array index\&#34; compiler error signifies that the constant values have changed.\n&#34;</span>)
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\t// Re-run the stringer command to generate them again.\n&#34;</span>)
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\tvar x [1]struct{}\n&#34;</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>values</span> {
		<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\t_ = x[%s - %s]\n&#34;</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>originalName</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>str</span>)
	}
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;}\n&#34;</span>)
	<span style=color:#a6e22e>runs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>splitIntoRuns</span>(<span style=color:#a6e22e>values</span>)
	<span style=color:#66d9ef>switch</span> {
	<span style=color:#66d9ef>case</span> len(<span style=color:#a6e22e>runs</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
		<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>buildOneRun</span>(<span style=color:#a6e22e>runs</span>, <span style=color:#a6e22e>typeName</span>)
	<span style=color:#f92672>...</span>
	}
}
</code></pre></div><p>随后调用的 <a href=/golang/tree/golang/tools/main.Generator.buildOneRun><code>golang/tools/main.Generator.buildOneRun</code></a> 会生成两个常量的声明语句并为类型定义 <code>String</code> 方法，其中引用的 <code>stringOneRun</code> 常量是方法的模板，与 Web 服务的前端 HTML 模板比较相似：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Generator</span>) <span style=color:#a6e22e>buildOneRun</span>(<span style=color:#a6e22e>runs</span> [][]<span style=color:#a6e22e>Value</span>, <span style=color:#a6e22e>typeName</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>values</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runs</span>[<span style=color:#ae81ff>0</span>]
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n&#34;</span>)
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>declareIndexAndNameVar</span>(<span style=color:#a6e22e>values</span>, <span style=color:#a6e22e>typeName</span>)
	<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#a6e22e>stringOneRun</span>, <span style=color:#a6e22e>typeName</span>, <span style=color:#a6e22e>usize</span>(len(<span style=color:#a6e22e>values</span>)), <span style=color:#e6db74>&#34;&#34;</span>)
}

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>stringOneRun</span> = <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>i</span> <span style=color:#f92672>%</span>[<span style=color:#ae81ff>1</span>]<span style=color:#a6e22e>s</span>) <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#f92672>%</span>[<span style=color:#ae81ff>3</span>]<span style=color:#a6e22e>si</span> <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>%</span>[<span style=color:#ae81ff>1</span>]<span style=color:#a6e22e>s</span>(len(<span style=color:#a6e22e>_</span><span style=color:#f92672>%</span>[<span style=color:#ae81ff>1</span>]<span style=color:#a6e22e>s_index</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;%[1]s(&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatInt</span>(int64(<span style=color:#a6e22e>i</span>), <span style=color:#ae81ff>10</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;)&#34;</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>_</span><span style=color:#f92672>%</span>[<span style=color:#ae81ff>1</span>]<span style=color:#a6e22e>s_name</span>[<span style=color:#a6e22e>_</span><span style=color:#f92672>%</span>[<span style=color:#ae81ff>1</span>]<span style=color:#a6e22e>s_index</span>[<span style=color:#a6e22e>i</span>]:<span style=color:#a6e22e>_</span><span style=color:#f92672>%</span>[<span style=color:#ae81ff>1</span>]<span style=color:#a6e22e>s_index</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]]
}
</code></pre></div><p>整个生成代码的过程就是使用编译器提供的库解析源文件并按照已有的模板生成新的代码，这与 Web 服务中利用模板生成 HTML 文件没有太多的区别，只是生成文件的用途稍微有一些不同，</p><h2 id=823-小结>8.2.3 小结
<a class=anchor href=#823-%e5%b0%8f%e7%bb%93>#</a></h2><p>Go 语言的标准库中暴露了编译器的很多能力，其中包含词法分析和语法分析，我们可以直接利用这些现成的解析器编译 Go 语言的源文件并获得抽象语法树，有了识别源文件结构的能力，我们就可以根据源文件对应的抽象语法树自由地生成更多的代码，使用元编程技术来减少代码重复、提高工作效率。</p><p><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/ class=book-btn>上一节</a>
<a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Generating code <a href=https://blog.golang.org/generate>https://blog.golang.org/generate</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Wikipedia: Metaprogramming <a href=https://en.wikipedia.org/wiki/Metaprogramming>https://en.wikipedia.org/wiki/Metaprogramming</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>谈元编程与表达能力 <a href=/metaprogramming/>/metaprogramming/</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>如何写出优雅的 Go 语言代码 <a href=/golang-101/>/golang-101/</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>command stringer <a href="https://pkg.go.dev/golang.org/x/tools/cmd/stringer?tab=doc">https://pkg.go.dev/golang.org/x/tools/cmd/stringer?tab=doc</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-code-gen data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-code-gen",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#82-代码生成>8.2 代码生成</a><ul><li><a href=#821-设计原理>8.2.1 设计原理</a></li><li><a href=#822-代码生成>8.2.2 代码生成</a><ul><li><a href=#预编译指令>预编译指令</a></li><li><a href=#抽象语法树>抽象语法树</a></li></ul></li><li><a href=#823-小结>8.2.3 小结</a></li></ul></li></ul></nav></aside></main></body></html>