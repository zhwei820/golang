<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="8.1 插件系统 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  熟悉 Go 语言的开发者一般都非常了解 Goroutine 和 Channel 的原理，包括如何设计基于 CSP 模型的应用程序，但是 Go 语言的插件系统是很少有人了解的模块，通过插件系统，我们可以在运行时加载动态库实现一些比较有趣的功能。
8.1.1 设计原理 #  Go 语言的插件系统基于 C 语言动态库实现的，所以它也继承了 C 语言动态库的优点和缺点，我们在本节中会对比 Linux 中的静态库和动态库，分析它们各自的特点和优势。
 静态库或者静态链接库是由编译期决定的程序、外部函数和变量构成的，编译器或者链接器会将程序和变量等内容拷贝到目标的应用并生成一个独立的可执行对象文件1； 动态库或者共享对象可以在多个可执行文件之间共享，程序使用的模块会在运行时从共享对象中加载，而不是在编译程序时打包成独立的可执行文件2；  由于特性不同，静态库和动态库的优缺点也比较明显；只依赖静态库并且通过静态链接生成的二进制文件因为包含了全部的依赖，所以能够独立执行，但是编译的结果也比较大；而动态库可以在多个可执行文件之间共享，可以减少内存的占用，其链接的过程往往也都是在装载或者运行期间触发的，所以可以包含一些可以热插拔的模块并降低内存的占用。
图 8-1 静态库与动态库
使用静态链接编译二进制文件在部署上有非常明显的优势，最终的编译产物也可以直接运行在大多数的机器上，静态链接带来的部署优势远比更低的内存占用显得重要，所以很多编程语言包括 Go 都将静态链接作为默认的链接方式。
插件系统 #  在今天，动态链接带来的低内存占用优势虽然已经没有太多作用，但是动态链接的机制却可以为我们提供更多的灵活性，主程序可以在编译后动态加载共享库实现热插拔的插件系统。
图 8-2 插件系统
通过在主程序和共享库直接定义一系列的约定或者接口，我们可以通过以下的代码动态加载其他人编译的 Go 语言共享对象，这样做的好处是主程序和共享库的开发者不需要共享代码，只要双方的约定不变，修改共享库后也不需要重新编译主程序。
type Driver interface { Name() string } func main() { p, err := plugin.Open(&#34;driver.so&#34;) if err !"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言的动态库和插件系统"><meta property="og:description" content="8.1 插件系统 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  熟悉 Go 语言的开发者一般都非常了解 Goroutine 和 Channel 的原理，包括如何设计基于 CSP 模型的应用程序，但是 Go 语言的插件系统是很少有人了解的模块，通过插件系统，我们可以在运行时加载动态库实现一些比较有趣的功能。
8.1.1 设计原理 #  Go 语言的插件系统基于 C 语言动态库实现的，所以它也继承了 C 语言动态库的优点和缺点，我们在本节中会对比 Linux 中的静态库和动态库，分析它们各自的特点和优势。
 静态库或者静态链接库是由编译期决定的程序、外部函数和变量构成的，编译器或者链接器会将程序和变量等内容拷贝到目标的应用并生成一个独立的可执行对象文件1； 动态库或者共享对象可以在多个可执行文件之间共享，程序使用的模块会在运行时从共享对象中加载，而不是在编译程序时打包成独立的可执行文件2；  由于特性不同，静态库和动态库的优缺点也比较明显；只依赖静态库并且通过静态链接生成的二进制文件因为包含了全部的依赖，所以能够独立执行，但是编译的结果也比较大；而动态库可以在多个可执行文件之间共享，可以减少内存的占用，其链接的过程往往也都是在装载或者运行期间触发的，所以可以包含一些可以热插拔的模块并降低内存的占用。
图 8-1 静态库与动态库
使用静态链接编译二进制文件在部署上有非常明显的优势，最终的编译产物也可以直接运行在大多数的机器上，静态链接带来的部署优势远比更低的内存占用显得重要，所以很多编程语言包括 Go 都将静态链接作为默认的链接方式。
插件系统 #  在今天，动态链接带来的低内存占用优势虽然已经没有太多作用，但是动态链接的机制却可以为我们提供更多的灵活性，主程序可以在编译后动态加载共享库实现热插拔的插件系统。
图 8-2 插件系统
通过在主程序和共享库直接定义一系列的约定或者接口，我们可以通过以下的代码动态加载其他人编译的 Go 语言共享对象，这样做的好处是主程序和共享库的开发者不需要共享代码，只要双方的约定不变，修改共享库后也不需要重新编译主程序。
type Driver interface { Name() string } func main() { p, err := plugin.Open(&#34;driver.so&#34;) if err !"><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/"><title>Go 语言的动态库和插件系统 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言的动态库和插件系统</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#81-插件系统>8.1 插件系统</a><ul><li><a href=#811-设计原理>8.1.1 设计原理</a><ul><li><a href=#插件系统>插件系统</a></li><li><a href=#操作系统>操作系统</a></li></ul></li><li><a href=#812-动态库>8.1.2 动态库</a><ul><li><a href=#cgo>CGO</a></li><li><a href=#加载过程>加载过程</a></li><li><a href=#符号查找>符号查找</a></li></ul></li><li><a href=#813-小结>8.1.3 小结</a></li><li><a href=#814-推荐阅读>8.1.4 推荐阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=81-插件系统>8.1 插件系统
<a class=anchor href=#81-%e6%8f%92%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>熟悉 Go 语言的开发者一般都非常了解 Goroutine 和 Channel 的原理，包括如何设计基于 CSP 模型的应用程序，但是 Go 语言的插件系统是很少有人了解的模块，通过插件系统，我们可以在运行时加载动态库实现一些比较有趣的功能。</p><h2 id=811-设计原理>8.1.1 设计原理
<a class=anchor href=#811-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>Go 语言的插件系统基于 C 语言动态库实现的，所以它也继承了 C 语言动态库的优点和缺点，我们在本节中会对比 Linux 中的静态库和动态库，分析它们各自的特点和优势。</p><ul><li>静态库或者静态链接库是由编译期决定的程序、外部函数和变量构成的，编译器或者链接器会将程序和变量等内容拷贝到目标的应用并生成一个独立的可执行对象文件<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>；</li><li>动态库或者共享对象可以在多个可执行文件之间共享，程序使用的模块会在运行时从共享对象中加载，而不是在编译程序时打包成独立的可执行文件<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>；</li></ul><p>由于特性不同，静态库和动态库的优缺点也比较明显；只依赖静态库并且通过静态链接生成的二进制文件因为包含了全部的依赖，所以能够独立执行，但是编译的结果也比较大；而动态库可以在多个可执行文件之间共享，可以减少内存的占用，其链接的过程往往也都是在装载或者运行期间触发的，所以可以包含一些可以热插拔的模块并降低内存的占用。</p><p><img src=https://img.draveness.me/2020-04-03-15859025269113-static-library-dynamic-library.png alt=static-library-dynamic-library></p><p><strong>图 8-1 静态库与动态库</strong></p><p>使用静态链接编译二进制文件在部署上有非常明显的优势，最终的编译产物也可以直接运行在大多数的机器上，静态链接带来的部署优势远比更低的内存占用显得重要，所以很多编程语言包括 Go 都将静态链接作为默认的链接方式。</p><h3 id=插件系统>插件系统
<a class=anchor href=#%e6%8f%92%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h3><p>在今天，动态链接带来的低内存占用优势虽然已经没有太多作用，但是动态链接的机制却可以为我们提供更多的灵活性，主程序可以在编译后动态加载共享库实现热插拔的插件系统。</p><p><img src=https://img.draveness.me/2020-04-03-15859025269151-plugin-system.png alt=plugin-system></p><p><strong>图 8-2 插件系统</strong></p><p>通过在主程序和共享库直接定义一系列的约定或者接口，我们可以通过以下的代码动态加载其他人编译的 Go 语言共享对象，这样做的好处是主程序和共享库的开发者不需要共享代码，只要双方的约定不变，修改共享库后也不需要重新编译主程序。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Driver</span> <span style=color:#66d9ef>interface</span> {
    <span style=color:#a6e22e>Name</span>() <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>plugin</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;driver.so&#34;</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
	   panic(<span style=color:#a6e22e>err</span>)
    }

    <span style=color:#a6e22e>newDriverSymbol</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Lookup</span>(<span style=color:#e6db74>&#34;NewDriver&#34;</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        panic(<span style=color:#a6e22e>err</span>)
    }

    <span style=color:#a6e22e>newDriverFunc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newDriverSymbol</span>.(<span style=color:#66d9ef>func</span>() <span style=color:#a6e22e>Driver</span>)
    <span style=color:#a6e22e>newDriver</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newDriverFunc</span>()
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>newDriver</span>.<span style=color:#a6e22e>Name</span>())
}
</code></pre></div><p>上述代码定义了 <code>Driver</code> 接口并认为共享库中一定包含 <code>func NewDriver() Driver</code> 函数，当我们通过 <a href=/golang/tree/plugin.Open><code>plugin.Open</code></a> 读取包含 Go 语言插件的共享库后，获取文件中的 <code>NewDriver</code> 符号并转换成正确的函数类型，可以通过该函数初始化新的 <code>Driver</code> 并获取它的名字了。</p><h3 id=操作系统>操作系统
<a class=anchor href=#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>#</a></h3><p>不同的操作系统会实现不同的动态链接机制和共享库格式，Linux 中的共享对象会使用 ELF 格式<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>并提供了一组操作动态链接器的接口，在本节的实现中我们会看到以下的几个接口<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>dlopen</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>filename, <span style=color:#66d9ef>int</span> flag);
<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>dlerror</span>(<span style=color:#66d9ef>void</span>);
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>dlsym</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>symbol);
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dlclose</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>handle);
</code></pre></div><p><code>dlopen</code> 会根据传入的文件名加载对应的动态库并返回一个句柄（Handle）；我们可以直接使用 <code>dlsym</code> 函数在该句柄中搜索特定的符号，也就是函数或者变量，它会返回该符号被加载到内存中的地址。因为待查找的符号可能不存在于目标动态库中，所以在每次查找后我们都应该调用 <code>dlerror</code> 查看当前查找的结果。</p><h2 id=812-动态库>8.1.2 动态库
<a class=anchor href=#812-%e5%8a%a8%e6%80%81%e5%ba%93>#</a></h2><p>Go 语言插件系统的全部实现都包含在 <a href=https://pkg.go.dev/plugin><code>plugin</code></a> 中，这个包实现了符号系统的加载和决议。插件是一个带有公开函数和变量的包，我们需要使用下面的命令编译插件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>go build -buildmode<span style=color:#f92672>=</span>plugin ...
</code></pre></div><p>该命令会生成一个共享对象 <code>.so</code> 文件，当该文件被加载到 Go 语言程序时会使用下面的结构体 <a href=/golang/tree/plugin.Plugin><code>plugin.Plugin</code></a> 表示，该结构体中包含文件的路径以及包含的符号等信息：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Plugin</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>pluginpath</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>syms</span>       <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>与插件系统相关的两个核心方法分别是用于加载共享文件的 <a href=/golang/tree/plugin.Open><code>plugin.Open</code></a> 和在插件中查找符号的 <a href=/golang/tree/plugin.Plugin.Lookup><code>plugin.Plugin.Lookup</code></a>，本节将详细介绍它们的实现原理。</p><h3 id=cgo>CGO
<a class=anchor href=#cgo>#</a></h3><p>在具体分析 <a href=https://pkg.go.dev/plugin><code>plugin</code></a> 包中几个公有方法之前，我们需要先了解一下包中使用的两个 C 语言函数 <a href=/golang/tree/plugin.pluginOpen><code>plugin.pluginOpen</code></a> 和 <a href=/golang/tree/plugin.pluginLookup><code>plugin.pluginLookup</code></a>；<a href=/golang/tree/plugin.pluginOpen><code>plugin.pluginOpen</code></a> 只是简单包装了一下标准库中的 <code>dlopen</code> 和 <code>dlerror</code> 函数并在加载成功后返回指向动态库的句柄：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> uintptr_t <span style=color:#a6e22e>pluginOpen</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> path, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> err) {
	<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> h <span style=color:#f92672>=</span> dlopen(path, RTLD_NOW<span style=color:#f92672>|</span>RTLD_GLOBAL);
	<span style=color:#66d9ef>if</span> (h <span style=color:#f92672>==</span> NULL) {
		<span style=color:#f92672>*</span>err <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)dlerror();
	}
	<span style=color:#66d9ef>return</span> (uintptr_t)h;
}
</code></pre></div><p><a href=/golang/tree/plugin.pluginLookup><code>plugin.pluginLookup</code></a> 使用了标准库中的 <code>dlsym</code> 和 <code>dlerror</code> 获取动态库句柄中的特定符号：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>pluginLookup</span>(uintptr_t h, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> err) {
	<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> r <span style=color:#f92672>=</span> dlsym((<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)h, name);
	<span style=color:#66d9ef>if</span> (r <span style=color:#f92672>==</span> NULL) {
		<span style=color:#f92672>*</span>err <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)dlerror();
	}
	<span style=color:#66d9ef>return</span> r;
}
</code></pre></div><p>这两个函数的实现原理都比较简单，它们的作用也只是简单封装标准库中的 C 语言函数，让它们的签名看起来更像是 Go 语言中的函数签名，方便在 Go 语言中调用。</p><h3 id=加载过程>加载过程
<a class=anchor href=#%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b>#</a></h3><p>用于加载共享对象的函数 <a href=/golang/tree/plugin.Open><code>plugin.Open</code></a> 会将共享对象文件的路径作为参数并返回 <a href=/golang/tree/plugin.Plugin><code>plugin.Plugin</code></a> 结构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>path</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Plugin</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>open</span>(<span style=color:#a6e22e>path</span>)
}
</code></pre></div><p>上述函数会调用私有的函数 <a href=/golang/tree/plugin.open><code>plugin.open</code></a> 加载插件，它是插件加载过程的核心函数，我们可以将该函数拆分成以下几个步骤：</p><ol><li>准备 C 语言函数 <a href=/golang/tree/plugin.pluginOpen><code>plugin.pluginOpen</code></a> 的参数；</li><li>通过 cgo 调用 <a href=/golang/tree/plugin.pluginOpen><code>plugin.pluginOpen</code></a> 并初始化加载的模块；</li><li>查找加载模块中的 <code>init</code> 函数并调用该函数；</li><li>通过插件的文件名和符号列表构建 <a href=/golang/tree/plugin.Plugin><code>plugin.Plugin</code></a> 结构；</li></ol><p>首先是使用 cgo 提供的一些结构准备调用 <a href=/golang/tree/plugin.pluginOpen><code>plugin.pluginOpen</code></a> 所需要的参数，下面的代码会将文件名转换成 <code>*C.char</code> 类型的变量，该类型的变量可以作为参数传入 C 函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>open</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Plugin</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>cPath</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>PATH_MAX</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
	<span style=color:#a6e22e>cRelName</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, len(<span style=color:#a6e22e>name</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
	copy(<span style=color:#a6e22e>cRelName</span>, <span style=color:#a6e22e>name</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>realpath</span>(
		(<span style=color:#f92672>*</span><span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>char</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>cRelName</span>[<span style=color:#ae81ff>0</span>])),
		(<span style=color:#f92672>*</span><span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>char</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>cPath</span>[<span style=color:#ae81ff>0</span>]))) <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>`plugin.Open(&#34;`</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>`&#34;): realpath failed`</span>)
	}

	<span style=color:#a6e22e>filepath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>GoString</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>char</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>cPath</span>[<span style=color:#ae81ff>0</span>])))

	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>cErr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>char</span>
	<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>pluginOpen</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>char</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>cPath</span>[<span style=color:#ae81ff>0</span>])), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>cErr</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>`plugin.Open(&#34;`</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>`&#34;): `</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>GoString</span>(<span style=color:#a6e22e>cErr</span>))
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>当我们拿到了指向动态库的句柄之后会调用 <a href=/golang/tree/plugin.lastmoduleinit><code>plugin.lastmoduleinit</code></a>，链接器会将它会链接到运行时的 <a href=/golang/tree/runtime.plugin_lastmoduleinit><code>runtime.plugin_lastmoduleinit</code></a> 函数上，它会解析文件中的符号并返回共享文件的目录和其中包含的全部符号：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>open</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Plugin</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>pluginpath</span>, <span style=color:#a6e22e>syms</span>, <span style=color:#a6e22e>errstr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lastmoduleinit</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>errstr</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
		<span style=color:#a6e22e>plugins</span>[<span style=color:#a6e22e>filepath</span>] = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Plugin</span>{
			<span style=color:#a6e22e>pluginpath</span>: <span style=color:#a6e22e>pluginpath</span>,
			<span style=color:#a6e22e>err</span>:        <span style=color:#a6e22e>errstr</span>,
		}
		<span style=color:#a6e22e>pluginsMu</span>.<span style=color:#a6e22e>Unlock</span>()
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>`plugin.Open(&#34;`</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>`&#34;): `</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>errstr</span>)
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>在该函数的最后，我们会构建一个新的 <a href=/golang/tree/plugin.Plugin><code>plugin.Plugin</code></a> 结构体并遍历 <a href=/golang/tree/plugin.lastmoduleinit><code>plugin.lastmoduleinit</code></a> 返回的全部符号，为每一个符号调用 <a href=/golang/tree/plugin.pluginLookup><code>plugin.pluginLookup</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>open</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Plugin</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Plugin</span>{
		<span style=color:#a6e22e>pluginpath</span>: <span style=color:#a6e22e>pluginpath</span>,
	}
	<span style=color:#a6e22e>plugins</span>[<span style=color:#a6e22e>filepath</span>] = <span style=color:#a6e22e>p</span>
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>updatedSyms</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}{}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>symName</span>, <span style=color:#a6e22e>sym</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>syms</span> {
		<span style=color:#a6e22e>isFunc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>symName</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isFunc</span> {
			delete(<span style=color:#a6e22e>syms</span>, <span style=color:#a6e22e>symName</span>)
			<span style=color:#a6e22e>symName</span> = <span style=color:#a6e22e>symName</span>[<span style=color:#ae81ff>1</span>:]
		}

		<span style=color:#a6e22e>fullName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pluginpath</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>symName</span>
		<span style=color:#a6e22e>cname</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, len(<span style=color:#a6e22e>fullName</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
		copy(<span style=color:#a6e22e>cname</span>, <span style=color:#a6e22e>fullName</span>)

		<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>pluginLookup</span>(<span style=color:#a6e22e>h</span>, (<span style=color:#f92672>*</span><span style=color:#a6e22e>C</span>.<span style=color:#a6e22e>char</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>cname</span>[<span style=color:#ae81ff>0</span>])), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>cErr</span>)
		<span style=color:#a6e22e>valp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span>[<span style=color:#ae81ff>2</span>]<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sym</span>))
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isFunc</span> {
			(<span style=color:#f92672>*</span><span style=color:#a6e22e>valp</span>)[<span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>)
		} <span style=color:#66d9ef>else</span> {
			(<span style=color:#f92672>*</span><span style=color:#a6e22e>valp</span>)[<span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>p</span>
		}
		<span style=color:#a6e22e>updatedSyms</span>[<span style=color:#a6e22e>symName</span>] = <span style=color:#a6e22e>sym</span>
	}
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>syms</span> = <span style=color:#a6e22e>updatedSyms</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>上述函数在最后会返回一个包含符号名到函数或者变量映射的 <a href=/golang/tree/plugin.Plugin><code>plugin.Plugin</code></a> 结构体，调用方可以将该结构体作为句柄查找其中的符号，需要注意的是，我们在这段代码中省略了查找 <code>init</code> 并初始化插件的过程。</p><h3 id=符号查找>符号查找
<a class=anchor href=#%e7%ac%a6%e5%8f%b7%e6%9f%a5%e6%89%be>#</a></h3><p><a href=/golang/tree/plugin.Plugin.Lookup><code>plugin.Plugin.Lookup</code></a> 可以在 <a href=/golang/tree/plugin.Open><code>plugin.Open</code></a> 返回的结构体中查找符号 <a href=/golang/tree/plugin.Symbol><code>plugin.Symbol</code></a>，该符号是 <code>interface{}</code> 类型的一个别名，我们可以将它转换成变量或者函数真实的类型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Plugin</span>) <span style=color:#a6e22e>Lookup</span>(<span style=color:#a6e22e>symName</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Symbol</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lookup</span>(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>symName</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>lookup</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Plugin</span>, <span style=color:#a6e22e>symName</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Symbol</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>syms</span>[<span style=color:#a6e22e>symName</span>]; <span style=color:#a6e22e>s</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>, <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;plugin: symbol &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>symName</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; not found in plugin &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>pluginpath</span>)
}
</code></pre></div><p>上述方法调用的私有函数 <a href=/golang/tree/plugin.lookup><code>plugin.lookup</code></a> 实现比较简单，它直接利用了结构体中的符号表，如果没有找到对应的符号会直接返回错误。</p><h2 id=813-小结>8.1.3 小结
<a class=anchor href=#813-%e5%b0%8f%e7%bb%93>#</a></h2><p>Go 语言的插件系统利用了操作系统的动态库实现模块化的设计，它提供功能虽然比较有趣，但是在实际使用中会遇到比较多的限制，目前的插件系统也仅支持 Linux、Darwin 和 FreeBSD，在 Windows 上是没有办法使用的。因为插件系统的实现基于一些黑魔法，所以跨平台的编译也会遇到一些比较奇葩的问题，作者在使用插件系统时也踩过很多坑，如果对 Go 语言不是特别了解，还是不建议使用该模块的。</p><h2 id=814-推荐阅读>8.1.4 推荐阅读
<a class=anchor href=#814-%e6%8e%a8%e8%8d%90%e9%98%85%e8%af%bb>#</a></h2><ul><li>Static Libraries vs. Dynamic Libraries <a href=https://medium.com/@StueyGK/static-libraries-vs-dynamic-libraries-af78f0b5f1e4>https://medium.com/@StueyGK/static-libraries-vs-dynamic-libraries-af78f0b5f1e4</a></li></ul><p><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/ class=book-btn>上一节</a>
<a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Wikipedia: Static library <a href=https://en.wikipedia.org/wiki/Static_library>https://en.wikipedia.org/wiki/Static_library</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Wikipedia: Library (computing) <a href=https://en.wikipedia.org/wiki/Library_(computing)#Shared_libraries>https://en.wikipedia.org/wiki/Library_(computing)#Shared_libraries</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Wikipedia: Executable and Linkable Format <a href=https://en.wikipedia.org/wiki/Executable_and_Linkable_Format>https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>dlopen(3) - Linux man page <a href=https://linux.die.net/man/3/dlopen>https://linux.die.net/man/3/dlopen</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-plugin data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-plugin",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#81-插件系统>8.1 插件系统</a><ul><li><a href=#811-设计原理>8.1.1 设计原理</a><ul><li><a href=#插件系统>插件系统</a></li><li><a href=#操作系统>操作系统</a></li></ul></li><li><a href=#812-动态库>8.1.2 动态库</a><ul><li><a href=#cgo>CGO</a></li><li><a href=#加载过程>加载过程</a></li><li><a href=#符号查找>符号查找</a></li></ul></li><li><a href=#813-小结>8.1.3 小结</a></li><li><a href=#814-推荐阅读>8.1.4 推荐阅读</a></li></ul></li></ul></nav></aside></main></body></html>