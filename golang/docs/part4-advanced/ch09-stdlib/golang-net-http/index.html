<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="9.2 HTTP #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了互联网的数据传输的核心1。在过去几年的时间里，HTTP/2 和 HTTP/3 也对现有的协议进行了更新，提供更加安全和快速的传输功能。多数的编程语言都会在标准库中实现 HTTP/1.1 和 HTTP/2.0 已满足工程师的日常开发需求，今天要介绍的 Go 语言的网络库也实现了这两个大版本的 HTTP 协议。
9.2.1 设计原理 #  HTTP 协议是应用层协议，在通常情况下我们都会使用 TCP 作为底层的传输层协议传输数据包，但是 HTTP/3 在 UDP 协议上实现了新的传输层协议 QUIC 并使用 QUIC 传输数据，这也意味着 HTTP 既可以跑在 TCP 上，也可以跑在 UDP 上。
图 9-5 HTTP 与传输层协议
Go 语言标准库通过 net/http 包提供 HTTP 的客户端和服务端实现，在分析内部的实现原理之前，我们先来了解一下 HTTP 协议相关的一些设计以及标准库内部的层级结构和模块之间的关系。
请求和响应 #  HTTP 协议中最常见的概念是 HTTP 请求与响应，我们可以将它们理解成客户端和服务端之间传递的消息，客户端向服务端发送 HTTP 请求，服务端收到 HTTP 请求后会做出计算后以 HTTP 响应的形式发送给客户端。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言 HTTP 标准库的实现原理"><meta property="og:description" content="9.2 HTTP #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了互联网的数据传输的核心1。在过去几年的时间里，HTTP/2 和 HTTP/3 也对现有的协议进行了更新，提供更加安全和快速的传输功能。多数的编程语言都会在标准库中实现 HTTP/1.1 和 HTTP/2.0 已满足工程师的日常开发需求，今天要介绍的 Go 语言的网络库也实现了这两个大版本的 HTTP 协议。
9.2.1 设计原理 #  HTTP 协议是应用层协议，在通常情况下我们都会使用 TCP 作为底层的传输层协议传输数据包，但是 HTTP/3 在 UDP 协议上实现了新的传输层协议 QUIC 并使用 QUIC 传输数据，这也意味着 HTTP 既可以跑在 TCP 上，也可以跑在 UDP 上。
图 9-5 HTTP 与传输层协议
Go 语言标准库通过 net/http 包提供 HTTP 的客户端和服务端实现，在分析内部的实现原理之前，我们先来了解一下 HTTP 协议相关的一些设计以及标准库内部的层级结构和模块之间的关系。
请求和响应 #  HTTP 协议中最常见的概念是 HTTP 请求与响应，我们可以将它们理解成客户端和服务端之间传递的消息，客户端向服务端发送 HTTP 请求，服务端收到 HTTP 请求后会做出计算后以 HTTP 响应的形式发送给客户端。"><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/"><title>Go 语言 HTTP 标准库的实现原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言 HTTP 标准库的实现原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#92-http>9.2 HTTP</a><ul><li><a href=#921-设计原理>9.2.1 设计原理</a><ul><li><a href=#请求和响应>请求和响应</a></li><li><a href=#消息边界>消息边界</a></li><li><a href=#层级结构>层级结构</a></li></ul></li><li><a href=#922-客户端>9.2.2 客户端</a><ul><li><a href=#构建请求>构建请求</a></li><li><a href=#开启事务>开启事务</a></li><li><a href=#等待请求>等待请求</a></li></ul></li><li><a href=#923-服务器>9.2.3 服务器</a><ul><li><a href=#注册处理器>注册处理器</a></li><li><a href=#处理请求>处理请求</a></li></ul></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=92-http>9.2 HTTP
<a class=anchor href=#92-http>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>超文本传输协议（Hypertext Transfer Protocol、HTTP 协议）是今天使用最广泛的应用层协议，1989 年由 Tim Berners-Lee 在 CERN 起草的协议已经成为了互联网的数据传输的核心<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。在过去几年的时间里，HTTP/2 和 HTTP/3 也对现有的协议进行了更新，提供更加安全和快速的传输功能。多数的编程语言都会在标准库中实现 HTTP/1.1 和 HTTP/2.0 已满足工程师的日常开发需求，今天要介绍的 Go 语言的网络库也实现了这两个大版本的 HTTP 协议。</p><h2 id=921-设计原理>9.2.1 设计原理
<a class=anchor href=#921-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>HTTP 协议是应用层协议，在通常情况下我们都会使用 TCP 作为底层的传输层协议传输数据包，但是 HTTP/3 在 UDP 协议上实现了新的传输层协议 QUIC 并使用 QUIC 传输数据，这也意味着 HTTP 既可以跑在 TCP 上，也可以跑在 UDP 上。</p><p><img src=https://img.draveness.me/2020-05-18-15897352888395-http-and-transport-layer.png alt=http-and-transport-layer></p><p><strong>图 9-5 HTTP 与传输层协议</strong></p><p>Go 语言标准库通过 <a href=https://golang.org/pkg/net/http/><code>net/http</code></a> 包提供 HTTP 的客户端和服务端实现，在分析内部的实现原理之前，我们先来了解一下 HTTP 协议相关的一些设计以及标准库内部的层级结构和模块之间的关系。</p><h3 id=请求和响应>请求和响应
<a class=anchor href=#%e8%af%b7%e6%b1%82%e5%92%8c%e5%93%8d%e5%ba%94>#</a></h3><p>HTTP 协议中最常见的概念是 HTTP 请求与响应，我们可以将它们理解成客户端和服务端之间传递的消息，客户端向服务端发送 HTTP 请求，服务端收到 HTTP 请求后会做出计算后以 HTTP 响应的形式发送给客户端。</p><p><img src=https://img.draveness.me/2020-05-18-15897352888407-http-request-and-response.png alt=http-request-and-response></p><p><strong>图 9-6 HTTP 请求与响应</strong></p><p>与其他的二进制协议不同，作为文本传输协议，HTTP 协议的协议头都是文本数据，HTTP 请求头的首行会包含请求的方法、路径和协议版本，接下来是多个 HTTP 协议头以及携带的负载。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#a6e22e>GET</span> / <span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span>
User-Agent<span style=color:#f92672>:</span> <span style=color:#ae81ff>Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span>
Host<span style=color:#f92672>:</span> <span style=color:#ae81ff>draveness.me</span>
Accept-Language<span style=color:#f92672>:</span> <span style=color:#ae81ff>en-us</span>
Accept-Encoding<span style=color:#f92672>:</span> <span style=color:#ae81ff>gzip, deflate</span>
Content-Length<span style=color:#f92672>:</span> <span style=color:#ae81ff>&lt;length&gt;</span>
Connection<span style=color:#f92672>:</span> <span style=color:#ae81ff>Keep-Alive</span>

&lt;html&gt;
    ...
&lt;/html&gt;
</code></pre></div><p>HTTP 响应也有着比较类似的结构，其中也包含响应的协议版本、状态码、响应头以及负载，在这里就不展开介绍了。</p><h3 id=消息边界>消息边界
<a class=anchor href=#%e6%b6%88%e6%81%af%e8%be%b9%e7%95%8c>#</a></h3><p>HTTP 协议目前主要还是跑在 TCP 协议上的，TCP 协议是面向连接的、可靠的、基于字节流的传输层通信协议<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标的主机<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>。因为 TCP 协议是基于字节流的，所以基于 TCP 协议的应用层协议都需要自己划分消息的边界。</p><p><img src=https://img.draveness.me/2020-05-18-15897352888414-message-framing.png alt=message-framing></p><p><strong>图 9-7 实现消息边界的方法</strong></p><p>在应用层协议中，最常见的两种解决方案是基于长度或者基于终结符（Delimiter）。HTTP 协议其实同时实现了上述两种方案，在多数情况下 HTTP 协议都会在协议头中加入 <code>Content-Length</code> 表示负载的长度，消息的接收者解析到该协议头之后就可以确定当前 HTTP 请求/响应结束的位置，分离不同的 HTTP 消息，下面就是一个使用 <code>Content-Length</code> 划分消息边界的例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 138
...
Connection: close

&lt;<span style=color:#f92672>html</span>&gt;
  &lt;<span style=color:#f92672>head</span>&gt;
    &lt;<span style=color:#f92672>title</span>&gt;An Example Page&lt;/<span style=color:#f92672>title</span>&gt;
  &lt;/<span style=color:#f92672>head</span>&gt;
  &lt;<span style=color:#f92672>body</span>&gt;
    &lt;<span style=color:#f92672>p</span>&gt;Hello World, this is a very simple HTML document.&lt;/<span style=color:#f92672>p</span>&gt;
  &lt;/<span style=color:#f92672>body</span>&gt;
&lt;/<span style=color:#f92672>html</span>&gt;
</code></pre></div><p>不过 HTTP 协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 <code>Content-Length</code> 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界。</p><h3 id=层级结构>层级结构
<a class=anchor href=#%e5%b1%82%e7%ba%a7%e7%bb%93%e6%9e%84>#</a></h3><p>Go 语言的 <a href=https://golang.org/pkg/net/http/><code>net/http</code></a> 中同时包好了 HTTP 客户端和服务端的实现，为了支持更好的扩展性，它引入了 <a href=/golang/tree/net/http.RoundTripper><code>net/http.RoundTripper</code></a> 和 <a href=/golang/tree/net/http.Handler><code>net/http.Handler</code></a> 两个接口。<a href=/golang/tree/net/http.RoundTripper><code>net/http.RoundTripper</code></a> 是用来表示执行 HTTP 请求的接口，调用方将请求作为参数可以获取请求对应的响应，而 <a href=/golang/tree/net/http.Handler><code>net/http.Handler</code></a> 主要用于 HTTP 服务器响应客户端的请求：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RoundTripper</span> <span style=color:#66d9ef>interface</span> {
    <span style=color:#a6e22e>RoundTrip</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Response</span>, <span style=color:#66d9ef>error</span>)
}
</code></pre></div><p>HTTP 请求的接收方可以实现 <a href=/golang/tree/net/http.Handler><code>net/http.Handler</code></a> 接口，其中实现了处理 HTTP 请求的逻辑，处理的过程中会调用 <a href=/golang/tree/net/http.ResponseWriter><code>net/http.ResponseWriter</code></a> 接口的方法构造 HTTP 响应，它提供的三个接口 <code>Header</code>、<code>Write</code> 和 <code>WriteHeader</code> 分别会获取 HTTP 响应、将数据写入负载以及写入响应头：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Handler</span> <span style=color:#66d9ef>interface</span> {
    <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ResponseWriter</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Header</span>() <span style=color:#a6e22e>Header</span>
	<span style=color:#a6e22e>Write</span>([]<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>error</span>)
	<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>statusCode</span> <span style=color:#66d9ef>int</span>)
}
</code></pre></div><p>客户端和服务端面对的都是双向的 HTTP 请求与响应，客户端构建请求并等待响应，服务端处理请求并返回响应。HTTP 请求和响应在标准库中不止有一种实现，它们都包含了层级结构，标准库中的 <a href=/golang/tree/net/http.RoundTripper><code>net/http.RoundTripper</code></a> 包含如下所示的层级结构：</p><p><img src=https://img.draveness.me/2020-05-18-15897352888419-golang-roundtripper.png alt=golang-roundtripper></p><p><strong>图 9-8 HTTP 标准库的层级结构</strong></p><p>每个 <a href=/golang/tree/net/http.RoundTripper><code>net/http.RoundTripper</code></a> 接口的实现都包含了一种向远程发出请求的过程；标准库中也提供了 <a href=/golang/tree/net/http.Handler><code>net/http.Handler</code></a> 的多种实现为客户端的 HTTP 请求提供不同的服务。</p><h2 id=922-客户端>9.2.2 客户端
<a class=anchor href=#922-%e5%ae%a2%e6%88%b7%e7%ab%af>#</a></h2><p>客户端可以直接通过 <a href=/golang/tree/net/http.Get><code>net/http.Get</code></a> 使用默认的客户端 <a href=/golang/tree/net/http.DefaultClient><code>net/http.DefaultClient</code></a> 发起 HTTP 请求，也可以自己构建新的 <a href=/golang/tree/net/http.Client><code>net/http.Client</code></a> 实现自定义的 HTTP 事务，在多数情况下使用默认的客户端都能满足我们的需求，不过需要注意的是使用默认客户端发出的请求没有超时时间，所以在某些场景下会一直等待下去。除了自定义 HTTP 事务之外，我们还可以实现自定义的 <a href=/golang/tree/net/http.CookieJar><code>net/http.CookieJar</code></a> 接口管理和使用 HTTP 请求中的 Cookie：</p><p><img src=https://img.draveness.me/2020-05-18-15897352888425-http-transaction-and-cookie.png alt=http-transaction-and-cookie></p><p><strong>图 9-9 事务和 Cookie</strong></p><p>事务和 Cookie 是我们在 HTTP 客户端包为我们提供的两个最重要模块，本节将从 HTTP GET 请求开始，按照构建请求、数据传输、获取连接以及等待响应几个模块分析客户端的实现原理。当我们调用 <a href=/golang/tree/net/http.Client.Get><code>net/http.Client.Get</code></a> 发出 HTTP 时，会按照如下的步骤执行：</p><ol><li>调用 <a href=/golang/tree/net/http.NewRequest><code>net/http.NewRequest</code></a> 根据方法名、URL 和请求体构建请求；</li><li>调用 <a href=/golang/tree/net/http.Transport.RoundTrip><code>net/http.Transport.RoundTrip</code></a> 开启 HTTP 事务、获取连接并发送请求；</li><li>在 HTTP 持久连接的 <a href=/golang/tree/net/http.persistConn.readLoop><code>net/http.persistConn.readLoop</code></a> 方法中等待响应；</li></ol><p><img src=https://img.draveness.me/2020-05-18-15897352888431-http-client-transport-conns.png alt=http-client-transport-conns></p><p><strong>图 9-10 客户端的几大结构体</strong></p><p>HTTP 的客户端中包含几个比较重要的结构体，它们分别是 <a href=/golang/tree/net/http.Client><code>net/http.Client</code></a>、<a href=/golang/tree/net/http.Transport><code>net/http.Transport</code></a> 和 <a href=/golang/tree/net/http.persistConn><code>net/http.persistConn</code></a>：</p><ul><li><a href=/golang/tree/net/http.Client><code>net/http.Client</code></a> 是 HTTP 客户端，它的默认值是使用 <a href=/golang/tree/net/http.DefaultTransport><code>net/http.DefaultTransport</code></a> 的 HTTP 客户端；</li><li><a href=/golang/tree/net/http.Transport><code>net/http.Transport</code></a> 是 <a href=/golang/tree/net/http.RoundTripper><code>net/http.RoundTripper</code></a> 接口的实现，它的主要作用就是支持 HTTP/HTTPS 请求和 HTTP 代理；</li><li><a href=/golang/tree/net/http.persistConn><code>net/http.persistConn</code></a> 封装了一个 TCP 的持久连接，是我们与远程交换消息的句柄（Handle）；</li></ul><p>客户端 <a href=/golang/tree/net/http.Client><code>net/http.Client</code></a> 是级别较高的抽象，它提供了 HTTP 的一些细节，包括 Cookies 和重定向；而 <a href=/golang/tree/net/http.Transport><code>net/http.Transport</code></a> 会处理 HTTP/HTTPS 协议的底层实现细节，其中会包含连接重用、构建请求以及发送请求等功能。</p><h3 id=构建请求>构建请求
<a class=anchor href=#%e6%9e%84%e5%bb%ba%e8%af%b7%e6%b1%82>#</a></h3><p><a href=/golang/tree/net/http.Request><code>net/http.Request</code></a> 表示 HTTP 服务接收到的请求或者 HTTP 客户端发出的请求，其中包含 HTTP 请求的方法、URL、协议版本、协议头以及请求体等字段，除了这些字段之外，它还会持有一个指向 HTTP 响应的引用：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Request</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Method</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>URL</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>URL</span>

	<span style=color:#a6e22e>Proto</span>      <span style=color:#66d9ef>string</span> <span style=color:#75715e>// &#34;HTTP/1.0&#34;
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ProtoMajor</span> <span style=color:#66d9ef>int</span>    <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ProtoMinor</span> <span style=color:#66d9ef>int</span>    <span style=color:#75715e>// 0
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>Header</span> <span style=color:#a6e22e>Header</span>
	<span style=color:#a6e22e>Body</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ReadCloser</span>

	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>Response</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Response</span>
}
</code></pre></div><p><a href=/golang/tree/net/http.NewRequest><code>net/http.NewRequest</code></a> 是标准库提供的用于创建请求的方法，这个方法会校验 HTTP 请求的字段并根据输入的参数拼装成新的请求结构体。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewRequestWithContext</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>method</span>, <span style=color:#a6e22e>url</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>body</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>method</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
		<span style=color:#a6e22e>method</span> = <span style=color:#e6db74>&#34;GET&#34;</span>
	}
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>validMethod</span>(<span style=color:#a6e22e>method</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;net/http: invalid method %q&#34;</span>, <span style=color:#a6e22e>method</span>)
	}
	<span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>urlpkg</span>.<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>url</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
	}
	<span style=color:#a6e22e>rc</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>body</span>.(<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ReadCloser</span>)
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>body</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>rc</span> = <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>NopCloser</span>(<span style=color:#a6e22e>body</span>)
	}
	<span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Host</span> = <span style=color:#a6e22e>removeEmptyPort</span>(<span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Host</span>)
	<span style=color:#a6e22e>req</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Request</span>{
		<span style=color:#a6e22e>ctx</span>:        <span style=color:#a6e22e>ctx</span>,
		<span style=color:#a6e22e>Method</span>:     <span style=color:#a6e22e>method</span>,
		<span style=color:#a6e22e>URL</span>:        <span style=color:#a6e22e>u</span>,
		<span style=color:#a6e22e>Proto</span>:      <span style=color:#e6db74>&#34;HTTP/1.1&#34;</span>,
		<span style=color:#a6e22e>ProtoMajor</span>: <span style=color:#ae81ff>1</span>,
		<span style=color:#a6e22e>ProtoMinor</span>: <span style=color:#ae81ff>1</span>,
		<span style=color:#a6e22e>Header</span>:     make(<span style=color:#a6e22e>Header</span>),
		<span style=color:#a6e22e>Body</span>:       <span style=color:#a6e22e>rc</span>,
		<span style=color:#a6e22e>Host</span>:       <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Host</span>,
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>body</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#f92672>...</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>req</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>请求拼装的过程比较简单，它会检查并校验输入的方法、URL 以及负载，然而初始化了新的 <a href=/golang/tree/net/http.Request><code>net/http.Request</code></a> 结构，处理负载的过程稍微有一些复杂，我们会根据负载的类型不同，使用不同的方法将它们包装成 <code>io.ReadCloser</code> 类型。</p><h3 id=开启事务>开启事务
<a class=anchor href=#%e5%bc%80%e5%90%af%e4%ba%8b%e5%8a%a1>#</a></h3><p>当我们使用标准库构建了 HTTP 请求之后，会开启 HTTP 事务发送 HTTP 请求并等待远程的响应，经过下面一连串的调用，我们最终来到了标准库实现底层 HTTP 协议的结构体 — <a href=/golang/tree/net/http.Transport><code>net/http.Transport</code></a>：</p><ol><li><a href=/golang/tree/net/http.Client.Do><code>net/http.Client.Do</code></a></li><li><a href=/golang/tree/net/http.Client.do><code>net/http.Client.do</code></a></li><li><a href=/golang/tree/net/http.Client.send><code>net/http.Client.send</code></a></li><li><a href=/golang/tree/net/http.send><code>net/http.send</code></a></li><li><a href=/golang/tree/net/http.Transport.RoundTrip><code>net/http.Transport.RoundTrip</code></a></li></ol><p><a href=/golang/tree/net/http.Transport><code>net/http.Transport</code></a> 实现了 <a href=/golang/tree/net/http.RoundTripper><code>net/http.RoundTripper</code></a> 接口，也是整个请求过程中最重要并且最复杂的结构体，该结构体会在 <a href=/golang/tree/net/http.Transport.roundTrip><code>net/http.Transport.roundTrip</code></a> 中发送 HTTP 请求并等待响应，我们可以将该函数的执行过程分成两个部分：</p><ul><li>根据 URL 的协议查找并执行自定义的 <a href=/golang/tree/net/http.RoundTripper><code>net/http.RoundTripper</code></a> 实现；</li><li>从连接池中获取或者初始化新的持久连接并调用连接的 <a href=/golang/tree/net/http.persistConn.roundTrip><code>net/http.persistConn.roundTrip</code></a> 发出请求；</li></ul><p>我们可以在标准库的 <a href=/golang/tree/net/http.Transport><code>net/http.Transport</code></a> 中调用 <a href=/golang/tree/net/http.Transport.RegisterProtocol><code>net/http.Transport.RegisterProtocol</code></a> 为不同的协议注册 <a href=/golang/tree/net/http.RoundTripper><code>net/http.RoundTripper</code></a> 的实现，在下面的这段代码中就会根据 URL 中的协议选择对应的实现来替代默认的逻辑：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Transport</span>) <span style=color:#a6e22e>roundTrip</span>(<span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Response</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Context</span>()
	<span style=color:#a6e22e>scheme</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Scheme</span>

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>altRT</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>alternateRoundTripper</span>(<span style=color:#a6e22e>req</span>); <span style=color:#a6e22e>altRT</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>altRT</span>.<span style=color:#a6e22e>RoundTrip</span>(<span style=color:#a6e22e>req</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>ErrSkipAltProtocol</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span>
		}
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>在默认情况下，我们都会使用 <a href=/golang/tree/net/http.persistConn><code>net/http.persistConn</code></a> 持久连接处理 HTTP 请求，该方法会先获取用于发送请求的连接，随后调用 <a href=/golang/tree/net/http.persistConn.roundTrip><code>net/http.persistConn.roundTrip</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Transport</span>) <span style=color:#a6e22e>roundTrip</span>(<span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Response</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>select</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>()
		<span style=color:#66d9ef>default</span>:
		}

		<span style=color:#a6e22e>treq</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>transportRequest</span>{<span style=color:#a6e22e>Request</span>: <span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>trace</span>: <span style=color:#a6e22e>trace</span>}
		<span style=color:#a6e22e>cm</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>connectMethodForRequest</span>(<span style=color:#a6e22e>treq</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
		}

		<span style=color:#a6e22e>pconn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>getConn</span>(<span style=color:#a6e22e>treq</span>, <span style=color:#a6e22e>cm</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
		}

		<span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pconn</span>.<span style=color:#a6e22e>roundTrip</span>(<span style=color:#a6e22e>treq</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resp</span>, <span style=color:#66d9ef>nil</span>
		}
	}
}
</code></pre></div><p><a href=/golang/tree/net/http.Transport.getConn><code>net/http.Transport.getConn</code></a> 是获取连接的方法，该方法会通过两种方法获取用于发送请求的连接：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Transport</span>) <span style=color:#a6e22e>getConn</span>(<span style=color:#a6e22e>treq</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>transportRequest</span>, <span style=color:#a6e22e>cm</span> <span style=color:#a6e22e>connectMethod</span>) (<span style=color:#a6e22e>pc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>persistConn</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>req</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>treq</span>.<span style=color:#a6e22e>Request</span>
	<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Context</span>()

	<span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wantConn</span>{
		<span style=color:#a6e22e>cm</span>:         <span style=color:#a6e22e>cm</span>,
		<span style=color:#a6e22e>key</span>:        <span style=color:#a6e22e>cm</span>.<span style=color:#a6e22e>key</span>(),
		<span style=color:#a6e22e>ctx</span>:        <span style=color:#a6e22e>ctx</span>,
		<span style=color:#a6e22e>ready</span>:      make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}, <span style=color:#ae81ff>1</span>),
	}

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>delivered</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>queueForIdleConn</span>(<span style=color:#a6e22e>w</span>); <span style=color:#a6e22e>delivered</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>pc</span>, <span style=color:#66d9ef>nil</span>
	}

	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>queueForDial</span>(<span style=color:#a6e22e>w</span>)
	<span style=color:#66d9ef>select</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>ready</span>:
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>err</span>
	<span style=color:#f92672>...</span>
	}
}
</code></pre></div><ol><li>调用 <a href=/golang/tree/net/http.Transport.queueForIdleConn><code>net/http.Transport.queueForIdleConn</code></a> 在队列中等待闲置的连接；</li><li>调用 <a href=/golang/tree/net/http.Transport.queueForDial><code>net/http.Transport.queueForDial</code></a> 在队列中等待建立新的连接；</li></ol><p>连接是一种相对比较昂贵的资源，如果在每次发出 HTTP 请求之前都建立新的连接，可能会消耗比较多的时间，带来较大的额外开销，通过连接池对资源进行分配和复用可以有效地提高 HTTP 请求的整体性能，多数的网络库客户端都会采取类似的策略来复用资源。</p><p>当我们调用 <a href=/golang/tree/net/http.Transport.queueForDial><code>net/http.Transport.queueForDial</code></a> 尝试与远程建立连接时，标准库会在内部启动新的 Goroutine 执行 <a href=/golang/tree/net/http.Transport.dialConnFor><code>net/http.Transport.dialConnFor</code></a> 用于建连，从最终调用的 <a href=/golang/tree/net/http.Transport.dialConn><code>net/http.Transport.dialConn</code></a> 中我们能找到 TCP 连接和 <a href=https://golang.org/pkg/net/><code>net</code></a> 库的身影：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Transport</span>) <span style=color:#a6e22e>dialConn</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>cm</span> <span style=color:#a6e22e>connectMethod</span>) (<span style=color:#a6e22e>pconn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>persistConn</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>pconn</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>persistConn</span>{
		<span style=color:#a6e22e>t</span>:             <span style=color:#a6e22e>t</span>,
		<span style=color:#a6e22e>cacheKey</span>:      <span style=color:#a6e22e>cm</span>.<span style=color:#a6e22e>key</span>(),
		<span style=color:#a6e22e>reqch</span>:         make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>requestAndChan</span>, <span style=color:#ae81ff>1</span>),
		<span style=color:#a6e22e>writech</span>:       make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>writeRequest</span>, <span style=color:#ae81ff>1</span>),
		<span style=color:#a6e22e>closech</span>:       make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}),
		<span style=color:#a6e22e>writeErrCh</span>:    make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>error</span>, <span style=color:#ae81ff>1</span>),
		<span style=color:#a6e22e>writeLoopDone</span>: make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}),
	}

	<span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>dial</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#a6e22e>cm</span>.<span style=color:#a6e22e>addr</span>())
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
	}
	<span style=color:#a6e22e>pconn</span>.<span style=color:#a6e22e>conn</span> = <span style=color:#a6e22e>conn</span>

	<span style=color:#a6e22e>pconn</span>.<span style=color:#a6e22e>br</span> = <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewReaderSize</span>(<span style=color:#a6e22e>pconn</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>readBufferSize</span>())
	<span style=color:#a6e22e>pconn</span>.<span style=color:#a6e22e>bw</span> = <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewWriterSize</span>(<span style=color:#a6e22e>persistConnWriter</span>{<span style=color:#a6e22e>pconn</span>}, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>writeBufferSize</span>())

	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>pconn</span>.<span style=color:#a6e22e>readLoop</span>()
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>pconn</span>.<span style=color:#a6e22e>writeLoop</span>()
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pconn</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>在创建新的 TCP 连接后，我们还会在后台为当前的连接创建两个 Goroutine，分别从 TCP 连接中读取数据或者向 TCP 连接写入数据，从建立连接的过程我们可以发现，如果我们为每一个 HTTP 请求都创建新的连接并启动 Goroutine 处理读写数据，会占用很多的资源。</p><h3 id=等待请求>等待请求
<a class=anchor href=#%e7%ad%89%e5%be%85%e8%af%b7%e6%b1%82>#</a></h3><p>持久的 TCP 连接会实现 <a href=/golang/tree/net/http.persistConn.roundTrip><code>net/http.persistConn.roundTrip</code></a> 处理写入 HTTP 请求并在 <code>select</code> 语句中等待响应的返回：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>pc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>persistConn</span>) <span style=color:#a6e22e>roundTrip</span>(<span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>transportRequest</span>) (<span style=color:#a6e22e>resp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Response</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>writeErrCh</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>error</span>, <span style=color:#ae81ff>1</span>)
	<span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>writech</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>writeRequest</span>{<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>writeErrCh</span>, <span style=color:#a6e22e>continueCh</span>}

	<span style=color:#a6e22e>resc</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>responseAndError</span>)
	<span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>reqch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>requestAndChan</span>{
		<span style=color:#a6e22e>req</span>:        <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Request</span>,
		<span style=color:#a6e22e>ch</span>:         <span style=color:#a6e22e>resc</span>,
	}

	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>select</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>re</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>resc</span>:
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>re</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>mapRoundTripError</span>(<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>startBytesWritten</span>, <span style=color:#a6e22e>re</span>.<span style=color:#a6e22e>err</span>)
			}
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>re</span>.<span style=color:#a6e22e>res</span>, <span style=color:#66d9ef>nil</span>
		<span style=color:#f92672>...</span>
		}
	}
}
</code></pre></div><p>每个 HTTP 请求都由另一个 Goroutine 中的 <a href=/golang/tree/net/http.persistConn.writeLoop><code>net/http.persistConn.writeLoop</code></a> 循环写入的，这两个 Goroutine 独立执行并通过 Channel 进行通信。<a href=/golang/tree/net/http.Request.write><code>net/http.Request.write</code></a> 会根据 <a href=/golang/tree/net/http.Request><code>net/http.Request</code></a> 结构中的字段按照 HTTP 协议组成 TCP 数据段：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>pc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>persistConn</span>) <span style=color:#a6e22e>writeLoop</span>() {
	<span style=color:#66d9ef>defer</span> close(<span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>writeLoopDone</span>)
	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>select</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>wr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>writech</span>:
			<span style=color:#a6e22e>startBytesWritten</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>nwrite</span>
			<span style=color:#a6e22e>wr</span>.<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>bw</span>, <span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>isProxy</span>, <span style=color:#a6e22e>wr</span>.<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>extra</span>, <span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>waitForContinue</span>(<span style=color:#a6e22e>wr</span>.<span style=color:#a6e22e>continueCh</span>))
			<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>closech</span>:
			<span style=color:#66d9ef>return</span>
		}
	}
}
</code></pre></div><p>当我们调用 <a href=/golang/tree/net/http.Request.write><code>net/http.Request.write</code></a> 向请求中写入数据时，实际上直接写入了 <a href=/golang/tree/net/http.persistConnWriter><code>net/http.persistConnWriter</code></a> 中的 TCP 连接中，TCP 协议栈会负责将 HTTP 请求中的内容发送到目标服务器上：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>persistConnWriter</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>pc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>persistConn</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>persistConnWriter</span>) <span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>p</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>p</span>)
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>pc</span>.<span style=color:#a6e22e>nwrite</span> <span style=color:#f92672>+=</span> int64(<span style=color:#a6e22e>n</span>)
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>持久连接中的另一个读循环 <a href=/golang/tree/net/http.persistConn.readLoop><code>net/http.persistConn.readLoop</code></a> 会负责从 TCP 连接中读取数据并将数据发送会 HTTP 请求的调用方，真正负责解析 HTTP 协议的还是 <a href=/golang/tree/net/http.ReadResponse><code>net/http.ReadResponse</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ReadResponse</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>Reader</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Response</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>tp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>textproto</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>r</span>)
	<span style=color:#a6e22e>resp</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Response</span>{
		<span style=color:#a6e22e>Request</span>: <span style=color:#a6e22e>req</span>,
	}

	<span style=color:#a6e22e>line</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tp</span>.<span style=color:#a6e22e>ReadLine</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>IndexByte</span>(<span style=color:#a6e22e>line</span>, <span style=color:#e6db74>&#39; &#39;</span>); <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>badStringError</span>(<span style=color:#e6db74>&#34;malformed HTTP response&#34;</span>, <span style=color:#a6e22e>line</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Proto</span> = <span style=color:#a6e22e>line</span>[:<span style=color:#a6e22e>i</span>]
		<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Status</span> = <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>TrimLeft</span>(<span style=color:#a6e22e>line</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:], <span style=color:#e6db74>&#34; &#34;</span>)
	}

	<span style=color:#a6e22e>statusCode</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Status</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>IndexByte</span>(<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Status</span>, <span style=color:#e6db74>&#39; &#39;</span>); <span style=color:#a6e22e>i</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
		<span style=color:#a6e22e>statusCode</span> = <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Status</span>[:<span style=color:#a6e22e>i</span>]
	}
	<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>StatusCode</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Atoi</span>(<span style=color:#a6e22e>statusCode</span>)

	<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>ProtoMajor</span>, <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>ProtoMinor</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>ParseHTTPVersion</span>(<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Proto</span>)

	<span style=color:#a6e22e>mimeHeader</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tp</span>.<span style=color:#a6e22e>ReadMIMEHeader</span>()
	<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Header</span> = <span style=color:#a6e22e>Header</span>(<span style=color:#a6e22e>mimeHeader</span>)

	<span style=color:#a6e22e>readTransfer</span>(<span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>r</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resp</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>我们在上述方法中可以看到 HTTP 响应结构的大致框架，其中包含状态码、协议版本、请求头等内容，响应体还是在读取循环 <a href=/golang/tree/net/http.persistConn.readLoop><code>net/http.persistConn.readLoop</code></a> 中根据 HTTP 协议头进行解析的。</p><h2 id=923-服务器>9.2.3 服务器
<a class=anchor href=#923-%e6%9c%8d%e5%8a%a1%e5%99%a8>#</a></h2><p>Go 语言标准库 <a href=https://golang.org/pkg/net/http/><code>net/http</code></a> 包提供了非常易用的接口，如下所示，我们可以利用标准库提供的功能快速搭建新的 HTTP 服务：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handler</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Hi there, I love %s!&#34;</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>[<span style=color:#ae81ff>1</span>:])
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>handler</span>)
    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>))
}
</code></pre></div><p>上述的 <code>main</code> 函数只调用了两个标准库提供的函数，它们分别是用于注册处理器的 <a href=/golang/tree/net/http.HandleFunc><code>net/http.HandleFunc</code></a> 函数和用于监听和处理器请求的 <a href=/golang/tree/net/http.ListenAndServe><code>net/http.ListenAndServe</code></a>，多数的服务器框架都会包含这两类接口，分别负责注册处理器和处理外部请求，这一种非常常见的模式，我们在这里也会按照这两个维度介绍标准库如何支持 HTTP 服务器的实现。</p><h3 id=注册处理器>注册处理器
<a class=anchor href=#%e6%b3%a8%e5%86%8c%e5%a4%84%e7%90%86%e5%99%a8>#</a></h3><p>HTTP 服务是由一组实现了 <a href=/golang/tree/net/http.Handler><code>net/http.Handler</code></a> 接口的处理器组成的，处理 HTTP 请求时会根据请求的路由选择合适的处理器：</p><p><img src=https://img.draveness.me/2020-05-18-15897352888438-http-server-and-handlers.png alt=http-server-and-handlers></p><p><strong>图 9-11 HTTP 服务与处理器</strong></p><p>当我们直接调用 <a href=/golang/tree/net/http.HandleFunc><code>net/http.HandleFunc</code></a> 注册处理器时，标准库会使用默认的 HTTP 服务器 <a href=/golang/tree/net/http.DefaultServeMux><code>net/http.DefaultServeMux</code></a> 处理请求，该方法会直接调用 <a href=/golang/tree/net/http.ServeMux.HandleFunc><code>net/http.ServeMux.HandleFunc</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>mux</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ServeMux</span>) <span style=color:#a6e22e>HandleFunc</span>(<span style=color:#a6e22e>pattern</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>handler</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>)) {
	<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#a6e22e>pattern</span>, <span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>handler</span>))
}
</code></pre></div><p>上述方法会将处理器转换成 <a href=/golang/tree/net/http.Handler><code>net/http.Handler</code></a> 接口类型调用 <a href=/golang/tree/net/http.ServeMux.Handle><code>net/http.ServeMux.Handle</code></a> 注册处理器：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>mux</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ServeMux</span>) <span style=color:#a6e22e>Handle</span>(<span style=color:#a6e22e>pattern</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>handler</span> <span style=color:#a6e22e>Handler</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>exist</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>pattern</span>]; <span style=color:#a6e22e>exist</span> {
		panic(<span style=color:#e6db74>&#34;http: multiple registrations for &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>pattern</span>)
	}

	<span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>muxEntry</span>{<span style=color:#a6e22e>h</span>: <span style=color:#a6e22e>handler</span>, <span style=color:#a6e22e>pattern</span>: <span style=color:#a6e22e>pattern</span>}
	<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>pattern</span>] = <span style=color:#a6e22e>e</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pattern</span>[len(<span style=color:#a6e22e>pattern</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;/&#39;</span> {
		<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>es</span> = <span style=color:#a6e22e>appendSorted</span>(<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>es</span>, <span style=color:#a6e22e>e</span>)
	}

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pattern</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;/&#39;</span> {
		<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>hosts</span> = <span style=color:#66d9ef>true</span>
	}
}
</code></pre></div><p>路由和对应的处理器会被组成 <a href=/golang/tree/net/http.DefaultServeMux><code>net/http.DefaultServeMux</code></a>，该结构会持有一个 <a href=/golang/tree/net/http.muxEntry><code>net/http.muxEntry</code></a> 哈希，其中存储了从 URL 到处理器的映射关系，HTTP 服务器在处理请求时就会使用该哈希查找处理器。</p><h3 id=处理请求>处理请求
<a class=anchor href=#%e5%a4%84%e7%90%86%e8%af%b7%e6%b1%82>#</a></h3><p>标准库提供的 <a href=/golang/tree/net/http.ListenAndServe><code>net/http.ListenAndServe</code></a> 可以用来监听 TCP 连接并处理请求，该函数会使用传入的监听地址和处理器初始化一个 HTTP 服务器 <a href=/golang/tree/net/http.Server><code>net/http.Server</code></a>，调用该服务器的 <a href=/golang/tree/net/http.Server.ListenAndServe><code>net/http.Server.ListenAndServe</code></a> 方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>handler</span> <span style=color:#a6e22e>Handler</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>server</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Server</span>{<span style=color:#a6e22e>Addr</span>: <span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>Handler</span>: <span style=color:#a6e22e>handler</span>}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>ListenAndServe</span>()
}
</code></pre></div><p><a href=/golang/tree/net/http.Server.ListenAndServe><code>net/http.Server.ListenAndServe</code></a> 会使用网络库提供的 <a href=/golang/tree/net.Listen><code>net.Listen</code></a> 监听对应地址上的 TCP 连接并通过 <a href=/golang/tree/net/http.Server.Serve><code>net/http.Server.Serve</code></a> 处理客户端的请求：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>srv</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Server</span>) <span style=color:#a6e22e>ListenAndServe</span>() <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>addr</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
		<span style=color:#a6e22e>addr</span> = <span style=color:#e6db74>&#34;:http&#34;</span>
	}
	<span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#a6e22e>addr</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>ln</span>)
}
</code></pre></div><p><a href=/golang/tree/net/http.Server.Serve><code>net/http.Server.Serve</code></a> 会在循环中监听外部的 TCP 连接并为每个连接调用 <a href=/golang/tree/net/http.Server.newConn><code>net/http.Server.newConn</code></a> 创建新的 <a href=/golang/tree/net/http.conn><code>net/http.conn</code></a>，它是 HTTP 连接的服务端表示：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>srv</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Server</span>) <span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>l</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listener</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>l</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>onceCloseListener</span>{<span style=color:#a6e22e>Listener</span>: <span style=color:#a6e22e>l</span>}
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Close</span>()

	<span style=color:#a6e22e>baseCtx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>()
	<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithValue</span>(<span style=color:#a6e22e>baseCtx</span>, <span style=color:#a6e22e>ServerContextKey</span>, <span style=color:#a6e22e>srv</span>)
	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>rw</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Accept</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>select</span> {
			<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>getDoneChan</span>():
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrServerClosed</span>
			<span style=color:#66d9ef>default</span>:
			}
			<span style=color:#f92672>...</span>
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
		<span style=color:#a6e22e>connCtx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>
		<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>newConn</span>(<span style=color:#a6e22e>rw</span>)
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>setState</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>rwc</span>, <span style=color:#a6e22e>StateNew</span>) <span style=color:#75715e>// before Serve can return
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>serve</span>(<span style=color:#a6e22e>connCtx</span>)
	}
}
</code></pre></div><p>创建了服务端的连接之后，标准库中的实现会为每个 HTTP 请求创建单独的 Goroutine 并在其中调用 <a href=/golang/tree/net/http.Conn.serve><code>net/http.Conn.serve</code></a> 方法，如果当前 HTTP 服务接收到了海量的请求，会在内部创建大量的 Goroutine，这可能会使整个服务质量明显降低无法处理请求。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>conn</span>) <span style=color:#a6e22e>serve</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>remoteAddr</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>rwc</span>.<span style=color:#a6e22e>RemoteAddr</span>().<span style=color:#a6e22e>String</span>()

	<span style=color:#a6e22e>ctx</span> = <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithValue</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>LocalAddrContextKey</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>rwc</span>.<span style=color:#a6e22e>LocalAddr</span>())
	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancelCtx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>ctx</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancelCtx</span> = <span style=color:#a6e22e>cancelCtx</span>
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cancelCtx</span>()

	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>r</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>connReader</span>{<span style=color:#a6e22e>conn</span>: <span style=color:#a6e22e>c</span>}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>bufr</span> = <span style=color:#a6e22e>newBufioReader</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>r</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>bufw</span> = <span style=color:#a6e22e>newBufioWriterSize</span>(<span style=color:#a6e22e>checkConnErrorWriter</span>{<span style=color:#a6e22e>c</span>}, <span style=color:#ae81ff>4</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>10</span>)

	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>readRequest</span>(<span style=color:#a6e22e>ctx</span>)
		<span style=color:#a6e22e>serverHandler</span>{<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>server</span>}.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>req</span>)
		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>finishRequest</span>()
		<span style=color:#f92672>...</span>
	}
}
</code></pre></div><p>上述代码片段是我们简化后的连接处理过程，其中包含读取 HTTP 请求、调用 Handler 处理 HTTP 请求以及调用完成该请求。读取 HTTP 请求会调用 <a href=/golang/tree/net/http.Conn.readRequest><code>net/http.Conn.readRequest</code></a>，该方法会从连接中获取 HTTP 请求并构建一个实现了 <a href=/golang/tree/net/http.ResponseWriter><code>net/http.ResponseWriter</code></a> 接口的变量 <a href=/golang/tree/net/http.response><code>net/http.response</code></a>，向该结构体写入的数据都会被转发到它持有的缓冲区中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>response</span>) <span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>lenData</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>dataB</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>dataS</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>written</span> <span style=color:#f92672>+=</span> int64(<span style=color:#a6e22e>lenData</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>contentLength</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>written</span> &gt; <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>contentLength</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>ErrContentLength</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dataB</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>dataB</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>dataS</span>)
	}
}
</code></pre></div><p>解析了 HTTP 请求并初始化 <a href=/golang/tree/net/http.ResponseWriter><code>net/http.ResponseWriter</code></a> 之后，我们就可以调用 <a href=/golang/tree/net/http.serverHandler.ServeHTTP><code>net/http.serverHandler.ServeHTTP</code></a> 查找处理器来处理 HTTP 请求了：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>serverHandler</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>srv</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Server</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>sh</span> <span style=color:#a6e22e>serverHandler</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>rw</span> <span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) {
	<span style=color:#a6e22e>handler</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sh</span>.<span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>Handler</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>handler</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>handler</span> = <span style=color:#a6e22e>DefaultServeMux</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>RequestURI</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;*&#34;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;OPTIONS&#34;</span> {
		<span style=color:#a6e22e>handler</span> = <span style=color:#a6e22e>globalOptionsHandler</span>{}
	}
	<span style=color:#a6e22e>handler</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>rw</span>, <span style=color:#a6e22e>req</span>)
}
</code></pre></div><p>如果当前的 HTTP 服务器中不包含任何处理器，我们会使用默认的 <a href=/golang/tree/net/http.DefaultServeMux><code>net/http.DefaultServeMux</code></a> 处理外部的 HTTP 请求。</p><p><a href=/golang/tree/net/http.ServeMux><code>net/http.ServeMux</code></a> 是一个 HTTP 请求的多路复用器，它可以接收外部的 HTTP 请求、根据请求的 URL 匹配并调用最合适的处理器：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>mux</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ServeMux</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) {
	<span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handler</span>(<span style=color:#a6e22e>r</span>)
	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>)
}
</code></pre></div><p>经过一系列的函数调用，上述过程最终会调用 HTTP 服务器的 <a href=/golang/tree/net/http.ServerMux.match><code>net/http.ServerMux.match</code></a>，该方法会遍历前面注册过的路由表并根据特定规则进行匹配：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>mux</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ServeMux</span>) <span style=color:#a6e22e>match</span>(<span style=color:#a6e22e>path</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>Handler</span>, <span style=color:#a6e22e>pattern</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>path</span>]
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>pattern</span>
	}

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>es</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>HasPrefix</span>(<span style=color:#a6e22e>path</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>pattern</span>) {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>pattern</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#e6db74>&#34;&#34;</span>
}
</code></pre></div><p>如果请求的路径和路由中的表项匹配成功，我们会调用表项中对应的处理器，处理器中包含的业务逻辑会通过 <a href=/golang/tree/net/http.ResponseWriter><code>net/http.ResponseWriter</code></a> 构建 HTTP 请求对应的响应并通过 TCP 连接发送回客户端。</p><h2 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h2><p>Go 语言的 HTTP 标准库提供了非常丰富的功能，很多语言的标准库只提供了最基本的功能，实现 HTTP 客户端和服务器往往都需要借助其他开源的框架，但是 Go 语言的很多项目都会直接使用标准库实现 HTTP 服务器，这也从侧面说明了 Go 语言标准库的价值。</p><p><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/ class=book-btn>上一节</a>
<a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Wikipedia: Hypertext Transfer Protocol <a href=https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol>HTTPS://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Wikipedia: Transmission Control Procol <a href=https://en.wikipedia.org/wiki/Transmission_Control_Protocol>HTTPS://en.wikipedia.org/wiki/Transmission_Control_Protocol</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>为什么 TCP 协议有粘包问题 <a href=/whys-the-design-tcp-message-frame/>/whys-the-design-tcp-message-frame/</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-net-http data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-net-http",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#92-http>9.2 HTTP</a><ul><li><a href=#921-设计原理>9.2.1 设计原理</a><ul><li><a href=#请求和响应>请求和响应</a></li><li><a href=#消息边界>消息边界</a></li><li><a href=#层级结构>层级结构</a></li></ul></li><li><a href=#922-客户端>9.2.2 客户端</a><ul><li><a href=#构建请求>构建请求</a></li><li><a href=#开启事务>开启事务</a></li><li><a href=#等待请求>等待请求</a></li></ul></li><li><a href=#923-服务器>9.2.3 服务器</a><ul><li><a href=#注册处理器>注册处理器</a></li><li><a href=#处理请求>处理请求</a></li></ul></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></aside></main></body></html>