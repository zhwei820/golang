<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="9.3 数据库 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  数据库几乎是所有 Web 服务不可或缺的一部分，在所有类型的数据库中，关系型数据库是我们在想要持久存储数据时的首要选择。因为关系型数据库的种类繁多，所以 Go 语言的标准库 database/sql 仅为访问关系型数据提供了通用的接口，这样不同数据库只要实现标准库中的接口，应用程序就可以通过标准库中的方法读写数据库中的数据。
9.3.1 设计原理 #  结构化查询语言（Structured Query Language、SQL）是在关系型数据库系统中使用的领域特定语言（Domain-Specific Language、DSL），它主要用于处理结构化的数据1。作为一门领域特定语言，它有更加强大的表达能力，与传统的命令式 API 相比，它能够提供两个优点：
 可以使用单个命令在数据库中访问多条数据； 不需要在查询中指定获取数据的方法；  所有的关系型数据库都会提供 SQL 作为查询语言，应用程序可以使用相同的 SQL 查询在不同数据库中查询数据，当然不同的数据库在实现细节和接口上还略有一些不同，这些不兼容的特性在不同数据库中仍然无法通用，例如：PostgreSQL 中的几何类型，不过它们基本都会兼容标准的 SQL 查询以方便应用程序接入：
图 9-12 SQL 和数据库
如上图所示，SQL 是应用程序和数据库之间的中间层，应用程序在多数情况下都不需要关心底层数据库的实现，它们只关心 SQL 查询返回的数据。
Go 语言的 database/sql 就建立在上述前提下，我们可以使用相同的 SQL 语言查询关系型数据库，所有关系型数据库的客户端都需要实现如下所示的驱动接口：
type Driver interface { Open(name string) (Conn, error) } type Conn interface { Prepare(query string) (Stmt, error) Close() error Begin() (Tx, error) } database/sql/driver."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言数据库的实现原理"><meta property="og:description" content="9.3 数据库 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  数据库几乎是所有 Web 服务不可或缺的一部分，在所有类型的数据库中，关系型数据库是我们在想要持久存储数据时的首要选择。因为关系型数据库的种类繁多，所以 Go 语言的标准库 database/sql 仅为访问关系型数据提供了通用的接口，这样不同数据库只要实现标准库中的接口，应用程序就可以通过标准库中的方法读写数据库中的数据。
9.3.1 设计原理 #  结构化查询语言（Structured Query Language、SQL）是在关系型数据库系统中使用的领域特定语言（Domain-Specific Language、DSL），它主要用于处理结构化的数据1。作为一门领域特定语言，它有更加强大的表达能力，与传统的命令式 API 相比，它能够提供两个优点：
 可以使用单个命令在数据库中访问多条数据； 不需要在查询中指定获取数据的方法；  所有的关系型数据库都会提供 SQL 作为查询语言，应用程序可以使用相同的 SQL 查询在不同数据库中查询数据，当然不同的数据库在实现细节和接口上还略有一些不同，这些不兼容的特性在不同数据库中仍然无法通用，例如：PostgreSQL 中的几何类型，不过它们基本都会兼容标准的 SQL 查询以方便应用程序接入：
图 9-12 SQL 和数据库
如上图所示，SQL 是应用程序和数据库之间的中间层，应用程序在多数情况下都不需要关心底层数据库的实现，它们只关心 SQL 查询返回的数据。
Go 语言的 database/sql 就建立在上述前提下，我们可以使用相同的 SQL 语言查询关系型数据库，所有关系型数据库的客户端都需要实现如下所示的驱动接口：
type Driver interface { Open(name string) (Conn, error) } type Conn interface { Prepare(query string) (Stmt, error) Close() error Begin() (Tx, error) } database/sql/driver."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/"><title>Go 语言数据库的实现原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言数据库的实现原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#93-数据库>9.3 数据库</a><ul><li><a href=#931-设计原理>9.3.1 设计原理</a></li><li><a href=#932-驱动接口>9.3.2 驱动接口</a></li><li><a href=#933-总结>9.3.3 总结</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=93-数据库>9.3 数据库
<a class=anchor href=#93-%e6%95%b0%e6%8d%ae%e5%ba%93>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>数据库几乎是所有 Web 服务不可或缺的一部分，在所有类型的数据库中，关系型数据库是我们在想要持久存储数据时的首要选择。因为关系型数据库的种类繁多，所以 Go 语言的标准库 <a href=https://golang.org/pkg/database/sql/><code>database/sql</code></a> 仅为访问关系型数据提供了通用的接口，这样不同数据库只要实现标准库中的接口，应用程序就可以通过标准库中的方法读写数据库中的数据。</p><h2 id=931-设计原理>9.3.1 设计原理
<a class=anchor href=#931-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>结构化查询语言（Structured Query Language、SQL）是在关系型数据库系统中使用的领域特定语言（Domain-Specific Language、DSL），它主要用于处理结构化的数据<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。作为一门领域特定语言，它有更加强大的表达能力，与传统的命令式 API 相比，它能够提供两个优点：</p><ol><li>可以使用单个命令在数据库中访问多条数据；</li><li>不需要在查询中指定获取数据的方法；</li></ol><p>所有的关系型数据库都会提供 SQL 作为查询语言，应用程序可以使用相同的 SQL 查询在不同数据库中查询数据，当然不同的数据库在实现细节和接口上还略有一些不同，这些不兼容的特性在不同数据库中仍然无法通用，例如：PostgreSQL 中的几何类型，不过它们基本都会兼容标准的 SQL 查询以方便应用程序接入：</p><p><img src=https://img.draveness.me/2020-05-24-15902906415020-sql-and-database.png alt=sql-and-database></p><p><strong>图 9-12 SQL 和数据库</strong></p><p>如上图所示，SQL 是应用程序和数据库之间的中间层，应用程序在多数情况下都不需要关心底层数据库的实现，它们只关心 SQL 查询返回的数据。</p><p>Go 语言的 <a href=https://golang.org/pkg/database/sql/><code>database/sql</code></a> 就建立在上述前提下，我们可以使用相同的 SQL 语言查询关系型数据库，所有关系型数据库的客户端都需要实现如下所示的驱动接口：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Driver</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Conn</span>, <span style=color:#66d9ef>error</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Conn</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Prepare</span>(<span style=color:#a6e22e>query</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Stmt</span>, <span style=color:#66d9ef>error</span>)
	<span style=color:#a6e22e>Close</span>() <span style=color:#66d9ef>error</span>
	<span style=color:#a6e22e>Begin</span>() (<span style=color:#a6e22e>Tx</span>, <span style=color:#66d9ef>error</span>)
}
</code></pre></div><p><a href=/golang/tree/database/sql/driver.Driver><code>database/sql/driver.Driver</code></a> 接口中只包含一个 <code>Open</code> 方法，该方法接收一个数据库连接串作为输入参数并返回一个特定数据库的连接，作为参数的数据库连接串是数据库特定的格式，这个返回的连接仍然是一个接口，整个标准库中的全部接口可以构成如下所示的树形结构：</p><p><img src=https://img.draveness.me/2020-05-24-15902906415032-database-sql-driver.png alt=database-sql-driver></p><p><strong>图 9-13 数据库驱动树形结构</strong></p><p>MySQL 的驱动 <a href=https://github.com/go-sql-driver/mysql>go-sql-driver/mysql</a> 就实现了上图中的树形结构，我们可以使用语言原生的接口在 MySQL 中查询或者管理数据。</p><h2 id=932-驱动接口>9.3.2 驱动接口
<a class=anchor href=#932-%e9%a9%b1%e5%8a%a8%e6%8e%a5%e5%8f%a3>#</a></h2><p>我们在这里从 <a href=https://golang.org/pkg/database/sql/><code>database/sql</code></a> 标准库提供的几个方法为入口分析这个中间层的实现原理，其中包括数据库驱动的注册、获取数据库连接和查询数据，这些方法都是我们在与数据库打交道时的最常用接口。</p><p><a href=https://golang.org/pkg/database/sql/><code>database/sql</code></a> 中提供的 <a href=/golang/tree/database/sql.Register><code>database/sql.Register</code></a> 方法可以注册自定义的数据库驱动，这个 package 的内部包含两个变量，分别是 <code>drivers</code> 哈希以及 <code>driversMu</code> 互斥锁，所有的数据库驱动都会存储在这个哈希中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Register</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>driver</span> <span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>Driver</span>) {
	<span style=color:#a6e22e>driversMu</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>driversMu</span>.<span style=color:#a6e22e>Unlock</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>driver</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#e6db74>&#34;sql: Register driver is nil&#34;</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>dup</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>drivers</span>[<span style=color:#a6e22e>name</span>]; <span style=color:#a6e22e>dup</span> {
		panic(<span style=color:#e6db74>&#34;sql: Register called twice for driver &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>name</span>)
	}
	<span style=color:#a6e22e>drivers</span>[<span style=color:#a6e22e>name</span>] = <span style=color:#a6e22e>driver</span>
}
</code></pre></div><p>MySQL 驱动会在 <a href=/golang/tree/go-sql-driver/mysql/mysql.init><code>go-sql-driver/mysql/mysql.init</code></a> 中调用上述方法将实现 <a href=/golang/tree/database/sql/driver.Driver><code>database/sql/driver.Driver</code></a> 接口的结构体注册到全局的驱动列表中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
	<span style=color:#a6e22e>sql</span>.<span style=color:#a6e22e>Register</span>(<span style=color:#e6db74>&#34;mysql&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>MySQLDriver</span>{})
}
</code></pre></div><p>当我们在全局变量中注册了驱动之后，就可以使用 <a href=/golang/tree/database/sql.Open><code>database/sql.Open</code></a> 方法获取特定数据库的连接。在如下所示的方法中，我们通过传入的驱动名获取 <a href=/golang/tree/database/sql/driver.Driver><code>database/sql/driver.Driver</code></a> 组成 <a href=/golang/tree/database/sql.dsnConnector><code>database/sql.dsnConnector</code></a> 结构体后调用 <a href=/golang/tree/database/sql.OpenDB><code>database/sql.OpenDB</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>driverName</span>, <span style=color:#a6e22e>dataSourceName</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>driversMu</span>.<span style=color:#a6e22e>RLock</span>()
	<span style=color:#a6e22e>driveri</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>drivers</span>[<span style=color:#a6e22e>driverName</span>]
	<span style=color:#a6e22e>driversMu</span>.<span style=color:#a6e22e>RUnlock</span>()
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;sql: unknown driver %q (forgotten import?)&#34;</span>, <span style=color:#a6e22e>driverName</span>)
	}
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>OpenDB</span>(<span style=color:#a6e22e>dsnConnector</span>{<span style=color:#a6e22e>dsn</span>: <span style=color:#a6e22e>dataSourceName</span>, <span style=color:#a6e22e>driver</span>: <span style=color:#a6e22e>driveri</span>}), <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p><a href=/golang/tree/database/sql.OpenDB><code>database/sql.OpenDB</code></a> 会返回一个 <a href=/golang/tree/database/sql.DB><code>database/sql.DB</code></a> 结构，这是标准库包为我们提供的关键结构体，无论是我们直接使用标准库查询数据库，还是使用 GORM 等 ORM 框架都会用到它：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>OpenDB</span>(<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>Connector</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span> {
	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>())
	<span style=color:#a6e22e>db</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>DB</span>{
		<span style=color:#a6e22e>connector</span>:    <span style=color:#a6e22e>c</span>,
		<span style=color:#a6e22e>openerCh</span>:     make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}, <span style=color:#a6e22e>connectionRequestQueueSize</span>),
		<span style=color:#a6e22e>lastPut</span>:      make(<span style=color:#66d9ef>map</span>[<span style=color:#f92672>*</span><span style=color:#a6e22e>driverConn</span>]<span style=color:#66d9ef>string</span>),
		<span style=color:#a6e22e>connRequests</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>uint64</span>]<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>connRequest</span>),
		<span style=color:#a6e22e>stop</span>:         <span style=color:#a6e22e>cancel</span>,
	}
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>connectionOpener</span>(<span style=color:#a6e22e>ctx</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>db</span>
}
</code></pre></div><p>结构体 <a href=/golang/tree/database/sql.DB><code>database/sql.DB</code></a> 在刚刚初始化时不会包含任何的数据库连接，它持有的数据库连接池会在真正应用程序申请连接时在单独的 Goroutine 中获取。<a href=/golang/tree/database/sql.DB.connectionOpener><code>database/sql.DB.connectionOpener</code></a> 方法中包含一个不会退出的循环，每当该 Goroutine 收到了请求时都会调用 <a href=/golang/tree/database/sql.DB.openNewConnection><code>database/sql.DB.openNewConnection</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span>) <span style=color:#a6e22e>openNewConnection</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) {
	<span style=color:#a6e22e>ci</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>connector</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>ctx</span>)
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>dc</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>driverConn</span>{
		<span style=color:#a6e22e>db</span>:         <span style=color:#a6e22e>db</span>,
		<span style=color:#a6e22e>createdAt</span>:  <span style=color:#a6e22e>nowFunc</span>(),
		<span style=color:#a6e22e>returnedAt</span>: <span style=color:#a6e22e>nowFunc</span>(),
		<span style=color:#a6e22e>ci</span>:         <span style=color:#a6e22e>ci</span>,
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>putConnDBLocked</span>(<span style=color:#a6e22e>dc</span>, <span style=color:#a6e22e>err</span>) {
		<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>addDepLocked</span>(<span style=color:#a6e22e>dc</span>, <span style=color:#a6e22e>dc</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>numOpen</span><span style=color:#f92672>--</span>
		<span style=color:#a6e22e>ci</span>.<span style=color:#a6e22e>Close</span>()
	}
}
</code></pre></div><p>数据库结构体 <a href=/golang/tree/database/sql.DB><code>database/sql.DB</code></a> 中的链接器是实现了 <a href=/golang/tree/database/sql/driver.Connector><code>database/sql/driver.Connector</code></a> 类型的接口，我们可以使用该接口创建任意数量完全等价的连接，创建的所有连接都会被加入连接池中，MySQL 的驱动在 <a href=/golang/tree/go-sql-driver/mysql/mysql.connector.Connect><code>go-sql-driver/mysql/mysql.connector.Connect</code></a> 方法实现了连接数据库的逻辑。</p><p>无论是使用 ORM 框架还是直接使用标准库，当我们在查询数据库时都会调用 <a href=/golang/tree/database/sql.DB.Query><code>database/sql.DB.Query</code></a> 方法，该方法的入参就是 SQL 语句和 SQL 语句中的参数，它会初始化新的上下文并调用 <a href=/golang/tree/database/sql.DB.QueryContext><code>database/sql.DB.QueryContext</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span>) <span style=color:#a6e22e>QueryContext</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>query</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>args</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>interface</span>{}) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Rows</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>rows</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Rows</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>maxBadConnRetries</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>query</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>cachedOrNewConn</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>ErrBadConn</span> {
			<span style=color:#66d9ef>break</span>
		}
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>ErrBadConn</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>query</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>alwaysNewConn</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>err</span>
}
</code></pre></div><p><a href=/golang/tree/database/sql.DB.query><code>database/sql.DB.query</code></a> 的执行过程可以分成两个部分，首先调用私有方法 <a href=/golang/tree/database/sql.DB.conn><code>database/sql.DB.conn</code></a> 获取底层数据库的连接，数据库连接既可能是刚刚通过连接器创建的，也可能是之前缓存的连接；获取连接之后调用 <a href=/golang/tree/database/sql.DB.queryDC><code>database/sql.DB.queryDC</code></a> 在特定的数据库连接上执行查询：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span>) <span style=color:#a6e22e>queryDC</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>txctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>dc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>driverConn</span>, <span style=color:#a6e22e>releaseConn</span> <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>error</span>), <span style=color:#a6e22e>query</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>args</span> []<span style=color:#66d9ef>interface</span>{}) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Rows</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>queryerCtx</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dc</span>.<span style=color:#a6e22e>ci</span>.(<span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>QueryerContext</span>)
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>queryer</span> <span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>Queryer</span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
		<span style=color:#a6e22e>queryer</span>, <span style=color:#a6e22e>ok</span> = <span style=color:#a6e22e>dc</span>.<span style=color:#a6e22e>ci</span>.(<span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>Queryer</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nvdargs</span> []<span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>NamedValue</span>
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>rowsi</span> <span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>Rows</span>
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
		<span style=color:#a6e22e>withLock</span>(<span style=color:#a6e22e>dc</span>, <span style=color:#66d9ef>func</span>() {
			<span style=color:#a6e22e>nvdargs</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>driverArgsConnLocked</span>(<span style=color:#a6e22e>dc</span>.<span style=color:#a6e22e>ci</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>args</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span>
			}
			<span style=color:#a6e22e>rowsi</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>ctxDriverQuery</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>queryerCtx</span>, <span style=color:#a6e22e>queryer</span>, <span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>nvdargs</span>)
		})
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>ErrSkip</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>releaseConn</span>(<span style=color:#a6e22e>err</span>)
				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
			}
			<span style=color:#a6e22e>rows</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Rows</span>{
				<span style=color:#a6e22e>dc</span>:          <span style=color:#a6e22e>dc</span>,
				<span style=color:#a6e22e>releaseConn</span>: <span style=color:#a6e22e>releaseConn</span>,
				<span style=color:#a6e22e>rowsi</span>:       <span style=color:#a6e22e>rowsi</span>,
			}
			<span style=color:#a6e22e>rows</span>.<span style=color:#a6e22e>initContextClose</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>txctx</span>)
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rows</span>, <span style=color:#66d9ef>nil</span>
		}
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>上述方法在准备了 SQL 查询所需的参数之后，会调用 <a href=/golang/tree/database/sql.ctxDriverQuery><code>database/sql.ctxDriverQuery</code></a> 完成 SQL 查询，我们会判断当前的查询上下文究竟实现了哪个接口，然后调用对应接口的 <code>Query</code> 或者 <code>QueryContext</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ctxDriverQuery</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>queryerCtx</span> <span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>QueryerContext</span>, <span style=color:#a6e22e>queryer</span> <span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>Queryer</span>, <span style=color:#a6e22e>query</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>nvdargs</span> []<span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>NamedValue</span>) (<span style=color:#a6e22e>driver</span>.<span style=color:#a6e22e>Rows</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>queryerCtx</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>queryerCtx</span>.<span style=color:#a6e22e>QueryContext</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>nvdargs</span>)
	}
	<span style=color:#a6e22e>dargs</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>namedValueToValue</span>(<span style=color:#a6e22e>nvdargs</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
	}
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>queryer</span>.<span style=color:#a6e22e>Query</span>(<span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>dargs</span>)
}
</code></pre></div><p>对应的数据库驱动会真正负责执行调用方输入的 SQL 查询，作为中间层的标准库可以不在乎具体的实现，抹平不同关系型数据库的差异，为用户程序提供统一的接口。</p><h2 id=933-总结>9.3.3 总结
<a class=anchor href=#933-%e6%80%bb%e7%bb%93>#</a></h2><p>Go 语言的标准库 <a href=https://golang.org/pkg/database/sql/><code>database/sql</code></a> 是一个抽象层的经典例子，虽然关系型数据库的功能相对比较复杂，但是我们仍然可以通过定义一系列构成树形结构的接口提供合理的抽象，这也是我们在编写框架和中间层时应该注意的，即面向接口编程 —— 只依赖抽象的接口，不要依赖具体的实现。</p><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/ class=book-btn>上一节</a><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Wikipedia: SQL <a href=https://en.wikipedia.org/wiki/SQL>https://en.wikipedia.org/wiki/SQL</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-database-sql data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-database-sql",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#93-数据库>9.3 数据库</a><ul><li><a href=#931-设计原理>9.3.1 设计原理</a></li><li><a href=#932-驱动接口>9.3.2 驱动接口</a></li><li><a href=#933-总结>9.3.3 总结</a></li></ul></li></ul></nav></aside></main></body></html>