<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="9.1 JSON #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  JSON（JavaScript 对象表示，JavaScript Object Notation）作为一种轻量级的数据交换格式1，在今天几乎占据了绝大多数的市场份额。虽然与更紧凑的数据交换格式相比，它的序列化和反序列化性能不足，但是 JSON 提供了良好的可读性与易用性，在不追求极致机制性能的情况下，使用 JSON 作为序列化格式是一种非常好的选择。
9.1.1 设计原理 #  几乎所有的现代编程语言都会将处理 JSON 的函数直接纳入标准库，Go 语言也不例外，它通过 encoding/json 对外提供标准的 JSON 序列化和反序列化方法，即 encoding/json.Marshal 和 encoding/json.Unmarshal，它们也是包中最常用的两个方法。
图 9-1 序列化和反序列化
序列化和反序列化的开销完全不同，JSON 反序列化的开销是序列化开销的好几倍，相信这背后的原因也非常好理解。Go 语言中的 JSON 序列化过程不需要被序列化的对象预先实现任何接口，它会通过反射获取结构体或者数组中的值并以树形的结构递归地进行编码，标准库也会根据 encoding/json.Unmarshal 中传入的值对 JSON 进行解码。
Go 语言 JSON 标准库编码和解码的过程大量地运用了反射这一特性，你会在本节的后半部分看到大量的反射代码，这一小节就不过多介绍了。我们在这里会简单介绍 JSON 标准库中的接口和标签，这是它为开发者提供的为数不多的影响编解码过程的接口。
接口 #  JSON 标准库中提供了 encoding/json.Marshaler 和 encoding/json.Unmarshaler 两个接口分别可以影响 JSON 的序列化和反序列化结果：
type Marshaler interface { MarshalJSON() ([]byte, error) } type Unmarshaler interface { UnmarshalJSON([]byte) error } 在 JSON 序列化和反序列化的过程中，它会使用反射判断结构体类型是否实现了上述接口，如果实现了上述接口就会优先使用对应的方法进行编码和解码操作，除了这两个方法之外，Go 语言其实还提供了另外两个用于控制编解码结果的方法，即 encoding."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言 JSON 的实现原理"><meta property="og:description" content="9.1 JSON #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  JSON（JavaScript 对象表示，JavaScript Object Notation）作为一种轻量级的数据交换格式1，在今天几乎占据了绝大多数的市场份额。虽然与更紧凑的数据交换格式相比，它的序列化和反序列化性能不足，但是 JSON 提供了良好的可读性与易用性，在不追求极致机制性能的情况下，使用 JSON 作为序列化格式是一种非常好的选择。
9.1.1 设计原理 #  几乎所有的现代编程语言都会将处理 JSON 的函数直接纳入标准库，Go 语言也不例外，它通过 encoding/json 对外提供标准的 JSON 序列化和反序列化方法，即 encoding/json.Marshal 和 encoding/json.Unmarshal，它们也是包中最常用的两个方法。
图 9-1 序列化和反序列化
序列化和反序列化的开销完全不同，JSON 反序列化的开销是序列化开销的好几倍，相信这背后的原因也非常好理解。Go 语言中的 JSON 序列化过程不需要被序列化的对象预先实现任何接口，它会通过反射获取结构体或者数组中的值并以树形的结构递归地进行编码，标准库也会根据 encoding/json.Unmarshal 中传入的值对 JSON 进行解码。
Go 语言 JSON 标准库编码和解码的过程大量地运用了反射这一特性，你会在本节的后半部分看到大量的反射代码，这一小节就不过多介绍了。我们在这里会简单介绍 JSON 标准库中的接口和标签，这是它为开发者提供的为数不多的影响编解码过程的接口。
接口 #  JSON 标准库中提供了 encoding/json.Marshaler 和 encoding/json.Unmarshaler 两个接口分别可以影响 JSON 的序列化和反序列化结果：
type Marshaler interface { MarshalJSON() ([]byte, error) } type Unmarshaler interface { UnmarshalJSON([]byte) error } 在 JSON 序列化和反序列化的过程中，它会使用反射判断结构体类型是否实现了上述接口，如果实现了上述接口就会优先使用对应的方法进行编码和解码操作，除了这两个方法之外，Go 语言其实还提供了另外两个用于控制编解码结果的方法，即 encoding."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part4-advanced/ch09-stdlib/golang-json/"><title>Go 语言 JSON 的实现原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言 JSON 的实现原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#91-json>9.1 JSON</a><ul><li><a href=#911-设计原理>9.1.1 设计原理</a><ul><li><a href=#接口>接口</a></li><li><a href=#标签>标签</a></li></ul></li><li><a href=#912-序列化>9.1.2 序列化</a></li><li><a href=#913-反序列化>9.1.3 反序列化</a></li><li><a href=#914-小结>9.1.4 小结</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=91-json>9.1 JSON
<a class=anchor href=#91-json>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>JSON（JavaScript 对象表示，JavaScript Object Notation）作为一种轻量级的数据交换格式<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，在今天几乎占据了绝大多数的市场份额。虽然与更紧凑的数据交换格式相比，它的序列化和反序列化性能不足，但是 JSON 提供了良好的可读性与易用性，在不追求极致机制性能的情况下，使用 JSON 作为序列化格式是一种非常好的选择。</p><h2 id=911-设计原理>9.1.1 设计原理
<a class=anchor href=#911-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>几乎所有的现代编程语言都会将处理 JSON 的函数直接纳入标准库，Go 语言也不例外，它通过 <a href=https://golang.org/pkg/encoding/json/><code>encoding/json</code></a> 对外提供标准的 JSON 序列化和反序列化方法，即 <a href=/golang/tree/encoding/json.Marshal><code>encoding/json.Marshal</code></a> 和 <a href=/golang/tree/encoding/json.Unmarshal><code>encoding/json.Unmarshal</code></a>，它们也是包中最常用的两个方法。</p><p><img src=https://img.draveness.me/2020-04-25-15878293719232-json-marshal-and-unmarshal.png alt=json-marshal-and-unmarshal></p><p><strong>图 9-1 序列化和反序列化</strong></p><p>序列化和反序列化的开销完全不同，JSON 反序列化的开销是序列化开销的好几倍，相信这背后的原因也非常好理解。Go 语言中的 JSON 序列化过程不需要被序列化的对象预先实现任何接口，它会通过反射获取结构体或者数组中的值并以树形的结构递归地进行编码，标准库也会根据 <a href=/golang/tree/encoding/json.Unmarshal><code>encoding/json.Unmarshal</code></a> 中传入的值对 JSON 进行解码。</p><p>Go 语言 JSON 标准库编码和解码的过程大量地运用了反射这一特性，你会在本节的后半部分看到大量的反射代码，这一小节就不过多介绍了。我们在这里会简单介绍 JSON 标准库中的接口和标签，这是它为开发者提供的为数不多的影响编解码过程的接口。</p><h3 id=接口>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3>#</a></h3><p>JSON 标准库中提供了 <a href=/golang/tree/encoding/json.Marshaler><code>encoding/json.Marshaler</code></a> 和 <a href=/golang/tree/encoding/json.Unmarshaler><code>encoding/json.Unmarshaler</code></a> 两个接口分别可以影响 JSON 的序列化和反序列化结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Marshaler</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>MarshalJSON</span>() ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Unmarshaler</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>UnmarshalJSON</span>([]<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span>
}
</code></pre></div><p>在 JSON 序列化和反序列化的过程中，它会使用反射判断结构体类型是否实现了上述接口，如果实现了上述接口就会优先使用对应的方法进行编码和解码操作，除了这两个方法之外，Go 语言其实还提供了另外两个用于控制编解码结果的方法，即 <a href=/golang/tree/encoding.TextMarshaler><code>encoding.TextMarshaler</code></a> 和 <a href=/golang/tree/encoding.TextUnmarshaler><code>encoding.TextUnmarshaler</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TextMarshaler</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>MarshalText</span>() (<span style=color:#a6e22e>text</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TextUnmarshaler</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>UnmarshalText</span>(<span style=color:#a6e22e>text</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span>
}
</code></pre></div><p>一旦发现 JSON 相关的序列化方法没有被实现，上述两个方法会作为候选方法被 JSON 标准库调用并参与编解码的过程。总的来说，我们可以在任意类型上实现上述这四个方法自定义最终的结果，后面的两个方法的适用范围更广，但是不会被 JSON 标准库优先调用。</p><h3 id=标签>标签
<a class=anchor href=#%e6%a0%87%e7%ad%be>#</a></h3><p>Go 语言的结构体标签也是一个比较有趣的功能，在默认情况下，当我们在序列化和反序列化结构体时，标准库都会认为字段名和 JSON 中的键具有一一对应的关系，然而 Go 语言的字段一般都是驼峰命名法，JSON 中下划线的命名方式相对比较常见，所以使用标签这一特性直接建立键与字段之间的映射关系是一个非常方便的设计。</p><p><img src=https://img.draveness.me/2020-04-25-15878293719272-struct-and-json.png alt=struct-and-json></p><p><strong>图 9-2 结构体与 JSON 的映射</strong></p><p>JSON 中的标签由两部分组成，如下所示的 <code>name</code> 和 <code>age</code> 都是标签名，后面的所有的字符串是标签选项，即 <a href=/golang/tree/encoding/json.tagOptions><code>encoding/json.tagOptions</code></a>，标签名和字段名会建立一一对应的关系，后面的标签选项也会影响编解码的过程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Author</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;name,omitempty&#34;`</span>
    <span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int32</span>  <span style=color:#e6db74>`json:&#34;age,string,omitempty&#34;`</span>
}
</code></pre></div><p>常见的两个标签是 <code>string</code> 和 <code>omitempty</code>，前者表示当前的整数或者浮点数是由 JSON 中的字符串表示的，而另一个字段 <code>omitempty</code> 会在字段为零值时，直接在生成的 JSON 中忽略对应的键值对，例如：<code>"age": 0</code>、<code>"author": ""</code> 等。标准库会使用如下所示的 <a href=/golang/tree/encoding/json.parseTag><code>encoding/json.parseTag</code></a> 来解析标签：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parseTag</span>(<span style=color:#a6e22e>tag</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>tagOptions</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>idx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Index</span>(<span style=color:#a6e22e>tag</span>, <span style=color:#e6db74>&#34;,&#34;</span>); <span style=color:#a6e22e>idx</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>tag</span>[:<span style=color:#a6e22e>idx</span>], <span style=color:#a6e22e>tagOptions</span>(<span style=color:#a6e22e>tag</span>[<span style=color:#a6e22e>idx</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:])
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>tag</span>, <span style=color:#a6e22e>tagOptions</span>(<span style=color:#e6db74>&#34;&#34;</span>)
}
</code></pre></div><p>从该方法的实现中，我们能分析出 JSON 标准库中的合法标签是什么形式的：标签名和标签选项都以 <code>,</code> 连接，最前面的字符串为标签名，后面的都是标签选项。</p><h2 id=912-序列化>9.1.2 序列化
<a class=anchor href=#912-%e5%ba%8f%e5%88%97%e5%8c%96>#</a></h2><p><a href=/golang/tree/encoding/json.Marshal><code>encoding/json.Marshal</code></a> 是 JSON 标准库中提供的最简单的序列化函数，它会接收一个 <code>interface{}</code> 类型的值作为参数，这也意味着几乎全部的 Go 语言变量都可以被 JSON 标准库序列化，为了提供如此复杂和通用的功能，在静态语言中使用反射是常见的选项，下面我们来深入了解一下它的实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newEncodeState</span>()
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>marshal</span>(<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>encOpts</span>{<span style=color:#a6e22e>escapeHTML</span>: <span style=color:#66d9ef>true</span>})
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
	}
	<span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> append([]byte(<span style=color:#66d9ef>nil</span>), <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Bytes</span>()<span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>encodeStatePool</span>.<span style=color:#a6e22e>Put</span>(<span style=color:#a6e22e>e</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>buf</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>上述方法会调用 <a href=/golang/tree/encoding/json.newEncodeState><code>encoding/json.newEncodeState</code></a> 从全局的编码状态池中获取 <a href=/golang/tree/encoding/json.encodeState><code>encoding/json.encodeState</code></a>，随后的序列化过程都会使用这个编码状态，该结构体也会在编码结束后被重新放回池中以便重复利用。</p><p><img src=https://img.draveness.me/2020-04-25-15878293719298-json-marshal-call-stack.png alt=json-marshal-call-stack></p><p><strong>图 9-3 序列化调用栈</strong></p><p>按照如上所示的复杂调用栈，一系列的序列化方法在最后获取了对象的反射类型并调用了 <a href=/golang/tree/encoding/json.newTypeEncoder><code>encoding/json.newTypeEncoder</code></a> 这个核心的编码方法，该方法会递归地为所有的类型找到对应的编码方法，不过它的执行过程可以分成以下两个步骤：</p><ol><li>获取用户自定义的 <a href=/golang/tree/encoding/json.Marshaler><code>encoding/json.Marshaler</code></a> 或者 <a href=/golang/tree/encoding.TextMarshaler><code>encoding.TextMarshaler</code></a> 编码器；</li><li>获取标准库中为基本类型内置的 JSON 编码器；</li></ol><p>在该方法的第一部分，我们会检查当前值的类型是否可以使用用户自定义的编码器，这里有两种不同的判断方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newTypeEncoder</span>(<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>allowAddr</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>encoderFunc</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Ptr</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>allowAddr</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>PtrTo</span>(<span style=color:#a6e22e>t</span>).<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>marshalerType</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newCondAddrEncoder</span>(<span style=color:#a6e22e>addrMarshalerEncoder</span>, <span style=color:#a6e22e>newTypeEncoder</span>(<span style=color:#a6e22e>t</span>, <span style=color:#66d9ef>false</span>))
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>marshalerType</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>marshalerEncoder</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Ptr</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>allowAddr</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>PtrTo</span>(<span style=color:#a6e22e>t</span>).<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>textMarshalerType</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newCondAddrEncoder</span>(<span style=color:#a6e22e>addrTextMarshalerEncoder</span>, <span style=color:#a6e22e>newTypeEncoder</span>(<span style=color:#a6e22e>t</span>, <span style=color:#66d9ef>false</span>))
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>textMarshalerType</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>textMarshalerEncoder</span>
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><ol><li>如果当前值是值类型、可以取地址并且值类型对应的指针类型实现了 <a href=/golang/tree/encoding/json.Marshaler><code>encoding/json.Marshaler</code></a> 接口，调用 <a href=/golang/tree/encoding/json.newCondAddrEncoder><code>encoding/json.newCondAddrEncoder</code></a> 获取一个条件编码器，条件编码器会在 <a href=/golang/tree/encoding/json.addrMarshalerEncoder><code>encoding/json.addrMarshalerEncoder</code></a> 失败时重新选择新的编码器；</li><li>如果当前类型实现了 <a href=/golang/tree/encoding/json.Marshaler><code>encoding/json.Marshaler</code></a> 接口，可以直接使用 <a href=/golang/tree/encoding/json.marshalerEncoder><code>encoding/json.marshalerEncoder</code></a> 序列化；</li></ol><p>在这段代码中，标准库对 <a href=/golang/tree/encoding.TextMarshaler><code>encoding.TextMarshaler</code></a> 的处理也几乎完全相同，只是它会先判断 <a href=/golang/tree/encoding/json.Marshaler><code>encoding/json.Marshaler</code></a> 接口，这也印证了我们在设计原理一节中的推测。</p><p><a href=/golang/tree/encoding/json.newTypeEncoder><code>encoding/json.newTypeEncoder</code></a> 会根据传入值的反射类型获取对应的编码器，其中包括 <code>bool</code>、<code>int</code>、<code>float</code> 等基本类型编码器等和数组、结构体、切片等复杂类型的编码器：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newTypeEncoder</span>(<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>allowAddr</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>encoderFunc</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Kind</span>() {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Bool</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>boolEncoder</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int8</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int16</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int32</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int64</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>intEncoder</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint8</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint16</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint32</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint64</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uintptr</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>uintEncoder</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Float32</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>float32Encoder</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Float64</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>float64Encoder</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>String</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>stringEncoder</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Interface</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>interfaceEncoder</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Struct</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newStructEncoder</span>(<span style=color:#a6e22e>t</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Map</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newMapEncoder</span>(<span style=color:#a6e22e>t</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Slice</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newSliceEncoder</span>(<span style=color:#a6e22e>t</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Array</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newArrayEncoder</span>(<span style=color:#a6e22e>t</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Ptr</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newPtrEncoder</span>(<span style=color:#a6e22e>t</span>)
	<span style=color:#66d9ef>default</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unsupportedTypeEncoder</span>
	}
}
</code></pre></div><p>我们在这里就不一一介绍全部的内置类型编码器了，只挑选其中几个帮助各位读者了解整体的设计。首先我们来看布尔值的 JSON 编码器，它的实现很简单，甚至没有太多值得介绍的地方：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>boolEncoder</span>(<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>encodeState</span>, <span style=color:#a6e22e>v</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>, <span style=color:#a6e22e>opts</span> <span style=color:#a6e22e>encOpts</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>quoted</span> {
		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>WriteByte</span>(<span style=color:#e6db74>&#39;&#34;&#39;</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Bool</span>() {
		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;true&#34;</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;false&#34;</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>quoted</span> {
		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>WriteByte</span>(<span style=color:#e6db74>&#39;&#34;&#39;</span>)
	}
}
</code></pre></div><p>它会根据当前值向编码状态中写入不同的字符串，也就是 true 或者 false，除此之外还会根据编码配置决定是否要在布尔值周围写入双引号 <code>"</code>，而其他的基本类型编码器也都大同小异。</p><p>复杂类型的编码器有着相对复杂的控制结构，我们在这里以结构体的编码器 <a href=/golang/tree/encoding/json.structEncoder><code>encoding/json.structEncoder</code></a> 为例介绍它们的原理，<a href=/golang/tree/encoding/json.newStructEncoder><code>encoding/json.newStructEncoder</code></a> 会为当前结构体的所有字段调用 <a href=/golang/tree/encoding/json.typeEncoder><code>encoding/json.typeEncoder</code></a> 获取类型编码器并返回 <a href=/golang/tree/encoding/json.structEncoder.encode><code>encoding/json.structEncoder.encode</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newStructEncoder</span>(<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>) <span style=color:#a6e22e>encoderFunc</span> {
	<span style=color:#a6e22e>se</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structEncoder</span>{<span style=color:#a6e22e>fields</span>: <span style=color:#a6e22e>cachedTypeFields</span>(<span style=color:#a6e22e>t</span>)}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>se</span>.<span style=color:#a6e22e>encode</span>
}
</code></pre></div><p>从 <a href=/golang/tree/encoding/json.structEncoder.encode><code>encoding/json.structEncoder.encode</code></a> 的实现我们能看出结构体序列化的结果，该方法会遍历结构体中的全部字段，在写入了字段名后，它会调用字段对应类型的编码方法将该字段对应的 JSON 写入缓冲区：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>se</span> <span style=color:#a6e22e>structEncoder</span>) <span style=color:#a6e22e>encode</span>(<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>encodeState</span>, <span style=color:#a6e22e>v</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>, <span style=color:#a6e22e>opts</span> <span style=color:#a6e22e>encOpts</span>) {
	<span style=color:#a6e22e>next</span> <span style=color:#f92672>:=</span> byte(<span style=color:#e6db74>&#39;{&#39;</span>)
<span style=color:#a6e22e>FieldLoop</span>:
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>se</span>.<span style=color:#a6e22e>fields</span>.<span style=color:#a6e22e>list</span> {
		<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>se</span>.<span style=color:#a6e22e>fields</span>.<span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>i</span>]

		<span style=color:#a6e22e>fv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>index</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fv</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Ptr</span> {
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fv</span>.<span style=color:#a6e22e>IsNil</span>() {
					<span style=color:#66d9ef>continue</span> <span style=color:#a6e22e>FieldLoop</span>
				}
				<span style=color:#a6e22e>fv</span> = <span style=color:#a6e22e>fv</span>.<span style=color:#a6e22e>Elem</span>()
			}
			<span style=color:#a6e22e>fv</span> = <span style=color:#a6e22e>fv</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>)
		}

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>omitEmpty</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>isEmptyValue</span>(<span style=color:#a6e22e>fv</span>) {
			<span style=color:#66d9ef>continue</span>
		}
		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>WriteByte</span>(<span style=color:#a6e22e>next</span>)
		<span style=color:#a6e22e>next</span> = <span style=color:#e6db74>&#39;,&#39;</span>
		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>nameNonEsc</span>)
		<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>quoted</span> = <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>quoted</span>
		<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>encoder</span>(<span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>fv</span>, <span style=color:#a6e22e>opts</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;{&#39;</span> {
		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;{}&#34;</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>WriteByte</span>(<span style=color:#e6db74>&#39;}&#39;</span>)
	}
}
</code></pre></div><p>数组以及指针等编码器的实现原理与该方法也没有太多的区别，它们都会使用类似的策略递归地调用持有字段的编码方法，这也就能形成一个如下图所示的树形结构：</p><p><img src=https://img.draveness.me/2020-04-25-15878293719308-struct-encoder.png alt=struct-encoder></p><p><strong>图 9-4 序列化与树形结构体</strong></p><p>树形结构的所有叶节点都是基础类型编码器或者开发者自定义的编码器，得到了整棵树的编码器之后会调用 <a href=/golang/tree/encoding/json.encodeState.reflectValue><code>encoding/json.encodeState.reflectValue</code></a> 从根节点依次调用整棵树的序列化函数，整个 JSON 序列化的过程查找类型和子类型的编码方法并调用的过程，它利用了大量反射的特性做到了足够的通用。</p><h2 id=913-反序列化>9.1.3 反序列化
<a class=anchor href=#913-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96>#</a></h2><p>标准库会使用 <a href=/golang/tree/encoding/json.Unmarshal><code>encoding/json.Unmarshal</code></a> 处理 JSON 的反序列化，与执行过程确定的序列化相比，反序列化的过程是逐渐探索的过程，所以会复杂很多，开销也会高出几倍。因为 Go 语言的表达能力比较有限，反序列化的使用相对比较繁琐，所以需要传入一个变量帮助标准库进行反序列化：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#a6e22e>decodeState</span>
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>checkValid</span>(<span style=color:#a6e22e>data</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>scan</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}

	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>init</span>(<span style=color:#a6e22e>data</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>unmarshal</span>(<span style=color:#a6e22e>v</span>)
}
</code></pre></div><p>在真正执行反序列化之前，我们会先调用 <a href=/golang/tree/encoding/json.checkValid><code>encoding/json.checkValid</code></a> 验证传入 JSON 的合法性保证在反序列化的过程中不会遇到语法错误的问题，在通过合法性的验证之后，标准库会初始化数据并调用 <a href=/golang/tree/encoding/json.decodeState.unmarshal><code>encoding/json.decodeState.unmarshal</code></a> 开始反序列化：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>decodeState</span>) <span style=color:#a6e22e>unmarshal</span>(<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>rv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>v</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rv</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Ptr</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>rv</span>.<span style=color:#a6e22e>IsNil</span>() {
		<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>InvalidUnmarshalError</span>{<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>v</span>)}
	}
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>scan</span>.<span style=color:#a6e22e>reset</span>()
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>scanWhile</span>(<span style=color:#a6e22e>scanSkipSpace</span>)
	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>value</span>(<span style=color:#a6e22e>rv</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>addErrorContext</span>(<span style=color:#a6e22e>err</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>savedError</span>
}
</code></pre></div><p>如果传入的值不是指针或者是空指针，当前方法会返回我们经常会见到的错误 <a href=/golang/tree/encoding/json.InvalidUnmarshalError><code>encoding/json.InvalidUnmarshalError</code></a>，使用格式化输出可以将该错误转换成 &ldquo;json: Unmarshal(non-pointer xxx)"。该方法调用的 <a href=/golang/tree/encoding/json.decodeState.value><code>encoding/json.decodeState.value</code></a> 是所有反序列化过程的执行入口：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>decodeState</span>) <span style=color:#a6e22e>value</span>(<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opcode</span> {
	<span style=color:#66d9ef>default</span>:
		panic(<span style=color:#a6e22e>phasePanicMsg</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>scanBeginArray</span>:
		<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>scanBeginLiteral</span>:
		<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>scanBeginObject</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>IsValid</span>() {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>object</span>(<span style=color:#a6e22e>v</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
			}
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>skip</span>()
		}
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>scanNext</span>()
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>该方法作为最顶层的反序列化方法可以接收三种不同类型的值，也就是数组、字面量和对象，这三种类型都可以作为 JSON 的顶层对象，我们首先来了解一下标准库是如何解析 JSON 中对象的，该过程会使用 <a href=/golang/tree/encoding/json.decodeState.object><code>encoding/json.decodeState.object</code></a> 进行反序列化，它会先调用 <a href=/golang/tree/encoding/json.indirect><code>encoding/json.indirect</code></a> 查找当前类型对应的非指针类型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>decodeState</span>) <span style=color:#a6e22e>object</span>(<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>ut</span>, <span style=color:#a6e22e>pv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>indirect</span>(<span style=color:#a6e22e>v</span>, <span style=color:#66d9ef>false</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>u</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>readIndex</span>()
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>skip</span>()
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>UnmarshalJSON</span>(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>start</span>:<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>off</span>])
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>在调用 <a href=/golang/tree/encoding/json.indirect><code>encoding/json.indirect</code></a> 的过程中，如果当前值的类型是 <code>**Type</code>，那么它会依次检查形如 <code>**Type</code>、<code>*Type</code> 和 <code>Type</code> 类型是否实现了 <a href=/golang/tree/encoding/json.Unmarshal><code>encoding/json.Unmarshal</code></a> 或者 <a href=/golang/tree/encoding.TextUnmarshaler><code>encoding.TextUnmarshaler</code></a> 接口；如果实现了该接口，标准库会直接调用 <code>UnmarshalJSON</code> 使用开发者自定义的方法完成反序列化。</p><p>在其他情况下，我们仍然会回到默认的逻辑中处理对象中的键值对，如下所示的代码会调用 <a href=/golang/tree/encoding/json.decodeState.rescanLiteral><code>encoding/json.decodeState.rescanLiteral</code></a> 扫描 JSON 中的键并在结构体中找到对应字段的反射值，接下来继续扫描符号 <code>:</code> 并调用 <a href=/golang/tree/encoding/json.decodeState.value><code>encoding/json.decodeState.value</code></a> 解析对应的值：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>decodeState</span>) <span style=color:#a6e22e>object</span>(<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>pv</span>
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Type</span>()
	<span style=color:#a6e22e>fields</span> = <span style=color:#a6e22e>cachedTypeFields</span>(<span style=color:#a6e22e>t</span>)
	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>readIndex</span>()
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>rescanLiteral</span>()
		<span style=color:#a6e22e>item</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>start</span>:<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>readIndex</span>()]
		<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>unquoteBytes</span>(<span style=color:#a6e22e>item</span>)
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>subv</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>f</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>field</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fields</span>.<span style=color:#a6e22e>nameIndex</span>[string(<span style=color:#a6e22e>key</span>)]; <span style=color:#a6e22e>ok</span> {
			<span style=color:#a6e22e>f</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>fields</span>.<span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>i</span>]
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>f</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>subv</span> = <span style=color:#a6e22e>v</span>
			<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>index</span> {
				<span style=color:#a6e22e>subv</span> = <span style=color:#a6e22e>subv</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>)
			}
		}

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opcode</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>scanObjectKey</span> {
			panic(<span style=color:#a6e22e>phasePanicMsg</span>)
		}
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>scanWhile</span>(<span style=color:#a6e22e>scanSkipSpace</span>)

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>value</span>(<span style=color:#a6e22e>subv</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opcode</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>scanEndObject</span> {
			<span style=color:#66d9ef>break</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>当上述方法调用 <a href=/golang/tree/encoding/json.decodeState.value><code>encoding/json.decodeState.value</code></a> 时，该方法会重新判断键对应的值是否是对象、数组或者字面量，因为数组和对象都是集合类型，所以该方法会递归地进行扫描，在这里就不再继续介绍这些集合类型的解析过程了，我们来简单分析一下字面量是如何被处理的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>decodeState</span>) <span style=color:#a6e22e>value</span>(<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opcode</span> {
	<span style=color:#66d9ef>default</span>:
		panic(<span style=color:#a6e22e>phasePanicMsg</span>)

	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>scanBeginArray</span>:
		<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>scanBeginObject</span>:
		<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>scanBeginLiteral</span>:
		<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>readIndex</span>()
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>rescanLiteral</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>IsValid</span>() {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>literalStore</span>(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>start</span>:<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>readIndex</span>()], <span style=color:#a6e22e>v</span>, <span style=color:#66d9ef>false</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
			}
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>字面量的扫描会通过 <a href=/golang/tree/encoding/json.decodeState.rescanLiteral><code>encoding/json.decodeState.rescanLiteral</code></a>，该方法会依次扫描缓冲区中的字符并根据字符的不同对字符串进行切片，整个过程有点像编译器的词法分析：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>decodeState</span>) <span style=color:#a6e22e>rescanLiteral</span>() {
	<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>off</span>
<span style=color:#a6e22e>Switch</span>:
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] {
	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;&#34;&#39;</span>: <span style=color:#75715e>// string
</span><span style=color:#75715e></span>		<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;0&#39;</span>, <span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;2&#39;</span>, <span style=color:#e6db74>&#39;3&#39;</span>, <span style=color:#e6db74>&#39;4&#39;</span>, <span style=color:#e6db74>&#39;5&#39;</span>, <span style=color:#e6db74>&#39;6&#39;</span>, <span style=color:#e6db74>&#39;7&#39;</span>, <span style=color:#e6db74>&#39;8&#39;</span>, <span style=color:#e6db74>&#39;9&#39;</span>, <span style=color:#e6db74>&#39;-&#39;</span>: <span style=color:#75715e>// number
</span><span style=color:#75715e></span>		<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;t&#39;</span>: <span style=color:#75715e>// true
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> len(<span style=color:#e6db74>&#34;rue&#34;</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;f&#39;</span>: <span style=color:#75715e>// false
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> len(<span style=color:#e6db74>&#34;alse&#34;</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;n&#39;</span>: <span style=color:#75715e>// null
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> len(<span style=color:#e6db74>&#34;ull&#34;</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>data</span>) {
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opcode</span> = <span style=color:#a6e22e>stateEndValue</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>scan</span>, <span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>i</span>])
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>opcode</span> = <span style=color:#a6e22e>scanEnd</span>
	}
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>off</span> = <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
}
</code></pre></div><p>因为 JSON 中的字面量其实也只包含字符串、数字、布尔值和空值几种，所以该方法的实现也不会特别复杂，当该方法扫描了对应的字面量之后，会调用 <a href=/golang/tree/encoding/json.decodeState.literalStore><code>encoding/json.decodeState.literalStore</code></a> 字面量存储到反射类型变量所在的地址中，在这个过程中会调用反射的 <a href=/golang/tree/reflect.Value.SetInt><code>reflect.Value.SetInt</code></a>、<a href=/golang/tree/reflect.Value.SetFloat><code>reflect.Value.SetFloat</code></a> 和 <a href=/golang/tree/reflect.Value.SetBool><code>reflect.Value.SetBool</code></a> 等方法。</p><h2 id=914-小结>9.1.4 小结
<a class=anchor href=#914-%e5%b0%8f%e7%bb%93>#</a></h2><p>JSON 本身就是一种树形的数据结构，无论是序列化还是反序列化，都会遵循自顶向下的编码和解码过程，使用递归的方式处理 JSON 对象。作为标准库的 JSON 提供的接口非常简洁，虽然它的性能一直被开发者所诟病，但是作为框架它提供了很好的通用性，通过分析 JSON 库的实现，我们也可以从中学习到使用反射的各种方法。</p><p><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/ class=book-btn>上一节</a>
<a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Introducing JSON <a href=https://www.json.org/json-en.html>https://www.json.org/json-en.html</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-json data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-json",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#91-json>9.1 JSON</a><ul><li><a href=#911-设计原理>9.1.1 设计原理</a><ul><li><a href=#接口>接口</a></li><li><a href=#标签>标签</a></li></ul></li><li><a href=#912-序列化>9.1.2 序列化</a></li><li><a href=#913-反序列化>9.1.3 反序列化</a></li><li><a href=#914-小结>9.1.4 小结</a></li></ul></li></ul></nav></aside></main></body></html>