<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="6.7 系统监控 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  很多系统中都有守护进程，它们能够在后台监控系统的运行状态，在出现意外情况时及时响应。系统监控是 Go 语言运行时的重要组成部分，它会每隔一段时间检查 Go 语言运行时，确保程序没有进入异常状态。本节会介绍 Go 语言系统监控的设计与实现原理，包括它的启动、执行过程以及主要职责。
6.7.1 设计原理 #  在支持多任务的操作系统中，守护进程是在后台运行的计算机程序，它不会由用户直接操作，它一般会在操作系统启动时自动运行。Kubernetes 的 DaemonSet 和 Go 语言的系统监控都使用类似设计提供一些通用的功能：
图 6-46 Go 语言系统监控
守护进程是很有效的设计，它在整个系统的生命周期中都会存在，会随着系统的启动而启动，系统的结束而结束。在操作系统和 Kubernetes 中，我们经常会将数据库服务、日志服务以及监控服务等进程作为守护进程运行。
Go 语言的系统监控也起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触发垃圾回收，通过这些行为，它能够让系统的运行状态变得更健康。
6.7.2 监控循环 #  当 Go 语言程序启动时，运行时会在第一个 Goroutine 中调用 runtime.main 启动主程序，该函数会在系统栈中创建新的线程：
func main() { ... if GOARCH != &#34;wasm&#34; { systemstack(func() { newm(sysmon, nil) }) } ... } runtime.newm 会创建一个存储待执行函数和处理器的新结构体 runtime."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言系统监控的实现原理"><meta property="og:description" content="6.7 系统监控 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  很多系统中都有守护进程，它们能够在后台监控系统的运行状态，在出现意外情况时及时响应。系统监控是 Go 语言运行时的重要组成部分，它会每隔一段时间检查 Go 语言运行时，确保程序没有进入异常状态。本节会介绍 Go 语言系统监控的设计与实现原理，包括它的启动、执行过程以及主要职责。
6.7.1 设计原理 #  在支持多任务的操作系统中，守护进程是在后台运行的计算机程序，它不会由用户直接操作，它一般会在操作系统启动时自动运行。Kubernetes 的 DaemonSet 和 Go 语言的系统监控都使用类似设计提供一些通用的功能：
图 6-46 Go 语言系统监控
守护进程是很有效的设计，它在整个系统的生命周期中都会存在，会随着系统的启动而启动，系统的结束而结束。在操作系统和 Kubernetes 中，我们经常会将数据库服务、日志服务以及监控服务等进程作为守护进程运行。
Go 语言的系统监控也起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触发垃圾回收，通过这些行为，它能够让系统的运行状态变得更健康。
6.7.2 监控循环 #  当 Go 语言程序启动时，运行时会在第一个 Goroutine 中调用 runtime.main 启动主程序，该函数会在系统栈中创建新的线程：
func main() { ... if GOARCH != &#34;wasm&#34; { systemstack(func() { newm(sysmon, nil) }) } ... } runtime.newm 会创建一个存储待执行函数和处理器的新结构体 runtime."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/"><title>Go 语言系统监控的实现原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言系统监控的实现原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#67-系统监控>6.7 系统监控</a><ul><li><a href=#671-设计原理>6.7.1 设计原理</a></li><li><a href=#672-监控循环>6.7.2 监控循环</a><ul><li><a href=#检查死锁>检查死锁</a></li><li><a href=#运行计时器>运行计时器</a></li><li><a href=#轮询网络>轮询网络</a></li><li><a href=#抢占处理器>抢占处理器</a></li><li><a href=#垃圾回收>垃圾回收</a></li></ul></li><li><a href=#673-小结>6.7.3 小结</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=67-系统监控>6.7 系统监控
<a class=anchor href=#67-%e7%b3%bb%e7%bb%9f%e7%9b%91%e6%8e%a7>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>很多系统中都有守护进程，它们能够在后台监控系统的运行状态，在出现意外情况时及时响应。系统监控是 Go 语言运行时的重要组成部分，它会每隔一段时间检查 Go 语言运行时，确保程序没有进入异常状态。本节会介绍 Go 语言系统监控的设计与实现原理，包括它的启动、执行过程以及主要职责。</p><h2 id=671-设计原理>6.7.1 设计原理
<a class=anchor href=#671-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>在支持多任务的操作系统中，守护进程是在后台运行的计算机程序，它不会由用户直接操作，它一般会在操作系统启动时自动运行。Kubernetes 的 DaemonSet 和 Go 语言的系统监控都使用类似设计提供一些通用的功能：</p><p><img src=https://img.draveness.me/2020-02-15-15817706777634-golang-system-monitor.png alt=golang-system-monitor></p><p><strong>图 6-46 Go 语言系统监控</strong></p><p>守护进程是很有效的设计，它在整个系统的生命周期中都会存在，会随着系统的启动而启动，系统的结束而结束。在操作系统和 Kubernetes 中，我们经常会将数据库服务、日志服务以及监控服务等进程作为守护进程运行。</p><p>Go 语言的系统监控也起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触发垃圾回收，通过这些行为，它能够让系统的运行状态变得更健康。</p><h2 id=672-监控循环>6.7.2 监控循环
<a class=anchor href=#672-%e7%9b%91%e6%8e%a7%e5%be%aa%e7%8e%af>#</a></h2><p>当 Go 语言程序启动时，运行时会在第一个 Goroutine 中调用 <a href=/golang/tree/runtime.main><code>runtime.main</code></a> 启动主程序，该函数会在系统栈中创建新的线程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>GOARCH</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;wasm&#34;</span> {
		<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
			<span style=color:#a6e22e>newm</span>(<span style=color:#a6e22e>sysmon</span>, <span style=color:#66d9ef>nil</span>)
		})
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p><a href=/golang/tree/runtime.newm><code>runtime.newm</code></a> 会创建一个存储待执行函数和处理器的新结构体 <a href=/golang/tree/runtime.m><code>runtime.m</code></a>。运行时执行系统监控不需要处理器，系统监控的 Goroutine 会直接在创建的线程上运行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newm</span>(<span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) {
	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>allocm</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#a6e22e>fn</span>)
	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>nextp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>_p_</span>)
	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>sigmask</span> = <span style=color:#a6e22e>initSigmask</span>
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>newm1</span>(<span style=color:#a6e22e>mp</span>)
}
</code></pre></div><p><a href=/golang/tree/runtime.newm1><code>runtime.newm1</code></a> 会调用特定平台的 <a href=/golang/tree/runtime.newosproc><code>runtime.newosproc</code></a> 通过系统调用 <code>clone</code> 创建一个新的线程并在新的线程中执行 <a href=/golang/tree/runtime.mstart><code>runtime.mstart</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newosproc</span>(<span style=color:#a6e22e>mp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>) {
	<span style=color:#a6e22e>stk</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span>)
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>oset</span> <span style=color:#a6e22e>sigset</span>
	<span style=color:#a6e22e>sigprocmask</span>(<span style=color:#a6e22e>_SIG_SETMASK</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sigset_all</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>oset</span>)
	<span style=color:#a6e22e>ret</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>clone</span>(<span style=color:#a6e22e>cloneFlags</span>, <span style=color:#a6e22e>stk</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>mstart</span>)))
	<span style=color:#a6e22e>sigprocmask</span>(<span style=color:#a6e22e>_SIG_SETMASK</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>oset</span>, <span style=color:#66d9ef>nil</span>)
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>在新创建的线程中，我们会执行存储在 <a href=/golang/tree/runtime.m><code>runtime.m</code></a> 中的 <a href=/golang/tree/runtime.sysmon><code>runtime.sysmon</code></a> 启动系统监控：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sysmon</span>() {
	<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmsys</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>checkdead</span>()

	<span style=color:#a6e22e>lasttrace</span> <span style=color:#f92672>:=</span> int64(<span style=color:#ae81ff>0</span>)
	<span style=color:#a6e22e>idle</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>delay</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#ae81ff>0</span>)
	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>idle</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>delay</span> = <span style=color:#ae81ff>20</span>
		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>idle</span> &gt; <span style=color:#ae81ff>50</span> {
			<span style=color:#a6e22e>delay</span> <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>delay</span> &gt; <span style=color:#ae81ff>10</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1000</span> {
			<span style=color:#a6e22e>delay</span> = <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>
		}
		<span style=color:#a6e22e>usleep</span>(<span style=color:#a6e22e>delay</span>)
		<span style=color:#f92672>...</span>
	}
}
</code></pre></div><p>当运行时刚刚调用上述函数时，会先通过 <a href=/golang/tree/runtime.checkdead><code>runtime.checkdead</code></a> 检查是否存在死锁，然后进入核心的监控循环；系统监控在每次循环开始时都会通过 <code>usleep</code> 挂起当前线程，该函数的参数是微秒，运行时会遵循以下的规则决定休眠时间：</p><ul><li>初始的休眠时间是 20μs；</li><li>最长的休眠时间是 10ms；</li><li>当系统监控在 50 个循环中都没有唤醒 Goroutine 时，休眠时间在每个循环都会倍增；</li></ul><p>当程序趋于稳定之后，系统监控的触发时间就会稳定在 10ms。它除了会检查死锁之外，还会在循环中完成以下的工作：</p><ul><li>运行计时器 — 获取下一个需要被触发的计时器；</li><li>轮询网络 — 获取需要处理的到期文件描述符；</li><li>抢占处理器 — 抢占运行时间较长的或者处于系统调用的 Goroutine；</li><li>垃圾回收 — 在满足条件时触发垃圾收集回收内存；</li></ul><p>我们在这一节中会依次介绍系统监控是如何完成上述几种不同工作的。</p><h3 id=检查死锁>检查死锁
<a class=anchor href=#%e6%a3%80%e6%9f%a5%e6%ad%bb%e9%94%81>#</a></h3><p>系统监控通过 <a href=/golang/tree/runtime.checkdead><code>runtime.checkdead</code></a> 检查运行时是否发生了死锁，我们可以将检查死锁的过程分成以下三个步骤：</p><ol><li>检查是否存在正在运行的线程；</li><li>检查是否存在正在运行的 Goroutine；</li><li>检查处理器上是否存在计时器；</li></ol><p>该函数首先会检查 Go 语言运行时中正在运行的线程数量，我们通过调度器中的多个字段计算该值的结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>checkdead</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>run0</span> <span style=color:#66d9ef>int32</span>
	<span style=color:#a6e22e>run</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mcount</span>() <span style=color:#f92672>-</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmidle</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmidlelocked</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmsys</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>run</span> &gt; <span style=color:#a6e22e>run0</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>run</span> &lt; <span style=color:#ae81ff>0</span> {
		print(<span style=color:#e6db74>&#34;runtime: checkdead: nmidle=&#34;</span>, <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmidle</span>, <span style=color:#e6db74>&#34; nmidlelocked=&#34;</span>, <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmidlelocked</span>, <span style=color:#e6db74>&#34; mcount=&#34;</span>, <span style=color:#a6e22e>mcount</span>(), <span style=color:#e6db74>&#34; nmsys=&#34;</span>, <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmsys</span>, <span style=color:#e6db74>&#34;\n&#34;</span>)
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;checkdead: inconsistent counts&#34;</span>)
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><ol><li><a href=/golang/tree/runtime.mcount><code>runtime.mcount</code></a> 根据下一个待创建的线程 id 和释放的线程数得到系统中存在的线程数；</li><li><code>nmidle</code> 是处于空闲状态的线程数量；</li><li><code>nmidlelocked</code> 是处于锁定状态的线程数量；</li><li><code>nmsys</code> 是处于系统调用的线程数量；</li></ol><p>利用上述几个线程相关数据，我们可以得到正在运行的线程数，如果线程数量大于 0，说明当前程序不存在死锁；如果线程数小于 0，说明当前程序的状态不一致；如果线程数等于 0，我们需要进一步检查程序的运行状态：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>checkdead</span>() {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>grunning</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>allgs</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>allgs</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isSystemGoroutine</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>) {
			<span style=color:#66d9ef>continue</span>
		}
		<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>readgstatus</span>(<span style=color:#a6e22e>gp</span>)
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>&amp;^</span> <span style=color:#a6e22e>_Gscan</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>_Gwaiting</span>, <span style=color:#a6e22e>_Gpreempted</span>:
			<span style=color:#a6e22e>grunning</span><span style=color:#f92672>++</span>
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>_Grunnable</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gsyscall</span>:
			print(<span style=color:#e6db74>&#34;runtime: checkdead: find g &#34;</span>, <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>goid</span>, <span style=color:#e6db74>&#34; in status &#34;</span>, <span style=color:#a6e22e>s</span>, <span style=color:#e6db74>&#34;\n&#34;</span>)
			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;checkdead: runnable g&#34;</span>)
		}
	}
	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>allglock</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>grunning</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;no goroutines (main called runtime.Goexit) - deadlock!&#34;</span>)
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><ol><li>当存在 Goroutine 处于 <code>_Grunnable</code>、<code>_Grunning</code> 和 <code>_Gsyscall</code> 状态时，意味着程序发生了死锁；</li><li>当所有的 Goroutine 都处于 <code>_Gidle</code>、<code>_Gdead</code> 和 <code>_Gcopystack</code> 状态时，意味着主程序调用了 <a href=/golang/tree/runtime.goexit><code>runtime.goexit</code></a>；</li></ol><p>当运行时存在等待的 Goroutine 并且不存在正在运行的 Goroutine 时，我们会检查处理器中存在的计时器<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>checkdead</span>() {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>allp</span> {
		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>timers</span>) &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>return</span>
		}
	}

	<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;all goroutines are asleep - deadlock!&#34;</span>)
}
</code></pre></div><p>如果处理器中存在等待的计时器，那么所有的 Goroutine 陷入休眠状态是合理的，不过如果不存在等待的计时器，运行时会直接报错并退出程序。</p><h3 id=运行计时器>运行计时器
<a class=anchor href=#%e8%bf%90%e8%a1%8c%e8%ae%a1%e6%97%b6%e5%99%a8>#</a></h3><p>在系统监控的循环中，我们通过 <a href=/golang/tree/runtime.nanotime><code>runtime.nanotime</code></a> 和 <a href=/golang/tree/runtime.timeSleepUntil><code>runtime.timeSleepUntil</code></a> 获取当前时间和计时器下一次需要唤醒的时间；当前调度器需要执行垃圾回收或者所有处理器都处于闲置状态时，如果没有需要触发的计时器，那么系统监控可以暂时陷入休眠：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sysmon</span>() {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>for</span> {
		<span style=color:#f92672>...</span>
		<span style=color:#a6e22e>now</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nanotime</span>()
		<span style=color:#a6e22e>next</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>timeSleepUntil</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>debug</span>.<span style=color:#a6e22e>schedtrace</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span>) <span style=color:#f92672>==</span> uint32(<span style=color:#a6e22e>gomaxprocs</span>)) {
			<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span>) <span style=color:#f92672>==</span> uint32(<span style=color:#a6e22e>gomaxprocs</span>) {
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> &gt; <span style=color:#a6e22e>now</span> {
					<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonwait</span>, <span style=color:#ae81ff>1</span>)
					<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
					<span style=color:#a6e22e>sleep</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>forcegcperiod</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
					<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span><span style=color:#f92672>-</span><span style=color:#a6e22e>now</span> &lt; <span style=color:#a6e22e>sleep</span> {
						<span style=color:#a6e22e>sleep</span> = <span style=color:#a6e22e>next</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>now</span>
					}
					<span style=color:#f92672>...</span>
					<span style=color:#a6e22e>notetsleep</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonnote</span>, <span style=color:#a6e22e>sleep</span>)
					<span style=color:#f92672>...</span>
					<span style=color:#a6e22e>now</span> = <span style=color:#a6e22e>nanotime</span>()
					<span style=color:#a6e22e>next</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>timeSleepUntil</span>()
					<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
					<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonwait</span>, <span style=color:#ae81ff>0</span>)
					<span style=color:#a6e22e>noteclear</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonnote</span>)
				}
				<span style=color:#a6e22e>idle</span> = <span style=color:#ae81ff>0</span>
				<span style=color:#a6e22e>delay</span> = <span style=color:#ae81ff>20</span>
			}
			<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
		}
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> &lt; <span style=color:#a6e22e>now</span> {
			<span style=color:#a6e22e>startm</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>)
		}
	}
}
</code></pre></div><p>休眠的时间会依据强制 GC 的周期 <code>forcegcperiod</code> 和计时器下次触发的时间确定，<a href=/golang/tree/runtime.notesleep><code>runtime.notesleep</code></a> 会使用信号量同步系统监控即将进入休眠的状态。当系统监控被唤醒之后，我们会重新计算当前时间和下一个计时器需要触发的时间、调用 <a href=/golang/tree/runtime.noteclear><code>runtime.noteclear</code></a> 通知系统监控被唤醒并重置休眠的间隔。</p><p>如果在这之后，我们发现下一个计时器需要触发的时间小于当前时间，这也说明所有的线程可能正在忙于运行 Goroutine，系统监控会启动新的线程来触发计时器，避免计时器的到期时间有较大的偏差。</p><h3 id=轮询网络>轮询网络
<a class=anchor href=#%e8%bd%ae%e8%af%a2%e7%bd%91%e7%bb%9c>#</a></h3><p>如果上一次轮询网络已经过去了 10ms，那么系统监控还会在循环中轮询网络，检查是否有待执行的文件描述符：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sysmon</span>() {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>for</span> {
		<span style=color:#f92672>...</span>
		<span style=color:#a6e22e>lastpoll</span> <span style=color:#f92672>:=</span> int64(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lastpoll</span>))
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>netpollinited</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>lastpoll</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>lastpoll</span><span style=color:#f92672>+</span><span style=color:#ae81ff>10</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1000</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1000</span> &lt; <span style=color:#a6e22e>now</span> {
			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lastpoll</span>, uint64(<span style=color:#a6e22e>lastpoll</span>), uint64(<span style=color:#a6e22e>now</span>))
			<span style=color:#a6e22e>list</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>netpoll</span>(<span style=color:#ae81ff>0</span>)
			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>empty</span>() {
				<span style=color:#a6e22e>incidlelocked</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
				<span style=color:#a6e22e>injectglist</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>list</span>)
				<span style=color:#a6e22e>incidlelocked</span>(<span style=color:#ae81ff>1</span>)
			}
		}
		<span style=color:#f92672>...</span>
	}
}
</code></pre></div><p>上述函数会非阻塞地调用 <a href=/golang/tree/runtime.netpoll><code>runtime.netpoll</code></a> 检查待执行的文件描述符并通过 <a href=/golang/tree/runtime.injectglist><code>runtime.injectglist</code></a> 将所有处于就绪状态的 Goroutine 加入全局运行队列中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>injectglist</span>(<span style=color:#a6e22e>glist</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gList</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>empty</span>() {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>n</span> = <span style=color:#ae81ff>0</span>; !<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>empty</span>(); <span style=color:#a6e22e>n</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>pop</span>()
		<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gwaiting</span>, <span style=color:#a6e22e>_Grunnable</span>)
		<span style=color:#a6e22e>globrunqput</span>(<span style=color:#a6e22e>gp</span>)
	}
	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
	<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>n</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>n</span><span style=color:#f92672>--</span> {
		<span style=color:#a6e22e>startm</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>)
	}
	<span style=color:#f92672>*</span><span style=color:#a6e22e>glist</span> = <span style=color:#a6e22e>gList</span>{}
}
</code></pre></div><p>该函数会将所有 Goroutine 的状态从 <code>_Gwaiting</code> 切换至 <code>_Grunnable</code> 并加入全局运行队列等待运行，如果当前程序中存在空闲的处理器，会通过 <a href=/golang/tree/runtime.startm><code>runtime.startm</code></a> 启动线程来执行这些任务。</p><h3 id=抢占处理器>抢占处理器
<a class=anchor href=#%e6%8a%a2%e5%8d%a0%e5%a4%84%e7%90%86%e5%99%a8>#</a></h3><p>系统监控会在循环中调用 <a href=/golang/tree/runtime.retake><code>runtime.retake</code></a> 抢占处于运行或者系统调用中的处理器，该函数会遍历运行时的全局处理器，每个处理器都存储了一个 <a href=/golang/tree/runtime.sysmontick><code>runtime.sysmontick</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sysmontick</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>schedtick</span>   <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>schedwhen</span>   <span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>syscalltick</span> <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>syscallwhen</span> <span style=color:#66d9ef>int64</span>
}
</code></pre></div><p>该结构体中的四个字段分别存储了处理器的调度次数、处理器上次调度时间、系统调用的次数以及系统调用的时间。<a href=/golang/tree/runtime.retake><code>runtime.retake</code></a> 的循环包含了两种不同的抢占逻辑：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>retake</span>(<span style=color:#a6e22e>now</span> <span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>uint32</span> {
	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>allp</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>allp</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#a6e22e>pd</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>sysmontick</span>
		<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>status</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_Prunning</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_Psyscall</span> {
			<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> int64(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>schedtick</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pd</span>.<span style=color:#a6e22e>schedwhen</span><span style=color:#f92672>+</span><span style=color:#a6e22e>forcePreemptNS</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>now</span> {
				<span style=color:#a6e22e>preemptone</span>(<span style=color:#a6e22e>_p_</span>)
			}
		}

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_Psyscall</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>runqempty</span>(<span style=color:#a6e22e>_p_</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmspinning</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span>) &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>pd</span>.<span style=color:#a6e22e>syscallwhen</span><span style=color:#f92672>+</span><span style=color:#ae81ff>10</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1000</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1000</span> &gt; <span style=color:#a6e22e>now</span> {
				<span style=color:#66d9ef>continue</span>
			}
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>_Pidle</span>) {
				<span style=color:#a6e22e>n</span><span style=color:#f92672>++</span>
				<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>syscalltick</span><span style=color:#f92672>++</span>
				<span style=color:#a6e22e>handoffp</span>(<span style=color:#a6e22e>_p_</span>)
			}
		}
	}
	<span style=color:#66d9ef>return</span> uint32(<span style=color:#a6e22e>n</span>)
}
</code></pre></div><ol><li>当处理器处于 <code>_Prunning</code> 或者 <code>_Psyscall</code> 状态时，如果上一次触发调度的时间已经过去了 10ms，我们会通过 <a href=/golang/tree/runtime.preemptone><code>runtime.preemptone</code></a> 抢占当前处理器；</li><li>当处理器处于 <code>_Psyscall</code> 状态时，在满足以下两种情况下会调用 <a href=/golang/tree/runtime.handoffp><code>runtime.handoffp</code></a> 让出处理器的使用权：<ol><li>当处理器的运行队列不为空或者不存在空闲处理器时<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>；</li><li>当系统调用时间超过了 10ms 时<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>；</li></ol></li></ol><p>系统监控通过在循环中抢占处理器来避免同一个 Goroutine 占用线程太长时间造成饥饿问题。</p><h3 id=垃圾回收>垃圾回收
<a class=anchor href=#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6>#</a></h3><p>在最后，系统监控还会决定是否需要触发强制垃圾回收，<a href=/golang/tree/runtime.sysmon><code>runtime.sysmon</code></a> 会构建 <a href=/golang/tree/runtime.gcTrigger><code>runtime.gcTrigger</code></a> 并调用 <a href=/golang/tree/runtime.gcTrigger.test><code>runtime.gcTrigger.test</code></a> 方法判断是否需要触发垃圾回收：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sysmon</span>() {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>for</span> {
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>gcTrigger</span>{<span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>gcTriggerTime</span>, <span style=color:#a6e22e>now</span>: <span style=color:#a6e22e>now</span>}); <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>test</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>idle</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>lock</span>)
			<span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>idle</span> = <span style=color:#ae81ff>0</span>
			<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>list</span> <span style=color:#a6e22e>gList</span>
			<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>g</span>)
			<span style=color:#a6e22e>injectglist</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>list</span>)
			<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>lock</span>)
		}
		<span style=color:#f92672>...</span>
	}
}
</code></pre></div><p>如果需要触发垃圾回收，我们会将用于垃圾回收的 Goroutine 加入全局队列，让调度器选择合适的处理器去执行。</p><h2 id=673-小结>6.7.3 小结
<a class=anchor href=#673-%e5%b0%8f%e7%bb%93>#</a></h2><p>运行时通过系统监控来触发线程的抢占、网络的轮询和垃圾回收，保证 Go 语言运行时的可用性。系统监控能够很好地解决尾延迟的问题，减少调度器调度 Goroutine 的饥饿问题并保证计时器在尽可能准确的时间触发。</p><p><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/ class=book-btn>上一节</a>
<a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Ian Lance Taylor. Apr 2019. &ldquo;runtime: initial scheduler changes for timers on P&rsquo;s&rdquo; <a href=https://github.com/golang/go/commit/06ac26279cb93140bb2b03bcef9a3300c166cade>https://github.com/golang/go/commit/06ac26279cb93140bb2b03bcef9a3300c166cade</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Dmitry Vyukov. Mar 2013. &ldquo;runtime: improved scheduler&rdquo; <a href=https://github.com/golang/go/commit/779c45a50700bda0f6ec98429720802e6c1624e8>https://github.com/golang/go/commit/779c45a50700bda0f6ec98429720802e6c1624e8</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Dmitry Vyukov. Jan 2014. &ldquo;runtime: tune P retake logic&rdquo; <a href=https://github.com/golang/go/commit/179d41feccc29260d1a16294647df218f1a6746a>https://github.com/golang/go/commit/179d41feccc29260d1a16294647df218f1a6746a</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-sysmon data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-sysmon",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#67-系统监控>6.7 系统监控</a><ul><li><a href=#671-设计原理>6.7.1 设计原理</a></li><li><a href=#672-监控循环>6.7.2 监控循环</a><ul><li><a href=#检查死锁>检查死锁</a></li><li><a href=#运行计时器>运行计时器</a></li><li><a href=#轮询网络>轮询网络</a></li><li><a href=#抢占处理器>抢占处理器</a></li><li><a href=#垃圾回收>垃圾回收</a></li></ul></li><li><a href=#673-小结>6.7.3 小结</a></li></ul></li></ul></nav></aside></main></body></html>