<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="6.5 调度器 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  Go 语言在并发编程方面有强大的能力，这离不开语言层面对并发编程的支持。本节会介绍 Go 语言运行时调度器的实现原理，其中包含调度器的设计与实现原理、演变过程以及与运行时调度相关的数据结构。
谈到 Go 语言调度器，我们绕不开的是操作系统、进程与线程这些概念，线程是操作系统调度时的最基本单元，而 Linux 在调度器并不区分进程和线程的调度，它们在不同操作系统上也有不同的实现，但是在大多数的实现中线程都属于进程：
图 6-25 进程和线程
多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。
虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间1，但是 Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销2。
图 6-26 线程与 Goroutine
Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。
6.5.1 设计原理 #  今天的 Go 语言调度器有着优异的性能，但是如果我们回头看 Go 语言的 0.x 版本的调度器会发现最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能，历史上几个不同版本的调度器引入了不同的改进，也存在着不同的缺陷:
 单线程调度器 · 0.x  只包含 40 多行代码； 程序中只能存在一个活跃线程，由 G-M 模型组成；   多线程调度器 · 1."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言调度器与 Goroutine 实现原理"><meta property="og:description" content="6.5 调度器 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  Go 语言在并发编程方面有强大的能力，这离不开语言层面对并发编程的支持。本节会介绍 Go 语言运行时调度器的实现原理，其中包含调度器的设计与实现原理、演变过程以及与运行时调度相关的数据结构。
谈到 Go 语言调度器，我们绕不开的是操作系统、进程与线程这些概念，线程是操作系统调度时的最基本单元，而 Linux 在调度器并不区分进程和线程的调度，它们在不同操作系统上也有不同的实现，但是在大多数的实现中线程都属于进程：
图 6-25 进程和线程
多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。
虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间1，但是 Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销2。
图 6-26 线程与 Goroutine
Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。
6.5.1 设计原理 #  今天的 Go 语言调度器有着优异的性能，但是如果我们回头看 Go 语言的 0.x 版本的调度器会发现最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能，历史上几个不同版本的调度器引入了不同的改进，也存在着不同的缺陷:
 单线程调度器 · 0.x  只包含 40 多行代码； 程序中只能存在一个活跃线程，由 G-M 模型组成；   多线程调度器 · 1."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/"><title>Go 语言调度器与 Goroutine 实现原理 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言调度器与 Goroutine 实现原理</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#65-调度器>6.5 调度器</a><ul><li><a href=#651-设计原理>6.5.1 设计原理</a><ul><li><a href=#单线程调度器>单线程调度器</a></li><li><a href=#多线程调度器>多线程调度器</a></li><li><a href=#任务窃取调度器>任务窃取调度器</a></li><li><a href=#抢占式调度器>抢占式调度器</a></li><li><a href=#非均匀内存访问调度器>非均匀内存访问调度器</a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#652-数据结构>6.5.2 数据结构</a><ul><li><a href=#g>G</a></li><li><a href=#m>M</a></li><li><a href=#p>P</a></li><li><a href=#小结-1>小结</a></li></ul></li><li><a href=#653-调度器启动>6.5.3 调度器启动</a></li><li><a href=#654-创建-goroutine>6.5.4 创建 Goroutine</a><ul><li><a href=#初始化结构体>初始化结构体</a></li><li><a href=#运行队列>运行队列</a></li><li><a href=#调度信息>调度信息</a></li></ul></li><li><a href=#655-调度循环>6.5.5 调度循环</a></li><li><a href=#656-触发调度>6.5.6 触发调度</a><ul><li><a href=#主动挂起>主动挂起</a></li><li><a href=#系统调用>系统调用</a></li><li><a href=#协作式调度>协作式调度</a></li></ul></li><li><a href=#657-线程管理>6.5.7 线程管理</a><ul><li><a href=#线程生命周期>线程生命周期</a></li></ul></li><li><a href=#658-小结>6.5.8 小结</a></li><li><a href=#659-延伸阅读>6.5.9 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=65-调度器>6.5 调度器
<a class=anchor href=#65-%e8%b0%83%e5%ba%a6%e5%99%a8>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>Go 语言在并发编程方面有强大的能力，这离不开语言层面对并发编程的支持。本节会介绍 Go 语言运行时调度器的实现原理，其中包含调度器的设计与实现原理、演变过程以及与运行时调度相关的数据结构。</p><p>谈到 Go 语言调度器，我们绕不开的是操作系统、进程与线程这些概念，线程是操作系统调度时的最基本单元，而 Linux 在调度器并不区分进程和线程的调度，它们在不同操作系统上也有不同的实现，但是在大多数的实现中线程都属于进程：</p><p><img src=https://img.draveness.me/2020-02-05-15808864354570-process-and-threads.png alt=process-and-threads></p><p><strong>图 6-25 进程和线程</strong></p><p>多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。</p><p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，但是 Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</p><p><img src=https://img.draveness.me/2020-02-05-15808864354586-goroutines-on-thread.png alt=goroutines-on-thread></p><p><strong>图 6-26 线程与 Goroutine</strong></p><p>Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。</p><h2 id=651-设计原理>6.5.1 设计原理
<a class=anchor href=#651-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>今天的 Go 语言调度器有着优异的性能，但是如果我们回头看 Go 语言的 0.x 版本的调度器会发现最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能，历史上几个不同版本的调度器引入了不同的改进，也存在着不同的缺陷:</p><ul><li>单线程调度器 · <a href=https://github.com/golang/go/blob/96824000ed89d13665f6f24ddc10b3bf812e7f47/src/runtime/proc.c>0.x</a><ul><li>只包含 40 多行代码；</li><li>程序中只能存在一个活跃线程，由 G-M 模型组成；</li></ul></li><li>多线程调度器 · <a href=https://github.com/golang/go/blob/go1.0.1/src/pkg/runtime/proc.c>1.0</a><ul><li>允许运行多线程的程序；</li><li>全局锁导致竞争严重；</li></ul></li><li>任务窃取调度器 · <a href=https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c>1.1</a><ul><li>引入了处理器 P，构成了目前的 <strong>G-M-P</strong> 模型；</li><li>在处理器 P 的基础上实现了基于<strong>工作窃取</strong>的调度器；</li><li>在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；</li><li>时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；</li></ul></li><li>抢占式调度器 · <a href=https://github.com/golang/go/blob/go1.2/src/pkg/runtime/proc.c>1.2</a> ~ 至今<ul><li>基于协作的抢占式调度器 - 1.2 ~ 1.13<ul><li>通过编译器在函数调用时插入<strong>抢占检查</strong>指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；</li><li>Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；</li></ul></li><li>基于信号的抢占式调度器 - 1.14 ~ 至今<ul><li>实现<strong>基于信号的真抢占式调度</strong>；</li><li>垃圾回收在扫描栈时会触发抢占调度；</li><li>抢占的时间点不够多，还不能覆盖全部的边缘情况；</li></ul></li></ul></li><li>非均匀存储访问调度器 · 提案<ul><li>对运行时的各种资源进行分区；</li><li>实现非常复杂，到今天还没有提上日程；</li></ul></li></ul><p>除了多线程、任务窃取和抢占式调度器之外，Go 语言社区目前还有一个非均匀存储访问（Non-uniform memory access，NUMA）调度器的提案。在这一节中，我们将依次介绍不同版本调度器的实现原理以及未来可能会实现的调度器提案。</p><h3 id=单线程调度器>单线程调度器
<a class=anchor href=#%e5%8d%95%e7%ba%bf%e7%a8%8b%e8%b0%83%e5%ba%a6%e5%99%a8>#</a></h3><p>0.x 版本调度器只包含表示 Goroutine 的 G 和表示线程的 M 两种结构，全局也只有一个线程。我们可以在 <a href=https://github.com/golang/go/commit/96824000ed89d13665f6f24ddc10b3bf812e7f47>clean up scheduler</a> 提交中找到单线程调度器的源代码，在这时 Go 语言的调度器还是由 C 语言实现的，调度函数 <a href=/golang/tree/runtime.scheduler:9682400><code>runtime.scheduler:9682400</code></a> 也只包含 40 多行代码 ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>scheduler</span>(<span style=color:#66d9ef>void</span>) {
	G<span style=color:#f92672>*</span> gp;
	lock(<span style=color:#f92672>&amp;</span>sched);

	<span style=color:#66d9ef>if</span>(gosave(<span style=color:#f92672>&amp;</span>m<span style=color:#f92672>-&gt;</span>sched)){
		lock(<span style=color:#f92672>&amp;</span>sched);
		gp <span style=color:#f92672>=</span> m<span style=color:#f92672>-&gt;</span>curg;
		<span style=color:#66d9ef>switch</span>(gp<span style=color:#f92672>-&gt;</span>status){
		<span style=color:#66d9ef>case</span> Grunnable:
		<span style=color:#66d9ef>case</span> Grunning:
			gp<span style=color:#f92672>-&gt;</span>status <span style=color:#f92672>=</span> Grunnable;
			gput(gp);
			<span style=color:#66d9ef>break</span>;
		...
		}
		notewakeup(<span style=color:#f92672>&amp;</span>gp<span style=color:#f92672>-&gt;</span>stopped);
	}

	gp <span style=color:#f92672>=</span> nextgandunlock();
	noteclear(<span style=color:#f92672>&amp;</span>gp<span style=color:#f92672>-&gt;</span>stopped);
	gp<span style=color:#f92672>-&gt;</span>status <span style=color:#f92672>=</span> Grunning;
	m<span style=color:#f92672>-&gt;</span>curg <span style=color:#f92672>=</span> gp;
	g <span style=color:#f92672>=</span> gp;
	gogo(<span style=color:#f92672>&amp;</span>gp<span style=color:#f92672>-&gt;</span>sched);
}
</code></pre></div><p>该函数会遵循如下的过程调度 Goroutine：</p><ol><li>获取调度器的全局锁；</li><li>调用 <a href=/golang/tree/runtime.gosave:9682400><code>runtime.gosave:9682400</code></a> 保存栈寄存器和程序计数器；</li><li>调用 <a href=/golang/tree/runtime.nextgandunlock:9682400><code>runtime.nextgandunlock:9682400</code></a> 获取下一个需要运行的 Goroutine 并解锁调度器；</li><li>修改全局线程 <code>m</code> 上要执行的 Goroutine；</li><li>调用 <a href=/golang/tree/runtime.gogo:9682400><code>runtime.gogo:9682400</code></a> 函数运行最新的 Goroutine；</li></ol><p>虽然这个单线程调度器的唯一优点就是<strong>能运行</strong>，但是这次提交已经包含了 G 和 M 两个重要的数据结构，也建立了 Go 语言调度器的框架。</p><h3 id=多线程调度器>多线程调度器
<a class=anchor href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e8%b0%83%e5%ba%a6%e5%99%a8>#</a></h3><p>Go 语言在 1.0 版本正式发布时就支持了多线程的调度器，与上一个版本几乎不可用的调度器相比，Go 语言团队在这一阶段实现了从不可用到可用的跨越。我们可以在 <a href=https://github.com/golang/go/blob/go1.0.1/src/pkg/runtime/proc.c><code>pkg/runtime/proc.c</code></a> 文件中找到 1.0.1 版本的调度器，多线程版本的调度函数 <a href=/golang/tree/runtime.schedule:go1.0.1><code>runtime.schedule:go1.0.1</code></a> 包含 70 多行代码，我们在这里保留了该函数的核心逻辑：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>schedule</span>(G <span style=color:#f92672>*</span>gp) {
	schedlock();
	<span style=color:#66d9ef>if</span>(gp <span style=color:#f92672>!=</span> nil) {
		gp<span style=color:#f92672>-&gt;</span>m <span style=color:#f92672>=</span> nil;
		uint32 v <span style=color:#f92672>=</span> runtime<span style=color:#960050;background-color:#1e0010>·</span>xadd(<span style=color:#f92672>&amp;</span>runtime<span style=color:#960050;background-color:#1e0010>·</span>sched.atomic, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span>mcpuShift);
		<span style=color:#66d9ef>if</span>(atomic_mcpu(v) <span style=color:#f92672>&gt;</span> maxgomaxprocs)
			runtime<span style=color:#960050;background-color:#1e0010>·</span>throw(<span style=color:#e6db74>&#34;negative mcpu in scheduler&#34;</span>);

		<span style=color:#66d9ef>switch</span>(gp<span style=color:#f92672>-&gt;</span>status){
		<span style=color:#66d9ef>case</span> Grunning:
			gp<span style=color:#f92672>-&gt;</span>status <span style=color:#f92672>=</span> Grunnable;
			gput(gp);
			<span style=color:#66d9ef>break</span>;
		<span style=color:#66d9ef>case</span> ...<span style=color:#f92672>:</span>
		}
	} <span style=color:#66d9ef>else</span> {
		...
	}
	gp <span style=color:#f92672>=</span> nextgandunlock();
	gp<span style=color:#f92672>-&gt;</span>status <span style=color:#f92672>=</span> Grunning;
	m<span style=color:#f92672>-&gt;</span>curg <span style=color:#f92672>=</span> gp;
	gp<span style=color:#f92672>-&gt;</span>m <span style=color:#f92672>=</span> m;
	runtime<span style=color:#960050;background-color:#1e0010>·</span>gogo(<span style=color:#f92672>&amp;</span>gp<span style=color:#f92672>-&gt;</span>sched, <span style=color:#ae81ff>0</span>);
}
</code></pre></div><p>整体的逻辑与单线程调度器没有太多区别，因为我们的程序中可能同时存在多个活跃线程，所以多线程调度器引入了 <code>GOMAXPROCS</code> 变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数。</p><p>多线程调度器的主要问题是调度时的锁竞争会严重浪费资源，<a href=http://golang.org/s/go11sched>Scalable Go Scheduler Design Doc</a> 中对调度器做的性能测试发现 14% 的时间都花费在 <a href=/golang/tree/runtime.futex:go1.0.1><code>runtime.futex:go1.0.1</code></a> 上<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，该调度器有以下问题需要解决：</p><ol><li>调度器和锁是全局资源，所有的调度状态都是中心化存储的，锁竞争问题严重；</li><li>线程需要经常互相传递可运行的 Goroutine，引入了大量的延迟；</li><li>每个线程都需要处理内存缓存，导致大量的内存占用并影响数据局部性；</li><li>系统调用频繁阻塞和解除阻塞正在运行的线程，增加了额外开销；</li></ol><p>这里的全局锁问题和 Linux 操作系统调度器在早期遇到的问题比较相似，解决的方案也都大同小异。</p><h3 id=任务窃取调度器>任务窃取调度器
<a class=anchor href=#%e4%bb%bb%e5%8a%a1%e7%aa%83%e5%8f%96%e8%b0%83%e5%ba%a6%e5%99%a8>#</a></h3><p>2012 年 Google 的工程师 Dmitry Vyukov 在 <a href=http://golang.org/s/go11sched>Scalable Go Scheduler Design Doc</a> 中指出了现有多线程调度器的问题并在多线程调度器上提出了两个改进的手段：</p><ol><li>在当前的 G-M 模型中引入了处理器 P，增加中间层；</li><li>在处理器 P 的基础上实现基于工作窃取的调度器；</li></ol><p>基于任务窃取的 Go 语言调度器使用了沿用至今的 G-M-P 模型，我们能在 <a href=https://github.com/golang/go/commit/779c45a50700bda0f6ec98429720802e6c1624e8>runtime: improved scheduler</a> 提交中找到任务窃取调度器刚被实现时的<a href=https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c>源代码</a>，调度器的 <a href=/golang/tree/runtime.schedule:779c45a><code>runtime.schedule:779c45a</code></a> 在这个版本的调度器中反而更简单了：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>static</span> <span style=color:#a6e22e>void</span> <span style=color:#a6e22e>schedule</span>(<span style=color:#a6e22e>void</span>) {
    <span style=color:#a6e22e>G</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gp</span>;
 <span style=color:#a6e22e>top</span>:
    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>gcwaiting</span>) {
        <span style=color:#a6e22e>gcstopm</span>();
        <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>top</span>;
    }

    <span style=color:#a6e22e>gp</span> = <span style=color:#a6e22e>runqget</span>(<span style=color:#a6e22e>m</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>p</span>);
    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span>)
        <span style=color:#a6e22e>gp</span> = <span style=color:#a6e22e>findrunnable</span>();

    <span style=color:#f92672>...</span>

    <span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>);
}
</code></pre></div><ol><li>如果当前运行时在等待垃圾回收，调用 <a href=/golang/tree/runtime.gcstopm:779c45a><code>runtime.gcstopm:779c45a</code></a> 函数；</li><li>调用 <a href=/golang/tree/runtime.runqget:779c45a><code>runtime.runqget:779c45a</code></a> 和 <a href=/golang/tree/runtime.findrunnable:779c45a><code>runtime.findrunnable:779c45a</code></a> 从本地或者全局的运行队列中获取待执行的 Goroutine；</li><li>调用 <a href=/golang/tree/runtime.execute:779c45a><code>runtime.execute:779c45a</code></a> 在当前线程 M 上运行 Goroutine；</li></ol><p>当前处理器本地的运行队列中不包含 Goroutine 时，调用 <a href=/golang/tree/runtime.findrunnable:779c45a><code>runtime.findrunnable:779c45a</code></a> 会触发工作窃取，从其它的处理器的队列中随机获取一些 Goroutine。</p><p>运行时 G-M-P 模型中引入的处理器 P 是线程和 Goroutine 的中间层，我们从它的结构体中就能看到处理器与 M 和 G 的关系：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> P {
	Lock;

	uint32	status;
	P<span style=color:#f92672>*</span>	link;
	uint32	tick;
	M<span style=color:#f92672>*</span>	m;
	MCache<span style=color:#f92672>*</span>	mcache;

	G<span style=color:#f92672>**</span>	runq;
	int32	runqhead;
	int32	runqtail;
	int32	runqsize;

	G<span style=color:#f92672>*</span>	gfree;
	int32	gfreecnt;
};
</code></pre></div><p>处理器持有一个由可运行的 Goroutine 组成的环形的运行队列 <code>runq</code>，还反向持有一个线程。调度器在调度时会从处理器的队列中选择队列头的 Goroutine 放到线程 M 上执行。如下所示的图片展示了 Go 语言中的线程 M、处理器 P 和 Goroutine 的关系。</p><p><img src=https://img.draveness.me/2020-02-02-15805792666151-golang-gmp.png alt=golang-gmp></p><p><strong>图 6-27 - G-M-P 模型</strong></p><p>基于工作窃取的多线程调度器将每一个线程绑定到了独立的 CPU 上，这些线程会被不同处理器管理，不同的处理器通过工作窃取对任务进行再分配实现任务的平衡，也能提升调度器和 Go 语言程序的整体性能，今天所有的 Go 语言服务都受益于这一改动。</p><h3 id=抢占式调度器>抢占式调度器
<a class=anchor href=#%e6%8a%a2%e5%8d%a0%e5%bc%8f%e8%b0%83%e5%ba%a6%e5%99%a8>#</a></h3><p>对 Go 语言并发模型的修改提升了调度器的性能，但是 1.1 版本中的调度器仍然不支持抢占式调度，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度。Go 语言的调度器在 1.2 版本<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>中引入基于协作的抢占式调度解决下面的问题<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>：</p><ul><li>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿；</li><li>垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>，导致整个程序无法工作；</li></ul><p>1.2 版本的抢占式调度虽然能够缓解这个问题，但是它实现的抢占式调度是基于协作的，在之后很长的一段时间里 Go 语言的调度器都有一些无法被抢占的边缘情况，例如：for 循环或者垃圾回收长时间占用线程，这些问题中的一部分直到 1.14 才被基于信号的抢占式调度解决。</p><h4 id=基于协作的抢占式调度>基于协作的抢占式调度
<a class=anchor href=#%e5%9f%ba%e4%ba%8e%e5%8d%8f%e4%bd%9c%e7%9a%84%e6%8a%a2%e5%8d%a0%e5%bc%8f%e8%b0%83%e5%ba%a6>#</a></h4><p>我们可以在 <a href=https://github.com/golang/go/blob/go1.2/src/pkg/runtime/proc.c><code>pkg/runtime/proc.c</code></a> 文件中找到引入基于协作的抢占式调度后的调度器。Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。Go 团队通过以下的多个提交实现该特性：</p><ul><li><a href=f5becf4233bd12506cbfcb9cbc04b5968ac11ae0>runtime: add stackguard0 to G</a><ul><li>为 Goroutine 引入 <code>stackguard0</code> 字段，该字段被设置成 <code>StackPreempt</code> 意味着当前 Goroutine 发出了抢占请求；</li></ul></li><li><a href=https://github.com/golang/go/commit/354ec5166668cae9be899c82e20c38b32ae3b867>runtime: introduce preemption function (not used for now)</a><ul><li>引入抢占函数 <a href=/golang/tree/runtime.preemptone:1e112cd><code>runtime.preemptone:1e112cd</code></a> 和 <a href=/golang/tree/runtime.preemptall:1e112cd><code>runtime.preemptall:1e112cd</code></a>，这两个函数会改变 Goroutine 的 <code>stackguard0</code> 字段发出抢占请求；</li><li>定义抢占请求 <code>StackPreempt</code>；</li></ul></li><li><a href=https://github.com/golang/go/commit/1e112cd59f560129f4dca5e9af7c3cbc445850b6>runtime: preempt goroutines for GC</a><ul><li>在 <a href=/golang/tree/runtime.stoptheworld:1e112cd><code>runtime.stoptheworld:1e112cd</code></a> 中调用 <a href=/golang/tree/runtime.preemptall:1e112cd><code>runtime.preemptall:1e112cd</code></a> 设置所有处理器上正在运行的 Goroutine 的 <code>stackguard0</code> 为 <code>StackPreempt</code>；</li><li>在 <a href=/golang/tree/runtime.newstack:1e112cd><code>runtime.newstack:1e112cd</code></a> 中增加抢占的代码，当 <code>stackguard0</code> 等于 <code>StackPreempt</code> 时触发调度器抢占让出线程；</li></ul></li><li><a href=https://github.com/golang/go/commit/bc31bcccd3b94ec8dd324e523c4c7ae9180b937f>runtime: preempt long-running goroutines</a><ul><li>在系统监控中，如果一个 Goroutine 的运行时间超过 10ms，就会调用 <a href=/golang/tree/runtime.retake:1e112cd><code>runtime.retake:1e112cd</code></a> 和 <a href=/golang/tree/runtime.preemptone:1e112cd><code>runtime.preemptone:1e112cd</code></a>；</li></ul></li><li><a href=https://github.com/golang/go/commit/f9066fe1c0a7181242f77d8534e0b6e112c982a9>runtime: more reliable preemption</a><ul><li>修复 Goroutine 因为周期性执行非阻塞的 CGO 或者系统调用不会被抢占的问题；</li></ul></li></ul><p>上面的多个提交实现了抢占式调度，但是还缺少最关键的一个环节 — 编译器如何在函数调用前插入函数，我们能在非常古老的提交 <a href=https://github.com/golang/go/commit/7343e03c433ebb0c302ed97bf832ad3bd3170de6>runtime: stack growth adjustments, cleanup</a> 中找到编译器插入函数的雏形，最新版本的 Go 语言会通过 <a href=/golang/tree/cmd/internal/obj/x86.stacksplit><code>cmd/internal/obj/x86.stacksplit</code></a> 插入 <a href=/golang/tree/runtime.morestack><code>runtime.morestack</code></a>，该函数可能会调用 <a href=/golang/tree/runtime.newstack><code>runtime.newstack</code></a> 触发抢占。从上面的多个提交中，我们能归纳出基于协作的抢占式调度的工作原理：</p><ol><li>编译器会在调用函数前插入 <a href=/golang/tree/runtime.morestack><code>runtime.morestack</code></a>；</li><li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 <code>StackPreempt</code>；</li><li>当发生函数调用时，可能会执行编译器插入的 <a href=/golang/tree/runtime.morestack><code>runtime.morestack</code></a>，它调用的 <a href=/golang/tree/runtime.newstack><code>runtime.newstack</code></a> 会检查 Goroutine 的 <code>stackguard0</code> 字段是否为 <code>StackPreempt</code>；</li><li>如果 <code>stackguard0</code> 是 <code>StackPreempt</code>，就会触发抢占让出当前线程；</li></ol><p>这种实现方式虽然增加了运行时的复杂度，但是实现相对简单，也没有带来过多的额外开销，总体来看还是比较成功的实现，也在 Go 语言中使用了 10 几个版本。因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种<strong>协作式的抢占式调度</strong>。</p><h4 id=基于信号的抢占式调度>基于信号的抢占式调度
<a class=anchor href=#%e5%9f%ba%e4%ba%8e%e4%bf%a1%e5%8f%b7%e7%9a%84%e6%8a%a2%e5%8d%a0%e5%bc%8f%e8%b0%83%e5%ba%a6>#</a></h4><p>基于协作的抢占式调度虽然实现巧妙，但是并不完备，我们能在 <a href=https://github.com/golang/go/issues/24543>runtime: non-cooperative goroutine preemption</a> 中找到一些遗留问题：</p><ul><li><a href=https://github.com/golang/go/issues/10958>runtime: tight loops should be preemptible #10958</a></li><li><a href=https://github.com/golang/go/issues/17174>An empty for{} will block large slice allocation in another goroutine, even with GOMAXPROCS > 1 ? #17174</a></li><li><a href=https://github.com/golang/go/issues/15442>runtime: tight loop hangs process completely after some time #15442</a></li><li>&mldr;</li></ul><p>Go 语言在 1.14 版本中实现了非协作的抢占式调度，在实现的过程中我们重构已有的逻辑并为 Goroutine 增加新的状态和字段来支持抢占。Go 团队通过下面的一系列提交实现了这一功能，我们可以按时间顺序分析相关提交理解它的工作原理：</p><ul><li><a href=https://github.com/golang/go/commit/3f834114ab617eb7b414cb12e7ca8085b5fe3a5c>runtime: add general suspendG/resumeG</a><ul><li>挂起 Goroutine 的过程是在垃圾回收的栈扫描时完成的，我们通过 <a href=/golang/tree/runtime.suspendG><code>runtime.suspendG</code></a> 和 <a href=/golang/tree/runtime.resumeG><code>runtime.resumeG</code></a> 两个函数重构栈扫描这一过程；</li><li>调用 <a href=/golang/tree/runtime.suspendG><code>runtime.suspendG</code></a> 时会将处于运行状态的 Goroutine 的 <code>preemptStop</code> 标记成 <code>true</code>；</li><li>调用 <a href=/golang/tree/runtime.preemptPark><code>runtime.preemptPark</code></a> 可以挂起当前 Goroutine、将其状态更新成 <code>_Gpreempted</code> 并触发调度器的重新调度，该函数能够交出线程控制权；</li></ul></li><li><a href=https://github.com/golang/go/commit/a3ffb0d9eb948409c0898c6b1803401c9bc68ed4>runtime: asynchronous preemption function for x86</a><ul><li>在 x86 架构上增加异步抢占的函数 <a href=/golang/tree/runtime.asyncPreempt><code>runtime.asyncPreempt</code></a> 和 <a href=/golang/tree/runtime.asyncPreempt2><code>runtime.asyncPreempt2</code></a>；</li></ul></li><li><a href=https://github.com/golang/go/commit/62e53b79227dafc6afcd92240c89acb8c0e1dd56>runtime: use signals to preempt Gs for suspendG</a><ul><li>支持通过向线程发送信号的方式暂停运行的 Goroutine；</li><li>在 <a href=/golang/tree/runtime.sighandler><code>runtime.sighandler</code></a> 函数中注册 <code>SIGURG</code> 信号的处理函数 <a href=/golang/tree/runtime.doSigPreempt><code>runtime.doSigPreempt</code></a>；</li><li>实现 <a href=/golang/tree/runtime.preemptM><code>runtime.preemptM</code></a>，它可以通过 <code>SIGURG</code> 信号向线程发送抢占请求；</li></ul></li><li><a href=https://github.com/golang/go/commit/177a36a5dc29854489825e8113ecb2cbb7070690>runtime: implement async scheduler preemption</a><ul><li>修改 <a href=/golang/tree/runtime.preemptone><code>runtime.preemptone</code></a> 函数的实现，加入异步抢占的逻辑；</li></ul></li></ul><p>目前的抢占式调度也只会在垃圾回收扫描任务时触发，我们可以梳理一下上述代码实现的抢占式调度过程：</p><ol><li>程序启动时，在 <a href=/golang/tree/runtime.sighandler><code>runtime.sighandler</code></a> 中注册 <code>SIGURG</code> 信号的处理函数 <a href=/golang/tree/runtime.doSigPreempt><code>runtime.doSigPreempt</code></a>；</li><li>在触发垃圾回收的栈扫描时会调用 <a href=/golang/tree/runtime.suspendG><code>runtime.suspendG</code></a> 挂起 Goroutine，该函数会执行下面的逻辑：<ol><li>将 <code>_Grunning</code> 状态的 Goroutine 标记成可以被抢占，即将 <code>preemptStop</code> 设置成 <code>true</code>；</li><li>调用 <a href=/golang/tree/runtime.preemptM><code>runtime.preemptM</code></a> 触发抢占；</li></ol></li><li><a href=/golang/tree/runtime.preemptM><code>runtime.preemptM</code></a> 会调用 <a href=/golang/tree/runtime.signalM><code>runtime.signalM</code></a> 向线程发送信号 <code>SIGURG</code>；</li><li>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 <a href=/golang/tree/runtime.doSigPreempt><code>runtime.doSigPreempt</code></a>；</li><li><a href=/golang/tree/runtime.doSigPreempt><code>runtime.doSigPreempt</code></a> 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 <a href=/golang/tree/runtime.sigctxt.pushCall><code>runtime.sigctxt.pushCall</code></a>；</li><li><a href=/golang/tree/runtime.sigctxt.pushCall><code>runtime.sigctxt.pushCall</code></a> 会修改寄存器并在程序回到用户态时执行 <a href=/golang/tree/runtime.asyncPreempt><code>runtime.asyncPreempt</code></a>；</li><li>汇编指令 <a href=/golang/tree/runtime.asyncPreempt><code>runtime.asyncPreempt</code></a> 会调用运行时函数 <a href=/golang/tree/runtime.asyncPreempt2><code>runtime.asyncPreempt2</code></a>；</li><li><a href=/golang/tree/runtime.asyncPreempt2><code>runtime.asyncPreempt2</code></a> 会调用 <a href=/golang/tree/runtime.preemptPark><code>runtime.preemptPark</code></a>；</li><li><a href=/golang/tree/runtime.preemptPark><code>runtime.preemptPark</code></a> 会修改当前 Goroutine 的状态到 <code>_Gpreempted</code> 并调用 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；</li></ol><p>上述 9 个步骤展示了基于信号的抢占式调度的执行过程。除了分析抢占的过程之外，我们还需要讨论一下抢占信号的选择，提案根据以下的四个原因选择 <code>SIGURG</code> 作为触发异步抢占的信号<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>；</p><ol><li>该信号需要被调试器透传；</li><li>该信号不会被内部的 libc 库使用并拦截；</li><li>该信号可以随意出现并且不触发任何后果；</li><li>我们需要处理多个平台上的不同信号；</li></ol><p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决所有问题，但是这种真抢占式调度是调度器走向完备的开始，相信在未来我们会在更多的地方触发抢占。</p><h3 id=非均匀内存访问调度器>非均匀内存访问调度器
<a class=anchor href=#%e9%9d%9e%e5%9d%87%e5%8c%80%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae%e8%b0%83%e5%ba%a6%e5%99%a8>#</a></h3><p>非均匀内存访问（Non-uniform memory access，NUMA）调度器现在只是 Go 语言的提案<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>。该提案的原理就是通过拆分全局资源，让各个处理器能够就近获取，减少锁竞争并增加数据的局部性。</p><p>在目前的运行时中，线程、处理器、网络轮询器、运行队列、全局内存分配器状态、内存分配缓存和垃圾收集器都是全局资源。运行时没有保证本地化，也不清楚系统的拓扑结构，部分结构可以提供一定的局部性，但是从全局来看没有这种保证。</p><p><img src=https://img.draveness.me/2020-02-02-15805792666185-go-numa-scheduler-architecture.png alt=go-numa-scheduler-architecture></p><p><strong>图 6-28 - Go 语言 NUMA 调度器</strong></p><p>如上图所示，堆栈、全局运行队列和线程池会按照 NUMA 节点进行分区，网络轮询器和计时器会由单独的处理器持有。这种方式虽然能够利用局部性提高调度器的性能，但是本身的实现过于复杂，所以 Go 语言团队还没有着手实现这一提案。</p><h3 id=小结>小结
<a class=anchor href=#%e5%b0%8f%e7%bb%93>#</a></h3><p>Go 语言的调度器在最初的几个版本中迅速迭代，但是从 1.2 版本之后调度器就没有太多的变化，直到 1.14 版本引入了真正的抢占式调度才解决了自 1.2 以来一直存在的问题。在可预见的未来，Go 语言的调度器还会进一步演进，增加触发抢占式调度的时间点以减少存在的边缘情况。</p><h2 id=652-数据结构>6.5.2 数据结构
<a class=anchor href=#652-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p>相信各位读者已经对 Go 语言调度相关的数据结构已经非常熟悉了，但是我们在一些还是要回顾一下运行时调度器的三个重要组成部分 — 线程 M、Goroutine G 和处理器 P：</p><p><img src=https://img.draveness.me/2020-02-05-15808864354595-golang-scheduler.png alt=golang-scheduler></p><p><strong>图 6-29 Go 语言调度器</strong></p><ol><li>G — 表示 Goroutine，它是一个待执行的任务；</li><li>M — 表示操作系统的线程，它由操作系统的调度器调度和管理；</li><li>P — 表示处理器，它可以被看做运行在线程上的本地调度器；</li></ol><p>我们会在这一节中分别介绍不同的结构体，详细介绍它们的作用、数据结构以及在运行期间可能处于的状态。</p><h3 id=g>G
<a class=anchor href=#g>#</a></h3><p>Goroutine 是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p><p>Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。</p><p>Goroutine 在 Go 语言运行时使用私有结构体 <a href=/golang/tree/runtime.g><code>runtime.g</code></a> 表示。这个私有结构体非常复杂，总共包含 40 多个用于表示各种状态的成员变量，这里也不会介绍所有的字段，仅会挑选其中的一部分，首先是与栈相关的两个字段：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>stack</span>       <span style=color:#a6e22e>stack</span>
	<span style=color:#a6e22e>stackguard0</span> <span style=color:#66d9ef>uintptr</span>
}
</code></pre></div><p>其中 <code>stack</code> 字段描述了当前 Goroutine 的栈内存范围 [stack.lo, stack.hi)，另一个字段 <code>stackguard0</code> 可以用于调度器抢占式调度。除了 <code>stackguard0</code> 之外，Goroutine 中还包含另外三个与抢占密切相关的字段：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>preempt</span>       <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// 抢占信号
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>preemptStop</span>   <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// 抢占时将状态修改成 `_Gpreempted`
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>preemptShrink</span> <span style=color:#66d9ef>bool</span> <span style=color:#75715e>// 在同步安全点收缩栈
</span><span style=color:#75715e></span>}
</code></pre></div><p>Goroutine 与我们在前面章节提到的 <code>defer</code> 和 <code>panic</code> 也有千丝万缕的联系，每一个 Goroutine 上都持有两个分别存储 <code>defer</code> 和 <code>panic</code> 对应结构体的链表：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>_panic</span>       <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span> <span style=color:#75715e>// 最内侧的 panic 结构体
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>_defer</span>       <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// 最内侧的延迟函数结构体
</span><span style=color:#75715e></span>}
</code></pre></div><p>最后，我们再节选一些作者认为比较有趣或者重要的字段：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>m</span>              <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>
	<span style=color:#a6e22e>sched</span>          <span style=color:#a6e22e>gobuf</span>
	<span style=color:#a6e22e>atomicstatus</span>   <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>goid</span>           <span style=color:#66d9ef>int64</span>
}
</code></pre></div><ul><li><code>m</code> — 当前 Goroutine 占用的线程，可能为空；</li><li><code>atomicstatus</code> — Goroutine 的状态；</li><li><code>sched</code> — 存储 Goroutine 的调度相关的数据；</li><li><code>goid</code> — Goroutine 的 ID，该字段对开发者不可见，Go 团队认为引入 ID 会让部分 Goroutine 变得更特殊，从而限制语言的并发能力<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>；</li></ul><p>上述四个字段中，我们需要展开介绍 <code>sched</code> 字段的 <a href=/golang/tree/runtime.gobuf><code>runtime.gobuf</code></a> 结构体中包含哪些内容：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>gobuf</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>sp</span>   <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>pc</span>   <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>g</span>    <span style=color:#a6e22e>guintptr</span>
	<span style=color:#a6e22e>ret</span>  <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>Uintreg</span>
	<span style=color:#f92672>...</span>
}
</code></pre></div><ul><li><code>sp</code> — 栈指针；</li><li><code>pc</code> — 程序计数器；</li><li><code>g</code> — 持有 <a href=/golang/tree/runtime.gobuf><code>runtime.gobuf</code></a> 的 Goroutine；</li><li><code>ret</code> — 系统调用的返回值；</li></ul><p>这些内容会在调度器保存或者恢复上下文的时候用到，其中的栈指针和程序计数器会用来存储或者恢复寄存器中的值，改变程序即将执行的代码。</p><p>结构体 <a href=/golang/tree/runtime.g><code>runtime.g</code></a> 的 <code>atomicstatus</code> 字段存储了当前 Goroutine 的状态。除了几个已经不被使用的以及与 GC 相关的状态之外，Goroutine 可能处于以下 9 种状态：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>_Gidle</code></td><td>刚刚被分配并且还没有被初始化</td></tr><tr><td><code>_Grunnable</code></td><td>没有执行代码，没有栈的所有权，存储在运行队列中</td></tr><tr><td><code>_Grunning</code></td><td>可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</td></tr><tr><td><code>_Gsyscall</code></td><td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</td></tr><tr><td><code>_Gwaiting</code></td><td>由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</td></tr><tr><td><code>_Gdead</code></td><td>没有被使用，没有执行代码，可能有分配的栈</td></tr><tr><td><code>_Gcopystack</code></td><td>栈正在被拷贝，没有执行代码，不在运行队列上</td></tr><tr><td><code>_Gpreempted</code></td><td>由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</td></tr><tr><td><code>_Gscan</code></td><td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td></tr></tbody></table><p><strong>表 7-3 Goroutine 的状态</strong></p><p>上述状态中比较常见是 <code>_Grunnable</code>、<code>_Grunning</code>、<code>_Gsyscall</code>、<code>_Gwaiting</code> 和 <code>_Gpreempted</code> 五个状态，这里会重点介绍这几个状态。Goroutine 的状态迁移是个复杂的过程，触发 Goroutine 状态迁移的方法也很多，在这里我们也没有办法介绍全部的迁移路线，只会从中选择一些介绍。</p><p><img src=https://img.draveness.me/2020-02-05-15808864354603-goroutine-status.png alt=goroutine-status></p><p><strong>图 6-30 Goroutine 的状态</strong></p><p>虽然 Goroutine 在运行时中定义的状态非常多而且复杂，但是我们可以将这些不同的状态聚合成三种：等待中、可运行、运行中，运行期间会在这三种状态来回切换：</p><ul><li>等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code> 和 <code>_Gpreempted</code> 几个状态；</li><li>可运行：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 <code>_Grunnable</code>；</li><li>运行中：Goroutine 正在某个线程上运行，即 <code>_Grunning</code>；</li></ul><p><img src=https://img.draveness.me/2020-02-05-15808864354615-golang-goroutine-state-transition.png alt=golang-goroutine-state-transition></p><p><strong>图 6-31 Goroutine 的常见状态迁移</strong></p><p>上图展示了 Goroutine 状态迁移的常见路径，其中包括创建 Goroutine 到 Goroutine 被执行、触发系统调用或者抢占式调度器的状态迁移过程。</p><h3 id=m>M
<a class=anchor href=#m>#</a></h3><p>Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行。</p><p>在默认情况下，运行时会将 <code>GOMAXPROCS</code> 设置成当前机器的核数，我们也可以在程序中使用 <a href=/golang/tree/runtime.GOMAXPROCS><code>runtime.GOMAXPROCS</code></a> 来改变最大的活跃线程数。</p><p><img src=https://img.draveness.me/2020-02-05-15808864354634-scheduler-m-and-thread.png alt=scheduler-m-and-thread></p><p><strong>图 6-32 CPU 和活跃线程</strong></p><p>在默认情况下，一个四核机器会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的 <a href=/golang/tree/runtime.m><code>runtime.m</code></a> 结构体。</p><p>在大多数情况下，我们都会使用 Go 的默认设置，也就是线程数等于 CPU 数，默认的设置不会频繁触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少很多额外开销。</p><p>Go 语言会使用私有结构体 <a href=/golang/tree/runtime.m><code>runtime.m</code></a> 表示操作系统线程，这个结构体也包含了几十个字段，这里先来了解几个与 Goroutine 相关的字段：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>g0</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
	<span style=color:#a6e22e>curg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>其中 g0 是持有调度栈的 Goroutine，<code>curg</code> 是在当前线程上运行的用户 Goroutine，这也是操作系统线程唯一关心的两个 Goroutine。</p><p><img src=https://img.draveness.me/2020-02-05-15808864354644-g0-and-g.png alt=g0-and-g></p><p><strong>图 6-33 调度 Goroutine 和运行 Goroutine</strong></p><p>g0 是一个运行时中比较特殊的 Goroutine，它会深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行。在后面的小节中，我们会经常看到 g0 的身影。</p><p><a href=/golang/tree/runtime.m><code>runtime.m</code></a> 结构体中还存在三个与处理器相关的字段，它们分别表示正在运行代码的处理器 <code>p</code>、暂存的处理器 <code>nextp</code> 和执行系统调用之前使用线程的处理器 <code>oldp</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>p</span>             <span style=color:#a6e22e>puintptr</span>
	<span style=color:#a6e22e>nextp</span>         <span style=color:#a6e22e>puintptr</span>
	<span style=color:#a6e22e>oldp</span>          <span style=color:#a6e22e>puintptr</span>
}
</code></pre></div><p>除了在上面介绍的字段之外，<a href=/golang/tree/runtime.m><code>runtime.m</code></a> 还包含大量与线程状态、锁、调度、系统调用有关的字段，我们会在分析调度过程时详细介绍它们。</p><h3 id=p>P
<a class=anchor href=#p>#</a></h3><p>调度器中的处理器 P 是线程和 Goroutine 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时让出计算资源，提高线程的利用率。</p><p>因为调度器在启动时就会创建 <code>GOMAXPROCS</code> 个处理器，所以 Go 语言程序的处理器数量一定会等于 <code>GOMAXPROCS</code>，这些处理器会绑定到不同的内核线程上。</p><p><a href=/golang/tree/runtime.p><code>runtime.p</code></a> 是处理器的运行时表示，作为调度器的内部实现，它包含的字段也非常多，其中包括与性能追踪、垃圾回收和计时器相关的字段，这些字段也非常重要，但是在这里就不展示了，我们主要关注处理器中的线程和运行队列：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>p</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>m</span>           <span style=color:#a6e22e>muintptr</span>

	<span style=color:#a6e22e>runqhead</span> <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>runqtail</span> <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>runq</span>     [<span style=color:#ae81ff>256</span>]<span style=color:#a6e22e>guintptr</span>
	<span style=color:#a6e22e>runnext</span> <span style=color:#a6e22e>guintptr</span>
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>反向存储的线程维护着线程与处理器之间的关系，而 <code>runqhead</code>、<code>runqtail</code> 和 <code>runq</code> 三个字段表示处理器持有的运行队列，其中存储着待执行的 Goroutine 列表，<code>runnext</code> 中是线程下一个需要执行的 Goroutine。</p><p><a href=/golang/tree/runtime.p><code>runtime.p</code></a> 结构体中的状态 <code>status</code> 字段会是以下五种中的一种：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>_Pidle</code></td><td>处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</td></tr><tr><td><code>_Prunning</code></td><td>被线程 M 持有，并且正在执行用户代码或者调度器</td></tr><tr><td><code>_Psyscall</code></td><td>没有执行用户代码，当前线程陷入系统调用</td></tr><tr><td><code>_Pgcstop</code></td><td>被线程 M 持有，当前处理器由于垃圾回收被停止</td></tr><tr><td><code>_Pdead</code></td><td>当前处理器已经不被使用</td></tr></tbody></table><p><strong>表 7-4 处理器的状态</strong></p><p>通过分析处理器 P 的状态，我们能够对处理器的工作过程有一些简单理解，例如处理器在执行用户代码时会处于 <code>_Prunning</code> 状态，在当前线程执行 I/O 操作时会陷入 <code>_Psyscall</code> 状态。</p><h3 id=小结-1>小结
<a class=anchor href=#%e5%b0%8f%e7%bb%93-1>#</a></h3><p>我们在这一小节简单介绍了 Go 语言调度器中常见的数据结构，包括线程 M、处理器 P 和 Goroutine G，它们在 Go 语言运行时中分别使用不同的私有结构体表示，我们在下面会深入分析 Go 语言调度器的实现原理。</p><h2 id=653-调度器启动>6.5.3 调度器启动
<a class=anchor href=#653-%e8%b0%83%e5%ba%a6%e5%99%a8%e5%90%af%e5%8a%a8>#</a></h2><p>调度器的启动过程是我们平时比较难以接触的过程，不过作为程序启动前的准备工作，理解调度器的启动过程对我们理解调度器的实现原理很有帮助，运行时通过 <a href=/golang/tree/runtime.schedinit><code>runtime.schedinit</code></a> 初始化调度器：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>schedinit</span>() {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#f92672>...</span>

	<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>maxmcount</span> = <span style=color:#ae81ff>10000</span>

	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lastpoll</span> = uint64(<span style=color:#a6e22e>nanotime</span>())
	<span style=color:#a6e22e>procs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ncpu</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atoi32</span>(<span style=color:#a6e22e>gogetenv</span>(<span style=color:#e6db74>&#34;GOMAXPROCS&#34;</span>)); <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>procs</span> = <span style=color:#a6e22e>n</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>procresize</span>(<span style=color:#a6e22e>procs</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unknown runnable goroutine during bootstrap&#34;</span>)
	}
}
</code></pre></div><p>在调度器初始函数执行的过程中会将 <code>maxmcount</code> 设置成 10000，这也就是一个 Go 语言程序能够创建的最大线程数，虽然最多可以创建 10000 个线程，但是可以同时运行的线程还是由 <code>GOMAXPROCS</code> 变量控制。</p><p>我们从环境变量 <code>GOMAXPROCS</code> 获取了程序能够同时运行的最大处理器数之后就会调用 <a href=/golang/tree/runtime.procresize><code>runtime.procresize</code></a> 更新程序中处理器的数量，在这时整个程序不会执行任何用户 Goroutine，调度器也会进入锁定状态，<a href=/golang/tree/runtime.procresize><code>runtime.procresize</code></a> 的执行过程如下：</p><ol><li>如果全局变量 <code>allp</code> 切片中的处理器数量少于期望数量，会对切片进行扩容；</li><li>使用 <code>new</code> 创建新的处理器结构体并调用 <a href=/golang/tree/runtime.p.init><code>runtime.p.init</code></a> 初始化刚刚扩容的处理器；</li><li>通过指针将线程 m0 和处理器 <code>allp[0]</code> 绑定到一起；</li><li>调用 <a href=/golang/tree/runtime.p.destroy><code>runtime.p.destroy</code></a> 释放不再使用的处理器结构；</li><li>通过截断改变全局变量 <code>allp</code> 的长度保证与期望处理器数量相等；</li><li>将除 <code>allp[0]</code> 之外的处理器 P 全部设置成 <code>_Pidle</code> 并加入到全局的空闲队列中；</li></ol><p>调用 <a href=/golang/tree/runtime.procresize><code>runtime.procresize</code></a> 是调度器启动的最后一步，在这一步过后调度器会完成相应数量处理器的启动，等待用户创建运行新的 Goroutine 并为 Goroutine 调度处理器资源。</p><h2 id=654-创建-goroutine>6.5.4 创建 Goroutine
<a class=anchor href=#654-%e5%88%9b%e5%bb%ba-goroutine>#</a></h2><p>想要启动一个新的 Goroutine 来执行任务时，我们需要使用 Go 语言的 <code>go</code> 关键字，编译器会通过 <a href=/golang/tree/cmd/compile/internal/gc.state.stmt><code>cmd/compile/internal/gc.state.stmt</code></a> 和 <a href=/golang/tree/cmd/compile/internal/gc.state.call><code>cmd/compile/internal/gc.state.call</code></a> 两个方法将该关键字转换成 <a href=/golang/tree/runtime.newproc><code>runtime.newproc</code></a> 函数调用：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>k</span> <span style=color:#a6e22e>callKind</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>callDeferStack</span> {
		<span style=color:#f92672>...</span>
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#66d9ef>switch</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>callGo</span>:
			<span style=color:#a6e22e>call</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>newValue1A</span>(<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>OpStaticCall</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>TypeMem</span>, <span style=color:#a6e22e>newproc</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mem</span>())
		<span style=color:#66d9ef>default</span>:
		}
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p><a href=/golang/tree/runtime.newproc><code>runtime.newproc</code></a> 的入参是参数大小和表示函数的指针 <code>funcval</code>，它会获取 Goroutine 以及调用方的程序计数器，然后调用 <a href=/golang/tree/runtime.newproc1><code>runtime.newproc1</code></a> 函数获取新的 Goroutine 结构体、将其加入处理器的运行队列并在满足条件时调用 <a href=/golang/tree/runtime.wakep><code>runtime.wakep</code></a> 唤醒新的处理执行 Goroutine：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newproc</span>(<span style=color:#a6e22e>siz</span> <span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>funcval</span>) {
	<span style=color:#a6e22e>argp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>fn</span>), <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PtrSize</span>)
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
	<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
		<span style=color:#a6e22e>newg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newproc1</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>argp</span>, <span style=color:#a6e22e>siz</span>, <span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>pc</span>)

		<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>()
		<span style=color:#a6e22e>runqput</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#a6e22e>newg</span>, <span style=color:#66d9ef>true</span>)

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mainStarted</span> {
			<span style=color:#a6e22e>wakep</span>()
		}
	})
}
</code></pre></div><p><a href=/golang/tree/runtime.newproc1><code>runtime.newproc1</code></a> 会根据传入参数初始化一个 <code>g</code> 结构体，我们可以将该函数分成以下几个部分介绍它的实现：</p><ol><li>获取或者创建新的 Goroutine 结构体；</li><li>将传入的参数移到 Goroutine 的栈上；</li><li>更新 Goroutine 调度相关的属性；</li></ol><p>首先是 Goroutine 结构体的创建过程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newproc1</span>(<span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>funcval</span>, <span style=color:#a6e22e>argp</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>narg</span> <span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>callergp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span> {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>siz</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>narg</span>
	<span style=color:#a6e22e>siz</span> = (<span style=color:#a6e22e>siz</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>&amp;^</span> <span style=color:#ae81ff>7</span>

	<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>()
	<span style=color:#a6e22e>newg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gfget</span>(<span style=color:#a6e22e>_p_</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>newg</span> = <span style=color:#a6e22e>malg</span>(<span style=color:#a6e22e>_StackMin</span>)
		<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>newg</span>, <span style=color:#a6e22e>_Gidle</span>, <span style=color:#a6e22e>_Gdead</span>)
		<span style=color:#a6e22e>allgadd</span>(<span style=color:#a6e22e>newg</span>)
	}
	<span style=color:#f92672>...</span>
</code></pre></div><p>上述代码会先从处理器的 <code>gFree</code> 列表中查找空闲的 Goroutine，如果不存在空闲的 Goroutine，会通过 <a href=/golang/tree/runtime.malg><code>runtime.malg</code></a> 创建一个栈大小足够的新结构体。</p><p>接下来，我们会调用 <a href=/golang/tree/runtime.memmove><code>runtime.memmove</code></a> 将 <code>fn</code> 函数的所有参数拷贝到栈上，<code>argp</code> 和 <code>narg</code> 分别是参数的内存空间和大小，我们在该方法中会将参数对应的内存空间整块拷贝到栈上：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>totalSize</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>4</span><span style=color:#f92672>*</span><span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>RegSize</span> <span style=color:#f92672>+</span> uintptr(<span style=color:#a6e22e>siz</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>MinFrameSize</span>
	<span style=color:#a6e22e>totalSize</span> <span style=color:#f92672>+=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>totalSize</span> <span style=color:#f92672>&amp;</span> (<span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>SpAlign</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>totalSize</span>
	<span style=color:#a6e22e>spArg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sp</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>narg</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>spArg</span>), <span style=color:#a6e22e>argp</span>, uintptr(<span style=color:#a6e22e>narg</span>))
	}
	<span style=color:#f92672>...</span>
</code></pre></div><p>拷贝了栈上的参数之后，<a href=/golang/tree/runtime.newproc1><code>runtime.newproc1</code></a> 会设置新的 Goroutine 结构体的参数，包括栈指针、程序计数器并更新其状态到 <code>_Grunnable</code> 并返回：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>memclrNoHeapPointers</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>sched</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>sched</span>))
	<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>sp</span>
	<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>stktopsp</span> = <span style=color:#a6e22e>sp</span>
	<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>pc</span> = <span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>goexit</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PCQuantum</span>
	<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>guintptr</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>newg</span>))
	<span style=color:#a6e22e>gostartcallfn</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>sched</span>, <span style=color:#a6e22e>fn</span>)
	<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>gopc</span> = <span style=color:#a6e22e>callerpc</span>
	<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>startpc</span> = <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>fn</span>
	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>newg</span>, <span style=color:#a6e22e>_Gdead</span>, <span style=color:#a6e22e>_Grunnable</span>)
	<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>goid</span> = int64(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>goidcache</span>)
	<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>goidcache</span><span style=color:#f92672>++</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newg</span>
}
</code></pre></div><p>我们在分析 <a href=/golang/tree/runtime.newproc><code>runtime.newproc</code></a> 的过程中，保留了主干省略了用于获取结构体的 <a href=/golang/tree/runtime.gfget><code>runtime.gfget</code></a>、<a href=/golang/tree/runtime.malg><code>runtime.malg</code></a>、将 Goroutine 加入运行队列的 <a href=/golang/tree/runtime.runqput><code>runtime.runqput</code></a> 以及设置调度信息的过程，下面会依次分析这些函数。</p><h3 id=初始化结构体>初始化结构体
<a class=anchor href=#%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84%e4%bd%93>#</a></h3><p><a href=/golang/tree/runtime.gfget><code>runtime.gfget</code></a> 通过两种不同的方式获取新的 <a href=/golang/tree/runtime.g><code>runtime.g</code></a>：</p><ol><li>从 Goroutine 所在处理器的 <code>gFree</code> 列表或者调度器的 <code>sched.gFree</code> 列表中获取 <a href=/golang/tree/runtime.g><code>runtime.g</code></a>；</li><li>调用 <a href=/golang/tree/runtime.malg><code>runtime.malg</code></a> 生成一个新的 <a href=/golang/tree/runtime.g><code>runtime.g</code></a> 并将结构体追加到全局的 Goroutine 列表 <code>allgs</code> 中。</li></ol><p><img src=https://img.draveness.me/golang-newproc-get-goroutine.png alt=golang-newproc-get-goroutine></p><p><strong>图 6-34 获取 Goroutine 结构体的三种方法</strong></p><p><a href=/golang/tree/runtime.gfget><code>runtime.gfget</code></a> 中包含两部分逻辑，它会根据处理器中 <code>gFree</code> 列表中 Goroutine 的数量做出不同的决策：</p><ol><li>当处理器的 Goroutine 列表为空时，会将调度器持有的空闲 Goroutine 转移到当前处理器上，直到 <code>gFree</code> 列表中的 Goroutine 数量达到 32；</li><li>当处理器的 Goroutine 数量充足时，会从列表头部返回一个新的 Goroutine；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gfget</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span> {
<span style=color:#a6e22e>retry</span>:
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>gFree</span>.<span style=color:#a6e22e>empty</span>() <span style=color:#f92672>&amp;&amp;</span> (!<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gFree</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>empty</span>() <span style=color:#f92672>||</span> !<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gFree</span>.<span style=color:#a6e22e>noStack</span>.<span style=color:#a6e22e>empty</span>()) {
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>gFree</span>.<span style=color:#a6e22e>n</span> &lt; <span style=color:#ae81ff>32</span> {
			<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gFree</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>pop</span>()
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>gp</span> = <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gFree</span>.<span style=color:#a6e22e>noStack</span>.<span style=color:#a6e22e>pop</span>()
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
					<span style=color:#66d9ef>break</span>
				}
			}
			<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>gFree</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>)
		}
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retry</span>
	}
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>gFree</span>.<span style=color:#a6e22e>pop</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>
}
</code></pre></div><p>当调度器的 <code>gFree</code> 和处理器的 <code>gFree</code> 列表都不存在结构体时，运行时会调用 <a href=/golang/tree/runtime.malg><code>runtime.malg</code></a> 初始化新的 <a href=/golang/tree/runtime.g><code>runtime.g</code></a> 结构，如果申请的堆栈大小大于 0，这里会通过 <a href=/golang/tree/runtime.stackalloc><code>runtime.stackalloc</code></a> 分配 2KB 的栈空间：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>malg</span>(<span style=color:#a6e22e>stacksize</span> <span style=color:#66d9ef>int32</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span> {
	<span style=color:#a6e22e>newg</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>g</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>stacksize</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>stacksize</span> = <span style=color:#a6e22e>round2</span>(<span style=color:#a6e22e>_StackSystem</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>stacksize</span>)
		<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>stackalloc</span>(uint32(<span style=color:#a6e22e>stacksize</span>))
		<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_StackGuard</span>
		<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>stackguard1</span> = ^uintptr(<span style=color:#ae81ff>0</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newg</span>
}
</code></pre></div><p><a href=/golang/tree/runtime.malg><code>runtime.malg</code></a> 返回的 Goroutine 会存储到全局变量 <code>allgs</code> 中。</p><p>简单总结一下，<a href=/golang/tree/runtime.newproc1><code>runtime.newproc1</code></a> 会从处理器或者调度器的缓存中获取新的结构体，也可以调用 <a href=/golang/tree/runtime.malg><code>runtime.malg</code></a> 函数创建。</p><h3 id=运行队列>运行队列
<a class=anchor href=#%e8%bf%90%e8%a1%8c%e9%98%9f%e5%88%97>#</a></h3><p><a href=/golang/tree/runtime.runqput><code>runtime.runqput</code></a> 会将 Goroutine 放到运行队列上，这既可能是全局的运行队列，也可能是处理器本地的运行队列：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runqput</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>next</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> {
	<span style=color:#a6e22e>retryNext</span>:
		<span style=color:#a6e22e>oldnext</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runnext</span>
		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runnext</span>.<span style=color:#a6e22e>cas</span>(<span style=color:#a6e22e>oldnext</span>, <span style=color:#a6e22e>guintptr</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>gp</span>))) {
			<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retryNext</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>oldnext</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>return</span>
		}
		<span style=color:#a6e22e>gp</span> = <span style=color:#a6e22e>oldnext</span>.<span style=color:#a6e22e>ptr</span>()
	}
<span style=color:#a6e22e>retry</span>:
	<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadAcq</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqhead</span>)
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqtail</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span><span style=color:#f92672>-</span><span style=color:#a6e22e>h</span> &lt; uint32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>)) {
		<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>[<span style=color:#a6e22e>t</span><span style=color:#f92672>%</span>uint32(len(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runq</span>))].<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>gp</span>)
		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>StoreRel</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>runqtail</span>, <span style=color:#a6e22e>t</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>runqputslow</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>t</span>) {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>retry</span>
}
</code></pre></div><ol><li>当 <code>next</code> 为 <code>true</code> 时，将 Goroutine 设置到处理器的 <code>runnext</code> 作为下一个处理器执行的任务；</li><li>当 <code>next</code> 为 <code>false</code> 并且本地运行队列还有剩余空间时，将 Goroutine 加入处理器持有的本地运行队列；</li><li>当处理器的本地运行队列已经没有剩余空间时就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 通过 <a href=/golang/tree/runtime.runqputslow><code>runtime.runqputslow</code></a> 添加到调度器持有的全局运行队列上；</li></ol><p>处理器本地的运行队列是一个使用数组构成的环形链表，它最多可以存储 256 个待执行任务。</p><p><img src=https://img.draveness.me/2020-02-05-15808864354654-golang-runnable-queue.png alt=golang-runnable-queue></p><p><strong>图 6-35 全局和本地运行队列</strong></p><p>简单总结一下，Go 语言有两个运行队列，其中一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列。</p><h3 id=调度信息>调度信息
<a class=anchor href=#%e8%b0%83%e5%ba%a6%e4%bf%a1%e6%81%af>#</a></h3><p>运行时创建 Goroutine 时会通过下面的代码设置调度相关的信息，前两行代码会分别将程序计数器和 Goroutine 设置成 <a href=/golang/tree/runtime.goexit><code>runtime.goexit</code></a> 和新创建 Goroutine 运行的函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>pc</span> = <span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>goexit</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PCQuantum</span>
	<span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>guintptr</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>newg</span>))
	<span style=color:#a6e22e>gostartcallfn</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newg</span>.<span style=color:#a6e22e>sched</span>, <span style=color:#a6e22e>fn</span>)
	<span style=color:#f92672>...</span>
</code></pre></div><p>上述调度信息 <code>sched</code> 不是初始化后的 Goroutine 的最终结果，它还需要经过 <a href=/golang/tree/runtime.gostartcallfn><code>runtime.gostartcallfn</code></a> 和 <a href=/golang/tree/runtime.gostartcall><code>runtime.gostartcall</code></a> 的处理：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gostartcallfn</span>(<span style=color:#a6e22e>gobuf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gobuf</span>, <span style=color:#a6e22e>fv</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>funcval</span>) {
	<span style=color:#a6e22e>gostartcall</span>(<span style=color:#a6e22e>gobuf</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>fv</span>.<span style=color:#a6e22e>fn</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>fv</span>))
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gostartcall</span>(<span style=color:#a6e22e>buf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gobuf</span>, <span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>ctxt</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) {
	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>sp</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>RegSize</span> &gt; <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PtrSize</span> {
		<span style=color:#a6e22e>sp</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PtrSize</span>
		<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sp</span>)) = <span style=color:#ae81ff>0</span>
	}
	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PtrSize</span>
	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sp</span>)) = <span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>pc</span>
	<span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>sp</span>
	<span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>pc</span> = uintptr(<span style=color:#a6e22e>fn</span>)
	<span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>ctxt</span> = <span style=color:#a6e22e>ctxt</span>
}
</code></pre></div><p>调度信息的 <code>sp</code> 中存储了 <a href=/golang/tree/runtime.goexit><code>runtime.goexit</code></a> 函数的程序计数器，而 <code>pc</code> 中存储了传入函数的程序计数器。因为 <code>pc</code> 寄存器的作用就是存储程序接下来运行的位置，所以 <code>pc</code> 的使用比较好理解，但是 <code>sp</code> 中存储的 <a href=/golang/tree/runtime.goexit><code>runtime.goexit</code></a> 会让人感到困惑，我们需要配合下面的调度循环来理解它的作用。</p><h2 id=655-调度循环>6.5.5 调度循环
<a class=anchor href=#655-%e8%b0%83%e5%ba%a6%e5%be%aa%e7%8e%af>#</a></h2><p>调度器启动之后，Go 语言运行时会调用 <a href=/golang/tree/runtime.mstart><code>runtime.mstart</code></a> 以及 <a href=/golang/tree/runtime.mstart1><code>runtime.mstart1</code></a>，前者会初始化 g0 的 <code>stackguard0</code> 和 <code>stackguard1</code> 字段，后者会初始化线程并调用 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 进入调度循环：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>schedule</span>() {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()

<span style=color:#a6e22e>top</span>:
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inheritTime</span> <span style=color:#66d9ef>bool</span>

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>schedtick</span><span style=color:#f92672>%</span><span style=color:#ae81ff>61</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
			<span style=color:#a6e22e>gp</span> = <span style=color:#a6e22e>globrunqget</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>(), <span style=color:#ae81ff>1</span>)
			<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
		}
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span> = <span style=color:#a6e22e>runqget</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>())
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span> = <span style=color:#a6e22e>findrunnable</span>()
	}

	<span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span>)
}
</code></pre></div><p><a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 函数会从下面几个地方查找待执行的 Goroutine：</p><ol><li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 <code>schedtick</code> 保证有一定几率会从全局的运行队列中查找对应的 Goroutine；</li><li>从处理器本地的运行队列中查找待执行的 Goroutine；</li><li>如果前两种方法都没有找到 Goroutine，会通过 <a href=/golang/tree/runtime.findrunnable><code>runtime.findrunnable</code></a> 进行阻塞地查找 Goroutine；</li></ol><p><a href=/golang/tree/runtime.findrunnable><code>runtime.findrunnable</code></a> 的实现非常复杂，这个 300 多行的函数通过以下的过程获取可运行的 Goroutine：</p><ol><li>从本地运行队列、全局运行队列中查找；</li><li>从网络轮询器中查找是否有 Goroutine 等待运行；</li><li>通过 <a href=/golang/tree/runtime.runqsteal><code>runtime.runqsteal</code></a> 尝试从其他随机的处理器中窃取待运行的 Goroutine，该函数还可能窃取处理器的计时器；</li></ol><p>因为函数的实现过于复杂，上述的执行过程是经过简化的，总而言之，当前函数一定会返回一个可执行的 Goroutine，如果当前不存在就会阻塞等待。</p><p>接下来由 <a href=/golang/tree/runtime.execute><code>runtime.execute</code></a> 执行获取的 Goroutine，做好准备工作后，它会通过 <a href=/golang/tree/runtime.gogo><code>runtime.gogo</code></a> 将 Goroutine 调度到当前线程上。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>inheritTime</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()

	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span> = <span style=color:#a6e22e>gp</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span> = <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>
	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunnable</span>, <span style=color:#a6e22e>_Grunning</span>)
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waitsince</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>preempt</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_StackGuard</span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>inheritTime</span> {
		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>schedtick</span><span style=color:#f92672>++</span>
	}

	<span style=color:#a6e22e>gogo</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>)
}
</code></pre></div><p><a href=/golang/tree/runtime.gogo><code>runtime.gogo</code></a> 在不同处理器架构上的实现都不同，但是也都大同小异，下面是该函数在 386 架构上的实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>gogo</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>8</span><span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>
	<span style=color:#a6e22e>MOVL</span> <span style=color:#a6e22e>buf</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>BX</span>     <span style=color:#75715e>// 获取调度信息
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVL</span> <span style=color:#a6e22e>gobuf_g</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>DX</span>
	<span style=color:#a6e22e>MOVL</span> <span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>DX</span>), <span style=color:#a6e22e>CX</span>         <span style=color:#75715e>// 保证 Goroutine 不为空
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>get_tls</span>(<span style=color:#a6e22e>CX</span>)
	<span style=color:#a6e22e>MOVL</span> <span style=color:#a6e22e>DX</span>, <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>CX</span>)
	<span style=color:#a6e22e>MOVL</span> <span style=color:#a6e22e>gobuf_sp</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>SP</span>  <span style=color:#75715e>// 将 runtime.goexit 函数的 PC 恢复到 SP 中
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVL</span> <span style=color:#a6e22e>gobuf_ret</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>AX</span>
	<span style=color:#a6e22e>MOVL</span> <span style=color:#a6e22e>gobuf_ctxt</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>DX</span>
	<span style=color:#a6e22e>MOVL</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>gobuf_sp</span>(<span style=color:#a6e22e>BX</span>)
	<span style=color:#a6e22e>MOVL</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>gobuf_ret</span>(<span style=color:#a6e22e>BX</span>)
	<span style=color:#a6e22e>MOVL</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>gobuf_ctxt</span>(<span style=color:#a6e22e>BX</span>)
	<span style=color:#a6e22e>MOVL</span> <span style=color:#a6e22e>gobuf_pc</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>BX</span>  <span style=color:#75715e>// 获取待执行函数的程序计数器
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>JMP</span>  <span style=color:#a6e22e>BX</span>                <span style=color:#75715e>// 开始执行
</span></code></pre></div><p>它从 <a href=/golang/tree/runtime.gobuf><code>runtime.gobuf</code></a> 中取出了 <a href=/golang/tree/runtime.goexit><code>runtime.goexit</code></a> 的程序计数器和待执行函数的程序计数器，其中：</p><ul><li><a href=/golang/tree/runtime.goexit><code>runtime.goexit</code></a> 的程序计数器被放到了栈 SP 上；</li><li>待执行函数的程序计数器被放到了寄存器 BX 上；</li></ul><p>在函数调用一节中，我们曾经介绍过 Go 语言的调用惯例，正常的函数调用都会使用 <code>CALL</code> 指令，该指令会将调用方的返回地址加入栈寄存器 SP 中，然后跳转到目标函数；当目标函数返回后，会从栈中查找调用的地址并跳转回调用方继续执行剩下的代码。</p><p><a href=/golang/tree/runtime.gogo><code>runtime.gogo</code></a> 就利用了 Go 语言的调用惯例成功模拟这一调用过程，通过以下几个关键指令模拟 <code>CALL</code> 的过程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>MOVL</span> <span style=color:#a6e22e>gobuf_sp</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>SP</span>  <span style=color:#75715e>// 将 runtime.goexit 函数的 PC 恢复到 SP 中
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVL</span> <span style=color:#a6e22e>gobuf_pc</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>BX</span>  <span style=color:#75715e>// 获取待执行函数的程序计数器
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>JMP</span>  <span style=color:#a6e22e>BX</span>                <span style=color:#75715e>// 开始执行
</span></code></pre></div><p><img src=https://img.draveness.me/2020-02-05-15808864354661-golang-gogo-stack.png alt=golang-gogo-stack></p><p><strong>图 6-36 runtime.gogo 栈内存</strong></p><p>上图展示了调用 <code>JMP</code> 指令后的栈中数据，当 Goroutine 中运行的函数返回时，程序会跳转到 <a href=/golang/tree/runtime.goexit><code>runtime.goexit</code></a> 所在位置执行该函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>goexit</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>goexit1</span>(<span style=color:#a6e22e>SB</span>)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>goexit1</span>() {
	<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>goexit0</span>)
}
</code></pre></div><p>经过一系列复杂的函数调用，我们最终在当前线程的 g0 的栈上调用 <a href=/golang/tree/runtime.goexit0><code>runtime.goexit0</code></a> 函数，该函数会将 Goroutine 转换会 <code>_Gdead</code> 状态、清理其中的字段、移除 Goroutine 和线程的关联并调用 <a href=/golang/tree/runtime.gfput><code>runtime.gfput</code></a> 重新加入处理器的 Goroutine 空闲列表 <code>gFree</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>goexit0</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()

	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gdead</span>)
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>labels</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>timer</span> = <span style=color:#66d9ef>nil</span>

	<span style=color:#a6e22e>dropg</span>()
	<span style=color:#a6e22e>gfput</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>(), <span style=color:#a6e22e>gp</span>)
	<span style=color:#a6e22e>schedule</span>()
}
</code></pre></div><p>在最后 <a href=/golang/tree/runtime.goexit0><code>runtime.goexit0</code></a> 会重新调用 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 触发新一轮的 Goroutine 调度，Go 语言中的运行时调度循环会从 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 开始，最终又回到 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a>，我们可以认为调度循环永远都不会返回。</p><p><img src=https://img.draveness.me/2020-02-05-15808864354669-golang-scheduler-loop.png alt=golang-scheduler-loop></p><p><strong>图 6-36 调度循环</strong></p><p>这里介绍的是 Goroutine 正常执行并退出的逻辑，实际情况会复杂得多，多数情况下 Goroutine 在执行的过程中都会经历协作式或者抢占式调度，它会让出线程的使用权等待调度器的唤醒。</p><h2 id=656-触发调度>6.5.6 触发调度
<a class=anchor href=#656-%e8%a7%a6%e5%8f%91%e8%b0%83%e5%ba%a6>#</a></h2><p>这里简单介绍下所有触发调度的时间点，因为调度器的 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 会重新选择 Goroutine 在线程上执行，所以我们只要找到该函数的调用方就能找到所有触发调度的时间点，经过分析和整理，我们能得到如下的树形结构：</p><p><img src=https://img.draveness.me/2020-02-05-15808864354679-schedule-points.png alt=schedule-points></p><p><strong>图 6-37 调度时间点</strong></p><p>除了上图中可能触发调度的时间点，运行时还会在线程启动 <a href=/golang/tree/runtime.mstart><code>runtime.mstart</code></a> 和 Goroutine 执行结束 <a href=/golang/tree/runtime.goexit0><code>runtime.goexit0</code></a> 触发调度。我们在这里会重点介绍运行时触发调度的几个路径：</p><ul><li>主动挂起 — <a href=/golang/tree/runtime.gopark><code>runtime.gopark</code></a> -> <a href=/golang/tree/runtime.park_m><code>runtime.park_m</code></a></li><li>系统调用 — <a href=/golang/tree/runtime.exitsyscall><code>runtime.exitsyscall</code></a> -> <a href=/golang/tree/runtime.exitsyscall0><code>runtime.exitsyscall0</code></a></li><li>协作式调度 — <a href=/golang/tree/runtime.Gosched><code>runtime.Gosched</code></a> -> <a href=/golang/tree/runtime.gosched_m><code>runtime.gosched_m</code></a> -> <a href=/golang/tree/runtime.goschedImpl><code>runtime.goschedImpl</code></a></li><li>系统监控 — <a href=/golang/tree/runtime.sysmon><code>runtime.sysmon</code></a> -> <a href=/golang/tree/runtime.retake><code>runtime.retake</code></a> -> <a href=/golang/tree/runtime.preemptone><code>runtime.preemptone</code></a></li></ul><p>我们在这里介绍的调度时间点不是将线程的运行权直接交给其他任务，而是通过调度器的 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 重新调度。</p><h3 id=主动挂起>主动挂起
<a class=anchor href=#%e4%b8%bb%e5%8a%a8%e6%8c%82%e8%b5%b7>#</a></h3><p><a href=/golang/tree/runtime.gopark><code>runtime.gopark</code></a> 是触发调度最常见的方法，该函数会将当前 Goroutine 暂停，被暂停的任务不会放回运行队列，我们来分析该函数的实现原理：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>reason</span> <span style=color:#a6e22e>waitReason</span>, <span style=color:#a6e22e>traceEv</span> <span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquirem</span>()
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>curg</span>
	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waitlock</span> = <span style=color:#a6e22e>lock</span>
	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waitunlockf</span> = <span style=color:#a6e22e>unlockf</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waitreason</span> = <span style=color:#a6e22e>reason</span>
	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waittraceev</span> = <span style=color:#a6e22e>traceEv</span>
	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waittraceskip</span> = <span style=color:#a6e22e>traceskip</span>
	<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>)
	<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>park_m</span>)
}
</code></pre></div><p>上述会通过 <a href=/golang/tree/runtime.mcall><code>runtime.mcall</code></a> 切换到 g0 的栈上调用 <a href=/golang/tree/runtime.park_m><code>runtime.park_m</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>park_m</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()

	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gwaiting</span>)
	<span style=color:#a6e22e>dropg</span>()

	<span style=color:#a6e22e>schedule</span>()
}
</code></pre></div><p><a href=/golang/tree/runtime.park_m><code>runtime.park_m</code></a> 会将当前 Goroutine 的状态从 <code>_Grunning</code> 切换至 <code>_Gwaiting</code>，调用 <a href=/golang/tree/runtime.dropg><code>runtime.dropg</code></a> 移除线程和 Goroutine 之间的关联，在这之后就可以调用 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 触发新一轮的调度了。</p><p>当 Goroutine 等待的特定条件满足后，运行时会调用 <a href=/golang/tree/runtime.goready><code>runtime.goready</code></a> 将因为调用 <a href=/golang/tree/runtime.gopark><code>runtime.gopark</code></a> 而陷入休眠的 Goroutine 唤醒。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
		<span style=color:#a6e22e>ready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>traceskip</span>, <span style=color:#66d9ef>true</span>)
	})
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ready</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>next</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()

	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gwaiting</span>, <span style=color:#a6e22e>_Grunnable</span>)
	<span style=color:#a6e22e>runqput</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>(), <span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>next</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmspinning</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>wakep</span>()
	}
}
</code></pre></div><p><a href=/golang/tree/runtime.ready><code>runtime.ready</code></a> 会将准备就绪的 Goroutine 的状态切换至 <code>_Grunnable</code> 并将其加入处理器的运行队列中，等待调度器的调度。</p><h3 id=系统调用>系统调用
<a class=anchor href=#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8>#</a></h3><p>系统调用也会触发运行时调度器的调度，为了处理特殊的系统调用，我们甚至在 Goroutine 中加入了 <code>_Gsyscall</code> 状态，Go 语言通过 <a href=/golang/tree/syscall.Syscall><code>syscall.Syscall</code></a> 和 <a href=/golang/tree/syscall.RawSyscall><code>syscall.RawSyscall</code></a> 等使用汇编语言编写的方法封装操作系统提供的所有系统调用，其中 <a href=/golang/tree/syscall.Syscall><code>syscall.Syscall</code></a> 的实现如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>define</span> <span style=color:#a6e22e>INVOKE_SYSCALL</span>	<span style=color:#a6e22e>INT</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x80</span>

<span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>Syscall</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>28</span>
	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>entersyscall</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>INVOKE_SYSCALL</span>
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>exitsyscall</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#a6e22e>RET</span>
<span style=color:#a6e22e>ok</span>:
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>exitsyscall</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#a6e22e>RET</span>
</code></pre></div><p>在通过汇编指令 <code>INVOKE_SYSCALL</code> 执行系统调用前后，上述函数会调用运行时的 <a href=/golang/tree/runtime.entersyscall><code>runtime.entersyscall</code></a> 和 <a href=/golang/tree/runtime.exitsyscall><code>runtime.exitsyscall</code></a>，正是这一层包装能够让我们在陷入系统调用前触发运行时的准备和清理工作。</p><p><img src=https://img.draveness.me/2020-02-05-15808864354688-golang-syscall-and-rawsyscall.png alt=golang-syscall-and-rawsyscal></p><p><strong>图 6-38 Go 语言系统调用</strong></p><p>不过出于性能的考虑，如果这次系统调用不需要运行时参与，就会使用 <a href=/golang/tree/syscall.RawSyscall><code>syscall.RawSyscall</code></a> 简化这一过程，不再调用运行时函数。<a href=https://gist.github.com/draveness/50c88883f30fa99d548cf1163c98aeb1>这里</a>包含 Go 语言对 Linux 386 架构上不同系统调用的分类，我们会按需决定是否需要运行时的参与。</p><table><thead><tr><th style=text-align:center>系统调用</th><th style=text-align:center>类型</th></tr></thead><tbody><tr><td style=text-align:center>SYS_TIME</td><td style=text-align:center>RawSyscall</td></tr><tr><td style=text-align:center>SYS_GETTIMEOFDAY</td><td style=text-align:center>RawSyscall</td></tr><tr><td style=text-align:center>SYS_SETRLIMIT</td><td style=text-align:center>RawSyscall</td></tr><tr><td style=text-align:center>SYS_GETRLIMIT</td><td style=text-align:center>RawSyscall</td></tr><tr><td style=text-align:center>SYS_EPOLL_WAIT</td><td style=text-align:center>Syscall</td></tr><tr><td style=text-align:center>&mldr;</td><td style=text-align:center>&mldr;</td></tr></tbody></table><p><strong>表 7-5 系统调用的类型</strong></p><p>由于直接进行系统调用会阻塞当前的线程，所以只有可以立刻返回的系统调用才可能会被设置成 <code>RawSyscall</code> 类型，例如：<code>SYS_EPOLL_CREATE</code>、<code>SYS_EPOLL_WAIT</code>（超时时间为 0）、<code>SYS_TIME</code> 等。</p><p>正常的系统调用过程相对比较复杂，下面将分别介绍进入系统调用前的准备工作和系统调用结束后的收尾工作。</p><h4 id=准备工作>准备工作
<a class=anchor href=#%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c>#</a></h4><p><a href=/golang/tree/runtime.entersyscall><code>runtime.entersyscall</code></a> 会在获取当前程序计数器和栈位置之后调用 <a href=/golang/tree/runtime.reentersyscall><code>runtime.reentersyscall</code></a>，它会完成 Goroutine 进入系统调用前的准备工作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reentersyscall</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span> <span style=color:#66d9ef>uintptr</span>) {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>stackPreempt</span>
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>throwsplit</span> = <span style=color:#66d9ef>true</span>

	<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallsp</span> = <span style=color:#a6e22e>sp</span>
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>syscallpc</span> = <span style=color:#a6e22e>pc</span>
	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>_g_</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gsyscall</span>)

	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>syscalltick</span> = <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span>
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>mcache</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>()
	<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>m</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>oldp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>pp</span>)
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>_Psyscall</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>entersyscall_gcwait</span>)
		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
	}
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>--</span>
}
</code></pre></div><ol><li>禁止线程上发生的抢占，防止出现内存不一致的问题；</li><li>保证当前函数不会触发栈分裂或者增长；</li><li>保存当前的程序计数器 PC 和栈指针 SP 中的内容；</li><li>将 Goroutine 的状态更新至 <code>_Gsyscall</code>；</li><li>将 Goroutine 的处理器和线程暂时分离并更新处理器的状态到 <code>_Psyscall</code>；</li><li>释放当前线程上的锁；</li></ol><p>需要注意的是 <a href=/golang/tree/runtime.reentersyscall><code>runtime.reentersyscall</code></a> 会使处理器和线程的分离，当前线程会陷入系统调用等待返回，在锁被释放后，会有其他 Goroutine 抢占处理器资源。</p><h4 id=恢复工作>恢复工作
<a class=anchor href=#%e6%81%a2%e5%a4%8d%e5%b7%a5%e4%bd%9c>#</a></h4><p>当系统调用结束后，会调用退出系统调用的函数 <a href=/golang/tree/runtime.exitsyscall><code>runtime.exitsyscall</code></a> 为当前 Goroutine 重新分配资源，该函数有两个不同的执行路径：</p><ol><li>调用 <a href=/golang/tree/runtime.exitsyscallfast><code>runtime.exitsyscallfast</code></a>；</li><li>切换至调度器的 Goroutine 并调用 <a href=/golang/tree/runtime.exitsyscall0><code>runtime.exitsyscall0</code></a>；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>exitsyscall</span>() {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()

	<span style=color:#a6e22e>oldp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>oldp</span>.<span style=color:#a6e22e>ptr</span>()
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>oldp</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>exitsyscallfast</span>(<span style=color:#a6e22e>oldp</span>) {
		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span><span style=color:#f92672>++</span>
		<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>_g_</span>, <span style=color:#a6e22e>_Gsyscall</span>, <span style=color:#a6e22e>_Grunning</span>)
		<span style=color:#f92672>...</span>

		<span style=color:#66d9ef>return</span>
	}

	<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>exitsyscall0</span>)
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>throwsplit</span> = <span style=color:#66d9ef>false</span>
}
</code></pre></div><p>这两种不同的路径会分别通过不同的方法查找一个用于执行当前 Goroutine 处理器 P，快速路径 <a href=/golang/tree/runtime.exitsyscallfast><code>runtime.exitsyscallfast</code></a> 中包含两个不同的分支：</p><ol><li>如果 Goroutine 的原处理器处于 <code>_Psyscall</code> 状态，会直接调用 <code>wirep</code> 将 Goroutine 与处理器进行关联；</li><li>如果调度器中存在闲置的处理器，会调用 <a href=/golang/tree/runtime.acquirep><code>runtime.acquirep</code></a> 使用闲置的处理器处理当前 Goroutine；</li></ol><p>另一个相对较慢的路径 <a href=/golang/tree/runtime.exitsyscall0><code>runtime.exitsyscall0</code></a> 会将当前 Goroutine 切换至 <code>_Grunnable</code> 状态，并移除线程 M 和当前 Goroutine 的关联：</p><ol><li>当我们通过 <a href=/golang/tree/runtime.pidleget><code>runtime.pidleget</code></a> 获取到闲置的处理器时就会在该处理器上执行 Goroutine；</li><li>在其它情况下，我们会将当前 Goroutine 放到全局的运行队列中，等待调度器的调度；</li></ol><p>无论哪种情况，我们在这个函数中都会调用 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 触发调度器的调度，因为上一节已经介绍过调度器的调度过程，所以在这里就不展开了。</p><h3 id=协作式调度>协作式调度
<a class=anchor href=#%e5%8d%8f%e4%bd%9c%e5%bc%8f%e8%b0%83%e5%ba%a6>#</a></h3><p>我们在设计原理中介绍过了 Go 语言基于协作式和信号的两种抢占式调度，这里主要介绍其中的协作式调度。<a href=/golang/tree/runtime.Gosched><code>runtime.Gosched</code></a> 函数会主动让出处理器，允许其他 Goroutine 运行。该函数无法挂起 Goroutine，调度器可能会将当前 Goroutine 调度到其他线程上：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Gosched</span>() {
	<span style=color:#a6e22e>checkTimeouts</span>()
	<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>gosched_m</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gosched_m</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
	<span style=color:#a6e22e>goschedImpl</span>(<span style=color:#a6e22e>gp</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>goschedImpl</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Grunnable</span>)
	<span style=color:#a6e22e>dropg</span>()
	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
	<span style=color:#a6e22e>globrunqput</span>(<span style=color:#a6e22e>gp</span>)
	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)

	<span style=color:#a6e22e>schedule</span>()
}
</code></pre></div><p>经过连续几次跳转，我们最终在 g0 的栈上调用 <a href=/golang/tree/runtime.goschedImpl><code>runtime.goschedImpl</code></a>，运行时会更新 Goroutine 的状态到 <code>_Grunnable</code>，让出当前的处理器并将 Goroutine 重新放回全局队列，在最后，该函数会调用 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 触发调度。</p><h2 id=657-线程管理>6.5.7 线程管理
<a class=anchor href=#657-%e7%ba%bf%e7%a8%8b%e7%ae%a1%e7%90%86>#</a></h2><p>Go 语言的运行时会通过调度器改变线程的所有权，它也提供了 <a href=/golang/tree/runtime.LockOSThread><code>runtime.LockOSThread</code></a> 和 <a href=/golang/tree/runtime.UnlockOSThread><code>runtime.UnlockOSThread</code></a> 让我们有能力绑定 Goroutine 和线程完成一些比较特殊的操作。Goroutine 应该在调用操作系统服务或者依赖线程状态的非 Go 语言库时调用 <a href=/golang/tree/runtime.LockOSThread><code>runtime.LockOSThread</code></a> 函数<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>，例如：C 语言图形库等。</p><p><a href=/golang/tree/runtime.LockOSThread><code>runtime.LockOSThread</code></a> 会通过如下所示的代码绑定 Goroutine 和当前线程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LockOSThread</span>() {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newmHandoff</span>.<span style=color:#a6e22e>haveTemplateThread</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>GOOS</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;plan9&#34;</span> {
		<span style=color:#a6e22e>startTemplateThread</span>()
	}
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockedExt</span><span style=color:#f92672>++</span>
	<span style=color:#a6e22e>dolockOSThread</span>()
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dolockOSThread</span>() {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockedg</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>_g_</span>)
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>lockedm</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>)
}
</code></pre></div><p><a href=/golang/tree/runtime.dolockOSThread><code>runtime.dolockOSThread</code></a> 会分别设置线程的 <code>lockedg</code> 字段和 Goroutine 的 <code>lockedm</code> 字段，这两行代码会绑定线程和 Goroutine。</p><p>当 Goroutine 完成了特定的操作之后，会调用以下函数 <a href=/golang/tree/runtime.UnlockOSThread><code>runtime.UnlockOSThread</code></a> 分离 Goroutine 和线程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>UnlockOSThread</span>() {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockedExt</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockedExt</span><span style=color:#f92672>--</span>
	<span style=color:#a6e22e>dounlockOSThread</span>()
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dounlockOSThread</span>() {
	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockedInt</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockedExt</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockedg</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>lockedm</span> = <span style=color:#ae81ff>0</span>
}
</code></pre></div><p>函数执行的过程与 <a href=/golang/tree/runtime.LockOSThread><code>runtime.LockOSThread</code></a> 正好相反。在多数的服务中，我们都用不到这一对函数，不过使用 CGO 或者经常与操作系统打交道的读者可能会见到它们的身影。</p><h3 id=线程生命周期>线程生命周期
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f>#</a></h3><p>Go 语言的运行时会通过 <a href=/golang/tree/runtime.startm><code>runtime.startm</code></a> 启动线程来执行处理器 P，如果我们在该函数中没能从闲置列表中获取到线程 M 就会调用 <a href=/golang/tree/runtime.newm><code>runtime.newm</code></a> 创建新的线程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newm</span>(<span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int64</span>) {
	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>allocm</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>id</span>)
	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>nextp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>_p_</span>)
	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>sigmask</span> = <span style=color:#a6e22e>initSigmask</span>
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>newm1</span>(<span style=color:#a6e22e>mp</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newm1</span>(<span style=color:#a6e22e>mp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>iscgo</span> {
		<span style=color:#f92672>...</span>
	}
	<span style=color:#a6e22e>newosproc</span>(<span style=color:#a6e22e>mp</span>)
}
</code></pre></div><p>创建新的线程需要使用如下所示的 <a href=/golang/tree/runtime.newosproc><code>runtime.newosproc</code></a>，该函数在 Linux 平台上会通过系统调用 <code>clone</code> 创建新的操作系统线程，它也是创建线程链路上距离操作系统最近的 Go 语言函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newosproc</span>(<span style=color:#a6e22e>mp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>) {
	<span style=color:#a6e22e>stk</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span>)
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>ret</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>clone</span>(<span style=color:#a6e22e>cloneFlags</span>, <span style=color:#a6e22e>stk</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>mstart</span>)))
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>使用系统调用 <code>clone</code> 创建的线程会在线程主动调用 <code>exit</code>、或者传入的函数 <a href=/golang/tree/runtime.mstart><code>runtime.mstart</code></a> 返回会主动退出，<a href=/golang/tree/runtime.mstart><code>runtime.mstart</code></a> 会执行调用 <a href=/golang/tree/runtime.newm><code>runtime.newm</code></a> 时传入的匿名函数 <code>fn</code>，到这里也就完成了从线程创建到销毁的整个闭环。</p><h2 id=658-小结>6.5.8 小结
<a class=anchor href=#658-%e5%b0%8f%e7%bb%93>#</a></h2><p>Goroutine 和调度器是 Go 语言能够高效地处理任务并且最大化利用资源的基础，本节介绍了 Go 语言用于处理并发任务的 G - M - P 模型，我们不仅介绍了它们各自的数据结构以及常见状态，还通过特定场景介绍调度器的工作原理以及不同数据结构之间的协作关系，相信能够帮助各位读者理解调度器的实现。</p><h2 id=659-延伸阅读>6.5.9 延伸阅读
<a class=anchor href=#659-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=http://jlouisramblings.blogspot.com/2013/01/how-erlang-does-scheduling.html>How Erlang does scheduling</a></li><li><a href=http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf>Analysis of the Go runtime scheduler</a></li><li><a href=https://rakyll.org/scheduler/>Go&rsquo;s work-stealing scheduler</a></li><li><a href=https://github.com/golang/go/commit/7f1ff65c3947b916cc4d0827fd8c1307d7efd7bf>cmd/compile: insert scheduling checks on loop backedges</a></li><li><a href=https://github.com/golang/go/issues/36365>runtime: clean up async preemption loose ends</a></li><li><a href=https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md>Proposal: Non-cooperative goroutine preemption</a></li><li><a href=https://github.com/golang/proposal/blob/master/design/24543/conservative-inner-frame.md>Proposal: Conservative inner-frame scanning for non-cooperative goroutine preemption</a></li><li><a href=https://docs.google.com/document/u/0/d/1d3iI2QWURgDIsSR6G2275vMeQ_X7w-qxM2Vp7iGwwuM/pub>NUMA-aware scheduler for Go</a></li><li><a href=http://morsmachine.dk/go-scheduler>The Go scheduler</a></li><li><a href=https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f>Why goroutines are not lightweight threads?</a></li><li><a href=https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html>Scheduling In Go : Part I - OS Scheduler</a></li><li><a href=https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html>Scheduling In Go : Part II - Go Scheduler</a></li><li><a href=https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html>Scheduling In Go : Part III - Concurrency</a></li><li><a href=https://manybutfinite.com/post/system-calls/>System Calls Make the World Go Round</a></li><li><a href=https://syscalls.kernelgrok.com>Linux Syscall Reference</a></li><li><a href=https://medium.com/a-journey-with-go/go-concurrency-scheduler-affinity-3b678f490488>Go: Concurrency & Scheduler Affinity</a></li><li><a href=https://medium.com/a-journey-with-go/go-g0-special-goroutine-8c778c6704d8>Go: g0, Special Goroutine</a></li><li><a href=https://github.com/golang/go/issues/21827>runtime: big performance penalty with runtime.LockOSThread #21827</a></li><li><a href=https://github.com/golang/go/commit/d0f8a7517ab0b33c8e3dd49294800dd6144e4cee>runtime: don&rsquo;t clear lockedExt on locked M when G exits</a></li></ul><p><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/ class=book-btn>上一节</a>
<a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Eli Bendersky. 2018. &ldquo;Measuring context switching and memory overheads for Linux threads&rdquo; <a href=https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/>https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Goroutine 上下文切换时间待确认； <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Scalable Go Scheduler Design Doc <a href=http://golang.org/s/go11sched>http://golang.org/s/go11sched</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Pre-emption in the scheduler <a href=https://golang.org/doc/go1.2#preemption>https://golang.org/doc/go1.2#preemption</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Go Preemptive Scheduler Design Doc <a href="https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.3pilqarbrc9h">https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.3pilqarbrc9h</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>runtime: goroutines do not get scheduled for a long time for no obvious reason <a href=https://github.com/golang/go/issues/4711#issuecomment-66073943>https://github.com/golang/go/issues/4711#issuecomment-66073943</a> <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7 role=doc-endnote><p>Proposal: Non-cooperative goroutine preemption <a href=https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md#other-considerations>https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md#other-considerations</a> <a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8 role=doc-endnote><p>Proposal: Conservative inner-frame scanning for non-cooperative goroutine preemption <a href=https://github.com/golang/proposal/blob/master/design/24543/conservative-inner-frame.md>https://github.com/golang/proposal/blob/master/design/24543/conservative-inner-frame.md</a> <a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9 role=doc-endnote><p>NUMA-aware scheduler for Go <a href=https://docs.google.com/document/u/0/d/1d3iI2QWURgDIsSR6G2275vMeQ_X7w-qxM2Vp7iGwwuM/pub>https://docs.google.com/document/u/0/d/1d3iI2QWURgDIsSR6G2275vMeQ_X7w-qxM2Vp7iGwwuM/pub</a> <a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10 role=doc-endnote><p>Why is there no goroutine ID? <a href=https://golang.org/doc/faq#no_goroutine_id>https://golang.org/doc/faq#no_goroutine_id</a> <a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11 role=doc-endnote><p>LockOSThread · package runtime <a href=https://golang.org/pkg/runtime/#LockOSThread>https://golang.org/pkg/runtime/#LockOSThread</a> <a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-goroutine data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-goroutine",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#65-调度器>6.5 调度器</a><ul><li><a href=#651-设计原理>6.5.1 设计原理</a><ul><li><a href=#单线程调度器>单线程调度器</a></li><li><a href=#多线程调度器>多线程调度器</a></li><li><a href=#任务窃取调度器>任务窃取调度器</a></li><li><a href=#抢占式调度器>抢占式调度器</a></li><li><a href=#非均匀内存访问调度器>非均匀内存访问调度器</a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#652-数据结构>6.5.2 数据结构</a><ul><li><a href=#g>G</a></li><li><a href=#m>M</a></li><li><a href=#p>P</a></li><li><a href=#小结-1>小结</a></li></ul></li><li><a href=#653-调度器启动>6.5.3 调度器启动</a></li><li><a href=#654-创建-goroutine>6.5.4 创建 Goroutine</a><ul><li><a href=#初始化结构体>初始化结构体</a></li><li><a href=#运行队列>运行队列</a></li><li><a href=#调度信息>调度信息</a></li></ul></li><li><a href=#655-调度循环>6.5.5 调度循环</a></li><li><a href=#656-触发调度>6.5.6 触发调度</a><ul><li><a href=#主动挂起>主动挂起</a></li><li><a href=#系统调用>系统调用</a></li><li><a href=#协作式调度>协作式调度</a></li></ul></li><li><a href=#657-线程管理>6.5.7 线程管理</a><ul><li><a href=#线程生命周期>线程生命周期</a></li></ul></li><li><a href=#658-小结>6.5.8 小结</a></li><li><a href=#659-延伸阅读>6.5.9 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>