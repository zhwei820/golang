<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="6.3 计时器 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把各个节点上时间的误差控制在毫秒级，所以准确的相对时间在分布式系统中显得更为重要，本节会分析用于获取相对时间的计时器的设计与实现原理。
6.3.1 设计原理 #  Go 语言从实现计时器到现在经历过很多个版本的迭代，到最新的版本为止，计时器的实现分别经历了以下几个过程：
 Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护1； Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护2； Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发3；  我们在这一节会分别介绍计时器在不同版本的不同设计，梳理计时器实现的演进过程。
全局四叉堆 #  Go 1.10 之前的计时器都使用最小四叉堆实现，所有的计时器都会存储在如下所示的结构体 runtime.timers:093adee 中：
var timers struct { lock mutex gp *g created bool sleeping bool rescheduling bool sleepUntil int64 waitnote note t []*timer } 这个结构体中的字段 t 就是最小四叉堆，运行时创建的所有计时器都会加入到四叉堆中。runtime.timerproc:093adee Goroutine 会运行时间驱动的事件，运行时会在发生以下事件时唤醒计时器："><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言并发编程与计时器"><meta property="og:description" content="6.3 计时器 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把各个节点上时间的误差控制在毫秒级，所以准确的相对时间在分布式系统中显得更为重要，本节会分析用于获取相对时间的计时器的设计与实现原理。
6.3.1 设计原理 #  Go 语言从实现计时器到现在经历过很多个版本的迭代，到最新的版本为止，计时器的实现分别经历了以下几个过程：
 Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护1； Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护2； Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发3；  我们在这一节会分别介绍计时器在不同版本的不同设计，梳理计时器实现的演进过程。
全局四叉堆 #  Go 1.10 之前的计时器都使用最小四叉堆实现，所有的计时器都会存储在如下所示的结构体 runtime.timers:093adee 中：
var timers struct { lock mutex gp *g created bool sleeping bool rescheduling bool sleepUntil int64 waitnote note t []*timer } 这个结构体中的字段 t 就是最小四叉堆，运行时创建的所有计时器都会加入到四叉堆中。runtime.timerproc:093adee Goroutine 会运行时间驱动的事件，运行时会在发生以下事件时唤醒计时器："><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part3-runtime/ch06-concurrency/golang-timer/"><title>Go 语言并发编程与计时器 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言并发编程与计时器</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#63-计时器>6.3 计时器</a><ul><li><a href=#631-设计原理>6.3.1 设计原理</a><ul><li><a href=#全局四叉堆>全局四叉堆</a></li><li><a href=#分片四叉堆>分片四叉堆</a></li><li><a href=#网络轮询器>网络轮询器</a></li></ul></li><li><a href=#632-数据结构>6.3.2 数据结构</a></li><li><a href=#633-状态机>6.3.3 状态机</a><ul><li><a href=#增加计时器>增加计时器</a></li><li><a href=#删除计时器>删除计时器</a></li><li><a href=#修改计时器>修改计时器</a></li><li><a href=#清除计时器>清除计时器</a></li><li><a href=#调整计时器>调整计时器</a></li><li><a href=#运行计时器>运行计时器</a></li></ul></li><li><a href=#634-触发计时器>6.3.4 触发计时器</a><ul><li><a href=#调度器>调度器</a></li><li><a href=#系统监控>系统监控</a></li></ul></li><li><a href=#635-小结>6.3.5 小结</a></li><li><a href=#636-延伸阅读>6.3.6 延伸阅读</a></li><li><a href=#637-历史变更>6.3.7 历史变更</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=63-计时器>6.3 计时器
<a class=anchor href=#63-%e8%ae%a1%e6%97%b6%e5%99%a8>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把各个节点上时间的误差控制在毫秒级，所以准确的相对时间在分布式系统中显得更为重要，本节会分析用于获取相对时间的计时器的设计与实现原理。</p><h2 id=631-设计原理>6.3.1 设计原理
<a class=anchor href=#631-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>Go 语言从实现计时器到现在经历过很多个版本的迭代，到最新的版本为止，计时器的实现分别经历了以下几个过程：</p><ol><li>Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>；</li><li>Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>；</li><li>Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>；</li></ol><p>我们在这一节会分别介绍计时器在不同版本的不同设计，梳理计时器实现的演进过程。</p><h3 id=全局四叉堆>全局四叉堆
<a class=anchor href=#%e5%85%a8%e5%b1%80%e5%9b%9b%e5%8f%89%e5%a0%86>#</a></h3><p>Go 1.10 之前的计时器都使用最小四叉堆实现，所有的计时器都会存储在如下所示的结构体 <a href=/golang/tree/runtime.timers:093adee><code>runtime.timers:093adee</code></a> 中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>timers</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>lock</span>         <span style=color:#a6e22e>mutex</span>
	<span style=color:#a6e22e>gp</span>           <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
	<span style=color:#a6e22e>created</span>      <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>sleeping</span>     <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>rescheduling</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>sleepUntil</span>   <span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>waitnote</span>     <span style=color:#a6e22e>note</span>
	<span style=color:#a6e22e>t</span>            []<span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>
}
</code></pre></div><p>这个结构体中的字段 <code>t</code> 就是最小四叉堆，运行时创建的所有计时器都会加入到四叉堆中。<a href=/golang/tree/runtime.timerproc:093adee><code>runtime.timerproc:093adee</code></a> Goroutine 会运行时间驱动的事件，运行时会在发生以下事件时唤醒计时器：</p><ul><li>四叉堆中的计时器到期；</li><li>四叉堆中加入了触发时间更早的新计时器；</li></ul><p><img src=https://img.draveness.me/2020-01-25-15799218054781-golang-timer-quadtree.png alt=golang-timer-quadtree></p><p><strong>图 6-14 计时器四叉堆</strong></p><p>然而全局四叉堆共用的互斥锁对计时器的影响非常大，计时器的各种操作都需要获取全局唯一的互斥锁，这会严重影响计时器的性能<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>。</p><h3 id=分片四叉堆>分片四叉堆
<a class=anchor href=#%e5%88%86%e7%89%87%e5%9b%9b%e5%8f%89%e5%a0%86>#</a></h3><p>Go 1.10 将全局的四叉堆分割成了 64 个更小的四叉堆<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。在理想情况下，四叉堆的数量应该等于处理器的数量，但是这需要实现动态的分配过程，所以经过权衡最终选择初始化 64 个四叉堆，以牺牲内存占用的代价换取性能的提升。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>timersLen</span> = <span style=color:#ae81ff>64</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>timers</span> [<span style=color:#a6e22e>timersLen</span>]<span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>timersBucket</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>timersBucket</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>lock</span>         <span style=color:#a6e22e>mutex</span>
	<span style=color:#a6e22e>gp</span>           <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
	<span style=color:#a6e22e>created</span>      <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>sleeping</span>     <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>rescheduling</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>sleepUntil</span>   <span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>waitnote</span>     <span style=color:#a6e22e>note</span>
	<span style=color:#a6e22e>t</span>            []<span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>
}
</code></pre></div><p>如果当前机器上的处理器 P 的个数超过了 64，多个处理器上的计时器就可能存储在同一个桶中。每一个计时器桶都由一个运行 <a href=/golang/tree/runtime.timerproc:76f4fd8><code>runtime.timerproc:76f4fd8</code></a> 函数的 Goroutine 处理。</p><p><img src=https://img.draveness.me/2020-01-25-15799218054791-golang-timer-bucket.png alt=golang-timer-bucket></p><p><strong>图 6-15 分片计时器桶</strong></p><p>将全局计时器分片的方式，虽然能够降低锁的粒度，提高计时器的性能，但是 <a href=/golang/tree/runtime.timerproc:76f4fd8><code>runtime.timerproc:76f4fd8</code></a> 造成的处理器和线程之间频繁的上下文切换却成为了影响计时器性能的首要因素<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>。</p><h3 id=网络轮询器>网络轮询器
<a class=anchor href=#%e7%bd%91%e7%bb%9c%e8%bd%ae%e8%af%a2%e5%99%a8>#</a></h3><p>在最新版本的实现中，计时器桶已经被移除<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>，所有的计时器都以最小四叉堆的形式存储在处理器 <a href=/golang/tree/runtime.p><code>runtime.p</code></a> 中。</p><p><img src=https://img.draveness.me/2020-01-25-15799218054798-golang-p-and-timers.png alt=golang-p-and-timers></p><p><strong>图 6-16 处理器中的最小四叉堆</strong></p><p>处理器 <a href=/golang/tree/runtime.p><code>runtime.p</code></a> 中与计时器相关的有以下字段：</p><ul><li><code>timersLock</code> — 用于保护计时器的互斥锁；</li><li><code>timers</code> — 存储计时器的最小四叉堆；</li><li><code>numTimers</code> — 处理器中的计时器数量；</li><li><code>adjustTimers</code> — 处理器中处于 <code>timerModifiedEarlier</code> 状态的计时器数量；</li><li><code>deletedTimers</code> — 处理器中处于 <code>timerDeleted</code> 状态的计时器数量；</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>p</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>timersLock</span> <span style=color:#a6e22e>mutex</span>
	<span style=color:#a6e22e>timers</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>

	<span style=color:#a6e22e>numTimers</span>     <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>adjustTimers</span>  <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>deletedTimers</span> <span style=color:#66d9ef>uint32</span>
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>原本用于管理计时器的 <a href=/golang/tree/runtime.timerproc:76f4fd8><code>runtime.timerproc:76f4fd8</code></a> 也已经被移除，目前计时器都交由处理器的网络轮询器和调度器触发，这种方式能够充分利用本地性、减少上下文的切换开销，也是目前性能最好的实现方式。</p><h2 id=632-数据结构>6.3.2 数据结构
<a class=anchor href=#632-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p><a href=/golang/tree/runtime.timer><code>runtime.timer</code></a> 是 Go 语言计时器的内部表示，每一个计时器都存储在对应处理器的最小四叉堆中，下面是运行时计时器对应的结构体：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>timer</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>pp</span> <span style=color:#a6e22e>puintptr</span>

	<span style=color:#a6e22e>when</span>     <span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>period</span>   <span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>f</span>        <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>interface</span>{}, <span style=color:#66d9ef>uintptr</span>)
	<span style=color:#a6e22e>arg</span>      <span style=color:#66d9ef>interface</span>{}
	<span style=color:#a6e22e>seq</span>      <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>nextwhen</span> <span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>status</span>   <span style=color:#66d9ef>uint32</span>
}
</code></pre></div><ul><li><code>when</code> — 当前计时器被唤醒的时间；</li><li><code>period</code> — 两次被唤醒的间隔；</li><li><code>f</code> — 每当计时器被唤醒时都会调用的函数；</li><li><code>arg</code> — 计时器被唤醒时调用 <code>f</code> 传入的参数；</li><li><code>nextWhen</code> — 计时器处于 <code>timerModifiedXX</code> 状态时，用于设置 <code>when</code> 字段；</li><li><code>status</code> — 计时器的状态；</li></ul><p>然而这里的 <a href=/golang/tree/runtime.timer><code>runtime.timer</code></a> 只是计时器运行时的私有结构体，对外暴露的计时器使用 <a href=/golang/tree/time.Timer><code>time.Timer</code></a> 结体：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Timer</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>C</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>Time</span>
	<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>runtimeTimer</span>
}
</code></pre></div><p><a href=/golang/tree/time.Timer><code>time.Timer</code></a> 计时器必须通过 <a href=/golang/tree/time.NewTimer><code>time.NewTimer</code></a>、<a href=/golang/tree/time.AfterFunc><code>time.AfterFunc</code></a> 或者 <a href=/golang/tree/time.After><code>time.After</code></a> 函数创建。 当计时器失效时，订阅计时器 Channel 的 Goroutine 会收到计时器失效的时间。</p><h2 id=633-状态机>6.3.3 状态机
<a class=anchor href=#633-%e7%8a%b6%e6%80%81%e6%9c%ba>#</a></h2><p>运行时使用状态机的方式处理全部的计时器，其中包括 10 种状态和几种操作。由于 Go 语言的计时器需要同时支持增加、删除、修改和重置等操作，所以它的状态非常复杂，目前会包含以下 10 种可能：</p><table><thead><tr><th style=text-align:left>状态</th><th style=text-align:center>解释</th></tr></thead><tbody><tr><td style=text-align:left>timerNoStatus</td><td style=text-align:center>还没有设置状态</td></tr><tr><td style=text-align:left>timerWaiting</td><td style=text-align:center>等待触发</td></tr><tr><td style=text-align:left>timerRunning</td><td style=text-align:center>运行计时器函数</td></tr><tr><td style=text-align:left>timerDeleted</td><td style=text-align:center>被删除</td></tr><tr><td style=text-align:left>timerRemoving</td><td style=text-align:center>正在被删除</td></tr><tr><td style=text-align:left>timerRemoved</td><td style=text-align:center>已经被停止并从堆中删除</td></tr><tr><td style=text-align:left>timerModifying</td><td style=text-align:center>正在被修改</td></tr><tr><td style=text-align:left>timerModifiedEarlier</td><td style=text-align:center>被修改到了更早的时间</td></tr><tr><td style=text-align:left>timerModifiedLater</td><td style=text-align:center>被修改到了更晚的时间</td></tr><tr><td style=text-align:left>timerMoving</td><td style=text-align:center>已经被修改正在被移动</td></tr></tbody></table><p><strong>表 6-2 计时器的状态</strong></p><p>上述表格已经展示了不同状态的含义，但是我们还需要展示一些重要的信息，例如状态的存在时间、计时器是否在堆上等：</p><ul><li><code>timerRunning</code>、<code>timerRemoving</code>、<code>timerModifying</code> 和 <code>timerMoving</code> — 停留的时间都比较短；</li><li><code>timerWaiting</code>、<code>timerRunning</code>、<code>timerDeleted</code>、<code>timerRemoving</code>、<code>timerModifying</code>、<code>timerModifiedEarlier</code>、<code>timerModifiedLater</code> 和 <code>timerMoving</code> — 计时器在处理器的堆上；</li><li><code>timerNoStatus</code> 和 <code>timerRemoved</code> — 计时器不在堆上；</li><li><code>timerModifiedEarlier</code> 和 <code>timerModifiedLater</code> — 计时器虽然在堆上，但是可能位于错误的位置上，需要重新排序；</li></ul><p>当我们操作计时器时，运行时会根据状态的不同而做出反应，所以在分析计时器时会将状态作为切入点分析其实现原理。计时器的状态机中包含如下所示的 7 种不同操作，它们分别承担了不同的职责：</p><ul><li><a href=/golang/tree/runtime.addtimer><code>runtime.addtimer</code></a> — 向当前处理器增加新的计时器<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>；</li><li><a href=/golang/tree/runtime.deltimer><code>runtime.deltimer</code></a> — 将计时器标记成 <code>timerDeleted</code> 删除处理器中的计时器<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>；</li><li><a href=/golang/tree/runtime.modtimer><code>runtime.modtimer</code></a> — 网络轮询器会调用该函数修改计时器<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>；</li><li><a href=/golang/tree/runtime.cleantimers><code>runtime.cleantimers</code></a> — 清除队列头中的计时器，能够提升程序创建和删除计时器的性能<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>；</li><li><a href=/golang/tree/runtime.adjusttimers><code>runtime.adjusttimers</code></a> — 调整处理器持有的计时器堆，包括移动会稍后触发的计时器、删除标记为 <code>timerDeleted</code> 的计时器<sup id=fnref:12><a href=#fn:12 class=footnote-ref role=doc-noteref>12</a></sup>；</li><li><a href=/golang/tree/runtime.runtimer><code>runtime.runtimer</code></a> — 检查队列头中的计时器，在其准备就绪时运行该计时器<sup id=fnref:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup>；</li></ul><p>我们在这里会依次分析计时器的上述 7 个不同操作。</p><h3 id=增加计时器>增加计时器
<a class=anchor href=#%e5%a2%9e%e5%8a%a0%e8%ae%a1%e6%97%b6%e5%99%a8>#</a></h3><p>当我们调用 <a href=/golang/tree/time.NewTimer><code>time.NewTimer</code></a> 增加新的计时器时，会执行程序中的 <a href=/golang/tree/runtime.addtimer><code>runtime.addtimer</code></a> 函数根据以下的规则处理计时器：</p><ul><li><code>timerNoStatus</code> -> <code>timerWaiting</code></li><li>其他状态 -> 崩溃：不合法的状态</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addtimer</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>timerNoStatus</span> {
		<span style=color:#a6e22e>badTimer</span>()
	}
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span> = <span style=color:#a6e22e>timerWaiting</span>
	<span style=color:#a6e22e>cleantimers</span>(<span style=color:#a6e22e>pp</span>)
	<span style=color:#a6e22e>doaddtimer</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>t</span>)
	<span style=color:#a6e22e>wakeNetPoller</span>(<span style=color:#a6e22e>when</span>)
}
</code></pre></div><ol><li>调用 <a href=/golang/tree/runtime.cleantimers><code>runtime.cleantimers</code></a> 清理处理器中的计时器；</li><li>调用 <a href=/golang/tree/runtime.doaddtimer><code>runtime.doaddtimer</code></a> 将当前计时器加入处理器的 <code>timers</code> 四叉堆中；<ol><li>调用 <a href=/golang/tree/runtime.netpollGenericInit><code>runtime.netpollGenericInit</code></a> 函数惰性初始化网络轮询器；</li></ol></li><li>调用 <a href=/golang/tree/runtime.wakeNetPoller><code>runtime.wakeNetPoller</code></a> 唤醒网络轮询器中休眠的线程；<ol><li>调用 <a href=/golang/tree/runtime.netpollBreak><code>runtime.netpollBreak</code></a> 函数中断正在阻塞的网络轮询<sup id=fnref:14><a href=#fn:14 class=footnote-ref role=doc-noteref>14</a></sup>；</li></ol></li></ol><p>每次增加新的计时器都会中断正在阻塞的轮询，触发调度器检查是否有计时器到期，我们会在后面详细介绍计时器的触发过程。</p><h3 id=删除计时器>删除计时器
<a class=anchor href=#%e5%88%a0%e9%99%a4%e8%ae%a1%e6%97%b6%e5%99%a8>#</a></h3><p><a href=/golang/tree/runtime.deltimer><code>runtime.deltimer</code></a> 函数会标记需要删除的计时器，它会根据以下的规则处理计时器：</p><ul><li><code>timerWaiting</code> -> <code>timerModifying</code> -> <code>timerDeleted</code></li><li><code>timerModifiedEarlier</code> -> <code>timerModifying</code> -> <code>timerDeleted</code></li><li><code>timerModifiedLater</code> -> <code>timerModifying</code> -> <code>timerDeleted</code></li><li>其他状态 -> 等待状态改变或者直接返回</li></ul><p>在删除计时器的过程中，可能会遇到其他处理器的计时器，在设置我们需要将计时器标记为删除状态，并由持有计时器的处理器完成清除工作。</p><h3 id=修改计时器>修改计时器
<a class=anchor href=#%e4%bf%ae%e6%94%b9%e8%ae%a1%e6%97%b6%e5%99%a8>#</a></h3><p><a href=/golang/tree/runtime.modtimer><code>runtime.modtimer</code></a> 会修改已经存在的计时器，它会根据以下的规则处理计时器：</p><ul><li><code>timerWaiting</code> -> <code>timerModifying</code> -> <code>timerModifiedXX</code></li><li><code>timerModifiedXX</code> -> <code>timerModifying</code> -> <code>timerModifiedYY</code></li><li><code>timerNoStatus</code> -> <code>timerModifying</code> -> <code>timerWaiting</code></li><li><code>timerRemoved</code> -> <code>timerModifying</code> -> <code>timerWaiting</code></li><li><code>timerDeleted</code> -> <code>timerModifying</code> -> <code>timerWaiting</code></li><li>其他状态 -> 等待状态改变</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>modtimer</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>, <span style=color:#a6e22e>when</span>, <span style=color:#a6e22e>period</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>interface</span>{}, <span style=color:#66d9ef>uintptr</span>), <span style=color:#a6e22e>arg</span> <span style=color:#66d9ef>interface</span>{}, <span style=color:#a6e22e>seq</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#a6e22e>status</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#a6e22e>timerNoStatus</span>)
	<span style=color:#a6e22e>wasRemoved</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
<span style=color:#a6e22e>loop</span>:
	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>status</span> = <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>); <span style=color:#a6e22e>status</span> {
			<span style=color:#f92672>...</span>
		}
	}

	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>period</span> = <span style=color:#a6e22e>period</span>
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>f</span> = <span style=color:#a6e22e>f</span>
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>arg</span> = <span style=color:#a6e22e>arg</span>
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>seq</span> = <span style=color:#a6e22e>seq</span>

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>wasRemoved</span> {
		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>when</span> = <span style=color:#a6e22e>when</span>
		<span style=color:#a6e22e>doaddtimer</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>t</span>)
		<span style=color:#a6e22e>wakeNetPoller</span>(<span style=color:#a6e22e>when</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>nextwhen</span> = <span style=color:#a6e22e>when</span>
		<span style=color:#a6e22e>newStatus</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#a6e22e>timerModifiedLater</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>when</span> &lt; <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>when</span> {
			<span style=color:#a6e22e>newStatus</span> = <span style=color:#a6e22e>timerModifiedEarlier</span>
		}
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newStatus</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>timerModifiedEarlier</span> {
			<span style=color:#a6e22e>wakeNetPoller</span>(<span style=color:#a6e22e>when</span>)
		}
	}
}
</code></pre></div><p>如果待修改的计时器已经被删除，那么该函数会调用 <a href=/golang/tree/runtime.doaddtimer><code>runtime.doaddtimer</code></a> 创建新的计时器。在正常情况下会根据修改后的时间进行不同的处理：</p><ul><li>如果修改后的时间大于或者等于修改前时间，设置计时器的状态为 <code>timerModifiedLater</code>；</li><li>如果修改后的时间小于修改前时间，设置计时器的状态为 <code>timerModifiedEarlier</code> 并调用 <a href=/golang/tree/runtime.netpollBreak><code>runtime.netpollBreak</code></a> 触发调度器的重新调度；</li></ul><p>因为修改后的时间会影响计时器的处理，所以用于修改计时器的 <a href=/golang/tree/runtime.modtimer><code>runtime.modtimer</code></a> 也是状态机中最复杂的函数了。</p><h3 id=清除计时器>清除计时器
<a class=anchor href=#%e6%b8%85%e9%99%a4%e8%ae%a1%e6%97%b6%e5%99%a8>#</a></h3><p><a href=/golang/tree/runtime.cleantimers><code>runtime.cleantimers</code></a> 函数会根据状态清理处理器队列头中的计时器，该函数会遵循以下的规则修改计时器的触发时间：</p><ul><li><code>timerDeleted</code> -> <code>timerRemoving</code> -> <code>timerRemoved</code></li><li><code>timerModifiedXX</code> -> <code>timerMoving</code> -> <code>timerWaiting</code></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>cleantimers</span>(<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timers</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
		}
		<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timers</span>[<span style=color:#ae81ff>0</span>]
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>); <span style=color:#a6e22e>s</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>timerDeleted</span>:
			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>timerRemoving</span>)
			<span style=color:#a6e22e>dodeltimer0</span>(<span style=color:#a6e22e>pp</span>)
			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>timerRemoving</span>, <span style=color:#a6e22e>timerRemoved</span>)
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>timerModifiedEarlier</span>, <span style=color:#a6e22e>timerModifiedLater</span>:
			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>timerMoving</span>)

			<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>when</span> = <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>nextwhen</span>

			<span style=color:#a6e22e>dodeltimer0</span>(<span style=color:#a6e22e>pp</span>)
			<span style=color:#a6e22e>doaddtimer</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>t</span>)
			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>timerMoving</span>, <span style=color:#a6e22e>timerWaiting</span>)
		<span style=color:#66d9ef>default</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
		}
	}
}
</code></pre></div><p><a href=/golang/tree/runtime.cleantimers><code>runtime.cleantimers</code></a> 函数只会处理计时器状态为 <code>timerDeleted</code>、<code>timerModifiedEarlier</code> 和 <code>timerModifiedLater</code> 的情况：</p><ul><li>如果计时器的状态为 <code>timerDeleted</code>；<ul><li>将计时器的状态修改成 <code>timerRemoving</code>；</li><li>调用 <a href=/golang/tree/runtime.dodeltimer0><code>runtime.dodeltimer0</code></a> 删除四叉堆顶上的计时器；</li><li>将计时器的状态修改成 <code>timerRemoved</code>；</li></ul></li><li>如果计时器的状态为 <code>timerModifiedEarlier</code> 或者 <code>timerModifiedLater</code>；<ul><li>将计时器的状态修改成 <code>timerMoving</code>；</li><li>使用计时器下次触发的时间 <code>nextWhen</code> 覆盖 <code>when</code>；</li><li>调用 <a href=/golang/tree/runtime.dodeltimer0><code>runtime.dodeltimer0</code></a> 删除四叉堆顶上的计时器；</li><li>调用 <a href=/golang/tree/runtime.doaddtimer><code>runtime.doaddtimer</code></a> 将计时器加入四叉堆中；</li><li>将计时器的状态修改成 <code>timerWaiting</code>；</li></ul></li></ul><p><a href=/golang/tree/runtime.cleantimers><code>runtime.cleantimers</code></a> 会删除已经标记的计时器，修改状态为 <code>timerModifiedXX</code> 的计时器。</p><h3 id=调整计时器>调整计时器
<a class=anchor href=#%e8%b0%83%e6%95%b4%e8%ae%a1%e6%97%b6%e5%99%a8>#</a></h3><p><a href=/golang/tree/runtime.adjusttimers><code>runtime.adjusttimers</code></a> 与 <a href=/golang/tree/runtime.cleantimers><code>runtime.cleantimers</code></a> 的作用相似，它们都会删除堆中的计时器并修改状态为 <code>timerModifiedEarlier</code> 和 <code>timerModifiedLater</code> 的计时器的时间，它们也会遵循相同的规则处理计时器状态：</p><ul><li><code>timerDeleted</code> -> <code>timerRemoving</code> -> <code>timerRemoved</code></li><li><code>timerModifiedXX</code> -> <code>timerMoving</code> -> <code>timerWaiting</code></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>adjusttimers</span>(<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>now</span> <span style=color:#66d9ef>int64</span>) {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>moved</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>
<span style=color:#a6e22e>loop</span>:
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timers</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timers</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>); <span style=color:#a6e22e>s</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>timerDeleted</span>:
			<span style=color:#75715e>// 删除堆中的计时器
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>timerModifiedEarlier</span>, <span style=color:#a6e22e>timerModifiedLater</span>:
			<span style=color:#75715e>// 修改计时器的时间
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>case</span> <span style=color:#f92672>...</span>
		}
	}
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>moved</span>) &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>addAdjustedTimers</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>moved</span>)
	}
}
</code></pre></div><p>与 <a href=/golang/tree/runtime.cleantimers><code>runtime.cleantimers</code></a> 不同的是，上述函数可能会遍历处理器堆中的全部计时器（包含退出条件），而不是只修改四叉堆顶部。</p><h3 id=运行计时器>运行计时器
<a class=anchor href=#%e8%bf%90%e8%a1%8c%e8%ae%a1%e6%97%b6%e5%99%a8>#</a></h3><p><a href=/golang/tree/runtime.runtimer><code>runtime.runtimer</code></a> 函数会检查处理器四叉堆上最顶上的计时器，该函数也会处理计时器的删除以及计时器时间的更新，它会遵循以下的规则处理计时器：</p><ul><li><code>timerNoStatus</code> -> 崩溃：未初始化的计时器</li><li><code>timerWaiting</code><ul><li>-> <code>timerWaiting</code></li><li>-> <code>timerRunning</code> -> <code>timerNoStatus</code></li><li>-> <code>timerRunning</code> -> <code>timerWaiting</code></li></ul></li><li><code>timerModifying</code> -> 等待状态改变</li><li><code>timerModifiedXX</code> -> <code>timerMoving</code> -> <code>timerWaiting</code></li><li><code>timerDeleted</code> -> <code>timerRemoving</code> -> <code>timerRemoved</code></li><li><code>timerRunning</code> -> 崩溃：并发调用该函数</li><li><code>timerRemoved</code>、<code>timerRemoving</code>、<code>timerMoving</code> -> 崩溃：计时器堆不一致</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runtimer</span>(<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>now</span> <span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>int64</span> {
	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timers</span>[<span style=color:#ae81ff>0</span>]
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>); <span style=color:#a6e22e>s</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>timerWaiting</span>:
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>when</span> &gt; <span style=color:#a6e22e>now</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>when</span>
			}
			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>timerRunning</span>)
			<span style=color:#a6e22e>runOneTimer</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>now</span>)
			<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>timerDeleted</span>:
			<span style=color:#75715e>// 删除计时器
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>timerModifiedEarlier</span>, <span style=color:#a6e22e>timerModifiedLater</span>:
			<span style=color:#75715e>// 修改计时器的时间
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>case</span> <span style=color:#f92672>...</span>
		}
	}
}
</code></pre></div><p>如果处理器四叉堆顶部的计时器没有到触发时间会直接返回，否则调用 <a href=/golang/tree/runtime.runOneTimer><code>runtime.runOneTimer</code></a> 运行堆顶的计时器：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runOneTimer</span>(<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>timer</span>, <span style=color:#a6e22e>now</span> <span style=color:#66d9ef>int64</span>) {
	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>f</span>
	<span style=color:#a6e22e>arg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>arg</span>
	<span style=color:#a6e22e>seq</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>seq</span>

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>period</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>delta</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>when</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>now</span>
		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>when</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>period</span> <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>delta</span><span style=color:#f92672>/</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>period</span>)
		<span style=color:#a6e22e>siftdownTimer</span>(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timers</span>, <span style=color:#ae81ff>0</span>)
		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>timerRunning</span>, <span style=color:#a6e22e>timerWaiting</span>)
		<span style=color:#a6e22e>updateTimer0When</span>(<span style=color:#a6e22e>pp</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>dodeltimer0</span>(<span style=color:#a6e22e>pp</span>)
		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>timerRunning</span>, <span style=color:#a6e22e>timerNoStatus</span>)
	}

	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timersLock</span>)
	<span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>arg</span>, <span style=color:#a6e22e>seq</span>)
	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timersLock</span>)
}
</code></pre></div><p>根据计时器的 <code>period</code> 字段，上述函数会做出不同的处理：</p><ul><li>如果 <code>period</code> 字段大于 0；<ul><li>修改计时器下一次触发的时间并更新其在堆中的位置；</li><li>将计时器的状态更新至 <code>timerWaiting</code>；</li><li>调用 <a href=/golang/tree/runtime.updateTimer0When><code>runtime.updateTimer0When</code></a> 函数设置处理器的 <code>timer0When</code> 字段；</li></ul></li><li>如果 <code>period</code> 字段小于或者等于 0；<ul><li>调用 <a href=/golang/tree/runtime.dodeltimer0><code>runtime.dodeltimer0</code></a> 函数删除计时器；</li><li>将计时器的状态更新至 <code>timerNoStatus</code>；</li></ul></li></ul><p>更新计时器之后，上述函数会运行计时器中存储的函数并传入触发时间等参数。</p><h2 id=634-触发计时器>6.3.4 触发计时器
<a class=anchor href=#634-%e8%a7%a6%e5%8f%91%e8%ae%a1%e6%97%b6%e5%99%a8>#</a></h2><p>我们在上一小节已经分析了计时器状态机中的 10 种状态以及几种操作。这里将分析器的触发过程，Go 语言会在两个模块触发计时器，运行计时器中保存的函数：</p><ul><li>调度器调度时会检查处理器中的计时器是否准备就绪；</li><li>系统监控会检查是否有未执行的到期计时器；</li></ul><p>我们将依次分析上述这两个触发过程。</p><h3 id=调度器>调度器
<a class=anchor href=#%e8%b0%83%e5%ba%a6%e5%99%a8>#</a></h3><p><a href=/golang/tree/runtime.checkTimers><code>runtime.checkTimers</code></a> 是调度器用来运行处理器中计时器的函数，它会在发生以下情况时被调用：</p><ul><li>调度器调用 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 执行调度时；</li><li>调度器调用 <a href=/golang/tree/runtime.findrunnable><code>runtime.findrunnable</code></a> 获取可执行的 Goroutine 时；</li><li>调度器调用 <a href=/golang/tree/runtime.findrunnable><code>runtime.findrunnable</code></a> 从其他处理器窃取计时器时；</li></ul><p>这里不展开介绍 <a href=/golang/tree/runtime.schedule><code>runtime.schedule</code></a> 和 <a href=/golang/tree/runtime.findrunnable><code>runtime.findrunnable</code></a> 的实现了，重点分析用于执行计时器的<a href=/golang/tree/runtime.checkTimers><code>runtime.checkTimers</code></a>，我们将该函数的实现分成调整计时器、运行计时器和删除计时器三个部分。首先是调整堆中计时器的过程：</p><ul><li>如果处理器中不存在需要调整的计时器；<ul><li>当没有需要执行的计时器时，直接返回；</li><li>当下一个计时器没有到期并且需要删除的计时器较少时都会直接返回；</li></ul></li><li>如果处理器中存在需要调整的计时器，会调用 <a href=/golang/tree/runtime.adjusttimers><code>runtime.adjusttimers</code></a>；</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>checkTimers</span>(<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>now</span> <span style=color:#66d9ef>int64</span>) (<span style=color:#a6e22e>rnow</span>, <span style=color:#a6e22e>pollUntil</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>ran</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>adjustTimers</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>next</span> <span style=color:#f92672>:=</span> int64(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timer0When</span>))
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>now</span>, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>false</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>now</span> = <span style=color:#a6e22e>nanotime</span>()
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>now</span> &lt; <span style=color:#a6e22e>next</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pp</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>() <span style=color:#f92672>||</span> int(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deletedTimers</span>)) <span style=color:#f92672>&lt;=</span> int(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>numTimers</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>) {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>now</span>, <span style=color:#a6e22e>next</span>, <span style=color:#66d9ef>false</span>
			}
		}
	}

	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timersLock</span>)
	<span style=color:#a6e22e>adjusttimers</span>(<span style=color:#a6e22e>pp</span>)
</code></pre></div><p>调整了堆中的计时器之后，会通过 <a href=/golang/tree/runtime.runtimer><code>runtime.runtimer</code></a> 依次查找堆中是否存在需要执行的计时器：</p><ul><li>如果存在，直接运行计时器；</li><li>如果不存在，获取最新计时器的触发时间；</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>rnow</span> = <span style=color:#a6e22e>now</span>
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timers</span>) &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rnow</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>rnow</span> = <span style=color:#a6e22e>nanotime</span>()
		}
		<span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timers</span>) &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tw</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtimer</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>rnow</span>); <span style=color:#a6e22e>tw</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tw</span> &gt; <span style=color:#ae81ff>0</span> {
					<span style=color:#a6e22e>pollUntil</span> = <span style=color:#a6e22e>tw</span>
				}
				<span style=color:#66d9ef>break</span>
			}
			<span style=color:#a6e22e>ran</span> = <span style=color:#66d9ef>true</span>
		}
	}
</code></pre></div><p>在 <a href=/golang/tree/runtime.checkTimers><code>runtime.checkTimers</code></a> 的最后，如果当前 Goroutine 的处理器和传入的处理器相同，并且处理器中删除的计时器是堆中计时器的 1/4 以上，就会调用 <a href=/golang/tree/runtime.clearDeletedTimers><code>runtime.clearDeletedTimers</code></a> 删除处理器全部被标记为 <code>timerDeleted</code> 的计时器，保证堆中靠后的计时器被删除。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pp</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>() <span style=color:#f92672>&amp;&amp;</span> int(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deletedTimers</span>)) &gt; len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timers</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span> {
		<span style=color:#a6e22e>clearDeletedTimers</span>(<span style=color:#a6e22e>pp</span>)
	}

	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>timersLock</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rnow</span>, <span style=color:#a6e22e>pollUntil</span>, <span style=color:#a6e22e>ran</span>
}
</code></pre></div><p><a href=/golang/tree/runtime.clearDeletedTimers><code>runtime.clearDeletedTimers</code></a> 能够避免堆中出现大量长时间运行的计时器，该函数和 <a href=/golang/tree/runtime.moveTimers><code>runtime.moveTimers</code></a> 也是唯二会遍历计时器堆的函数。</p><h3 id=系统监控>系统监控
<a class=anchor href=#%e7%b3%bb%e7%bb%9f%e7%9b%91%e6%8e%a7>#</a></h3><p>系统监控函数 <a href=/golang/tree/runtime.sysmon><code>runtime.sysmon</code></a> 也可能会触发函数的计时器，下面的代码片段中省略了大量与计时器无关的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sysmon</span>() {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>for</span> {
		<span style=color:#f92672>...</span>
		<span style=color:#a6e22e>now</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nanotime</span>()
		<span style=color:#a6e22e>next</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>timeSleepUntil</span>()
		<span style=color:#f92672>...</span>
		<span style=color:#a6e22e>lastpoll</span> <span style=color:#f92672>:=</span> int64(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lastpoll</span>))
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>netpollinited</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>lastpoll</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>lastpoll</span><span style=color:#f92672>+</span><span style=color:#ae81ff>10</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1000</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1000</span> &lt; <span style=color:#a6e22e>now</span> {
			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lastpoll</span>, uint64(<span style=color:#a6e22e>lastpoll</span>), uint64(<span style=color:#a6e22e>now</span>))
			<span style=color:#a6e22e>list</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>netpoll</span>(<span style=color:#ae81ff>0</span>)
			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>empty</span>() {
				<span style=color:#a6e22e>incidlelocked</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
				<span style=color:#a6e22e>injectglist</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>list</span>)
				<span style=color:#a6e22e>incidlelocked</span>(<span style=color:#ae81ff>1</span>)
			}
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> &lt; <span style=color:#a6e22e>now</span> {
			<span style=color:#a6e22e>startm</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>)
		}
		<span style=color:#f92672>...</span>
}
</code></pre></div><ol><li>调用 <a href=/golang/tree/runtime.timeSleepUntil><code>runtime.timeSleepUntil</code></a> 获取计时器的到期时间以及持有该计时器的堆；</li><li>如果超过 10ms 的时间没有轮询，调用 <a href=/golang/tree/runtime.netpoll><code>runtime.netpoll</code></a> 轮询网络；</li><li>如果当前有应该运行的计时器没有执行，可能存在无法被抢占的处理器，这时我们应该启动新的线程处理计时器；</li></ol><p>在上述过程中 <a href=/golang/tree/runtime.timeSleepUntil><code>runtime.timeSleepUntil</code></a> 会遍历运行时的全部处理器并查找下一个需要执行的计时器。</p><h2 id=635-小结>6.3.5 小结
<a class=anchor href=#635-%e5%b0%8f%e7%bb%93>#</a></h2><p>Go 语言的计时器在并发编程起到了非常重要的作用，它能够为我们提供比较准确的相对时间，基于它的功能，标准库中还提供了定时器、休眠等接口能够我们在 Go 语言程序中更好地处理过期和超时等问题。</p><p>标准库中的计时器在大多数情况下是能够正常工作并且高效完成任务的，但是在遇到极端情况或者性能敏感场景时，它可能没有办法胜任，而在 10ms 的这个粒度中，作者在社区中也没有找到能够使用的计时器实现，一些使用时间轮算法的开源库也不能很好地完成这个任务。</p><h2 id=636-延伸阅读>6.3.6 延伸阅读
<a class=anchor href=#636-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li>&ldquo;runtime: switch to using new timer code&rdquo; <a href=https://github.com/golang/go/commit/6becb033341602f2df9d7c55cc23e64b925bbee2>https://github.com/golang/go/commit/6becb033341602f2df9d7c55cc23e64b925bbee2</a></li><li>jaypei/use_c_sleep.go · Gist <a href=https://gist.github.com/jaypei/5334115>https://gist.github.com/jaypei/5334115</a></li><li>Alexander Morozov Vyacheslav Bakhmutov. Dec 4, 2016. &ldquo;How Do They Do It: Timers in Go&rdquo; <a href=https://blog.gopheracademy.com/advent-2016/go-timers/>https://blog.gopheracademy.com/advent-2016/go-timers/</a></li><li>Russ Cox. January 26, 2017. &ldquo;Proposal: Monotonic Elapsed Time Measurements in Go&rdquo; <a href=https://go.googlesource.com/proposal/+/master/design/12914-monotonic.md>https://go.googlesource.com/proposal/+/master/design/12914-monotonic.md</a></li></ul><h2 id=637-历史变更>6.3.7 历史变更
<a class=anchor href=#637-%e5%8e%86%e5%8f%b2%e5%8f%98%e6%9b%b4>#</a></h2><ul><li>2021-01-05 更新：Go 1.15 修改并合并了计时器处理的多个函数并改变了状态的迁移过程，这里删除了重置计数器的章节<sup id=fnref:15><a href=#fn:15 class=footnote-ref role=doc-noteref>15</a></sup>；</li></ul><p><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/ class=book-btn>上一节</a>
<a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Go 1.9 之前的计时器实现 <a href=https://github.com/golang/go/blob/093adeef4004fd029de1a8fd138802607265dc73/src/runtime/time.go>https://github.com/golang/go/blob/093adeef4004fd029de1a8fd138802607265dc73/src/runtime/time.go</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Aliaksandr Valialkin, Ian Lance Taylor. Jan 6, 2017. &ldquo;runtime: improve timers scalability on multi-CPU systems&rdquo; <a href=https://github.com/golang/go/commit/76f4fd8a5251b4f63ea14a3c1e2fe2e78eb74f81>https://github.com/golang/go/commit/76f4fd8a5251b4f63ea14a3c1e2fe2e78eb74f81</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Dmitry Vyukov. Apr 6, 2016. &ldquo;runtime: make timers faster&rdquo; <a href=https://github.com/golang/go/issues/6239#issuecomment-206361959>https://github.com/golang/go/issues/6239#issuecomment-206361959</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Dmitry Vyukov. Apr 6, 2016. &ldquo;runtime: timer doesn&rsquo;t scale on multi-CPU systems with a lot of timers #15133&rdquo; <a href=https://github.com/golang/go/issues/15133#issuecomment-206376049>https://github.com/golang/go/issues/15133#issuecomment-206376049</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Go 1.10 ~ 1.13 的计时器实现 <a href=https://github.com/golang/go/blob/76f4fd8a5251b4f63ea14a3c1e2fe2e78eb74f81/src/runtime/time.go>https://github.com/golang/go/blob/76f4fd8a5251b4f63ea14a3c1e2fe2e78eb74f81/src/runtime/time.go</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>&ldquo;time: excessive CPU usage when using Ticker and Sleep&rdquo;<a href=https://github.com/golang/go/issues/27707>https://github.com/golang/go/issues/27707</a> <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7 role=doc-endnote><p>Ian Lance Taylor. Apr 12, 2019. &ldquo;runtime, time: remove old timer code&rdquo; <a href=https://github.com/golang/go/commit/580337e268a0581bc537e67ca4005b7682be5d66>https://github.com/golang/go/commit/580337e268a0581bc537e67ca4005b7682be5d66</a> <a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8 role=doc-endnote><p>Ian Lance Taylor. &ldquo;runtime: add new addtimer function&rdquo; <a href=https://github.com/golang/go/commit/2e0aa581b4a2544249ad2f8e86e17204ca778ca7>https://github.com/golang/go/commit/2e0aa581b4a2544249ad2f8e86e17204ca778ca7</a> <a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9 role=doc-endnote><p>Ian Lance Taylor. &ldquo;runtime: add new deltimer function&rdquo; <a href=https://github.com/golang/go/commit/7416315e3358b0bc2774c92f39d8f7c4b33790ad>https://github.com/golang/go/commit/7416315e3358b0bc2774c92f39d8f7c4b33790ad</a> <a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10 role=doc-endnote><p>Ian Lance Taylor. &ldquo;runtime: add modtimer function&rdquo; <a href=https://github.com/golang/go/commit/48eb79ec2197aeea0eb43597b00cad1ebcad61d2>https://github.com/golang/go/commit/48eb79ec2197aeea0eb43597b00cad1ebcad61d2</a> <a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11 role=doc-endnote><p>Ian Lance Taylor. &ldquo;runtime: add cleantimers function&rdquo; <a href=https://github.com/golang/go/commit/466547014769bbdf7d5a62ca1019bf52d809dfcd>https://github.com/golang/go/commit/466547014769bbdf7d5a62ca1019bf52d809dfcd</a> <a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:12 role=doc-endnote><p>Ian Lance Taylor. &ldquo;runtime: add adjusttimers function&rdquo; <a href=https://github.com/golang/go/commit/220150ff3c03a0d2618093689ab129ab5ea7dc7b>https://github.com/golang/go/commit/220150ff3c03a0d2618093689ab129ab5ea7dc7b</a> <a href=#fnref:12 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:13 role=doc-endnote><p>Ian Lance Taylor. &ldquo;runtime: add new runtimer function&rdquo; <a href=https://github.com/golang/go/commit/432ca0ea83d12519004c6f7f7c1728410923987f>https://github.com/golang/go/commit/432ca0ea83d12519004c6f7f7c1728410923987f</a> <a href=#fnref:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:14 role=doc-endnote><p>Ian Lance Taylor. &ldquo;runtime: add netpollBreak&rdquo; <a href=https://github.com/golang/go/commit/50f4896b72d16b6538178c8ca851b20655075b7f>https://github.com/golang/go/commit/50f4896b72d16b6538178c8ca851b20655075b7f</a> <a href=#fnref:14 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:15 role=doc-endnote><p>Ian Lance Taylor. &ldquo;runtime: don&rsquo;t panic on racy use of timers&rdquo; <a href=https://github.com/golang/go/commit/98858c438016bbafd161b502a148558987aa44d5>https://github.com/golang/go/commit/98858c438016bbafd161b502a148558987aa44d5</a> <a href=#fnref:15 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-timer data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-timer",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#63-计时器>6.3 计时器</a><ul><li><a href=#631-设计原理>6.3.1 设计原理</a><ul><li><a href=#全局四叉堆>全局四叉堆</a></li><li><a href=#分片四叉堆>分片四叉堆</a></li><li><a href=#网络轮询器>网络轮询器</a></li></ul></li><li><a href=#632-数据结构>6.3.2 数据结构</a></li><li><a href=#633-状态机>6.3.3 状态机</a><ul><li><a href=#增加计时器>增加计时器</a></li><li><a href=#删除计时器>删除计时器</a></li><li><a href=#修改计时器>修改计时器</a></li><li><a href=#清除计时器>清除计时器</a></li><li><a href=#调整计时器>调整计时器</a></li><li><a href=#运行计时器>运行计时器</a></li></ul></li><li><a href=#634-触发计时器>6.3.4 触发计时器</a><ul><li><a href=#调度器>调度器</a></li><li><a href=#系统监控>系统监控</a></li></ul></li><li><a href=#635-小结>6.3.5 小结</a></li><li><a href=#636-延伸阅读>6.3.6 延伸阅读</a></li><li><a href=#637-历史变更>6.3.7 历史变更</a></li></ul></li></ul></nav></aside></main></body></html>