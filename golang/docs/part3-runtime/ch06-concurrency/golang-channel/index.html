<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="6.4 Channel #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  作为 Go 核心的数据结构和 Goroutine 之间的通信方式，Channel 是支撑 Go 语言高性能并发编程模型的重要结构本节会介绍管道 Channel 的设计原理、数据结构和常见操作，例如 Channel 的创建、发送、接收和关闭。虽然 Channel 与关键字 range 和 select 的关系紧密，但是因为在前面的两节中已经分析了 Channel 在不同的控制结构中组合使用时的现象，所以这里也就不会再次介绍了。
6.4.1 设计原理 #  Go 语言中最常见的、也是经常被人提及的设计模式就是：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存。在很多主流的编程语言中，多个线程传递数据的方式一般都是共享内存，为了解决线程竞争，我们需要限制同一时间能够读写这些变量的线程数量，然而这与 Go 语言鼓励的设计并不相同。
图 6-17 多线程使用共享内存传递数据
虽然我们在 Go 语言中也能使用共享内存加互斥锁进行通信，但是 Go 语言提供了一种不同的并发模型，即通信顺序进程（Communicating sequential processes，CSP）1。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据。
图 6-18 Goroutine 使用 Channel 传递数据
上图中的两个 Goroutine，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言 Channel 实现原理精要"><meta property="og:description" content="6.4 Channel #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  作为 Go 核心的数据结构和 Goroutine 之间的通信方式，Channel 是支撑 Go 语言高性能并发编程模型的重要结构本节会介绍管道 Channel 的设计原理、数据结构和常见操作，例如 Channel 的创建、发送、接收和关闭。虽然 Channel 与关键字 range 和 select 的关系紧密，但是因为在前面的两节中已经分析了 Channel 在不同的控制结构中组合使用时的现象，所以这里也就不会再次介绍了。
6.4.1 设计原理 #  Go 语言中最常见的、也是经常被人提及的设计模式就是：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存。在很多主流的编程语言中，多个线程传递数据的方式一般都是共享内存，为了解决线程竞争，我们需要限制同一时间能够读写这些变量的线程数量，然而这与 Go 语言鼓励的设计并不相同。
图 6-17 多线程使用共享内存传递数据
虽然我们在 Go 语言中也能使用共享内存加互斥锁进行通信，但是 Go 语言提供了一种不同的并发模型，即通信顺序进程（Communicating sequential processes，CSP）1。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据。
图 6-18 Goroutine 使用 Channel 传递数据
上图中的两个 Goroutine，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。"><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part3-runtime/ch06-concurrency/golang-channel/"><title>Go 语言 Channel 实现原理精要 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言 Channel 实现原理精要</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#64-channel>6.4 Channel</a><ul><li><a href=#641-设计原理>6.4.1 设计原理</a><ul><li><a href=#先入先出>先入先出</a></li><li><a href=#无锁管道>无锁管道</a></li></ul></li><li><a href=#642-数据结构>6.4.2 数据结构</a></li><li><a href=#643-创建管道>6.4.3 创建管道</a></li><li><a href=#644-发送数据>6.4.4 发送数据</a><ul><li><a href=#直接发送>直接发送</a></li><li><a href=#缓冲区>缓冲区</a></li><li><a href=#阻塞发送>阻塞发送</a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#645-接收数据>6.4.5 接收数据</a><ul><li><a href=#直接接收>直接接收</a></li><li><a href=#缓冲区-1>缓冲区</a></li><li><a href=#阻塞接收>阻塞接收</a></li><li><a href=#小结-1>小结</a></li></ul></li><li><a href=#646-关闭管道>6.4.6 关闭管道</a></li><li><a href=#647-小结>6.4.7 小结</a></li><li><a href=#648-扩展阅读>6.4.8 扩展阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=64-channel>6.4 Channel
<a class=anchor href=#64-channel>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>作为 Go 核心的数据结构和 Goroutine 之间的通信方式，Channel 是支撑 Go 语言高性能并发编程模型的重要结构本节会介绍管道 Channel 的设计原理、数据结构和常见操作，例如 Channel 的创建、发送、接收和关闭。虽然 Channel 与关键字 <code>range</code> 和 <code>select</code> 的关系紧密，但是因为在前面的两节中已经分析了 Channel 在不同的控制结构中组合使用时的现象，所以这里也就不会再次介绍了。</p><h2 id=641-设计原理>6.4.1 设计原理
<a class=anchor href=#641-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>Go 语言中最常见的、也是经常被人提及的设计模式就是：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存。在很多主流的编程语言中，多个线程传递数据的方式一般都是共享内存，为了解决线程竞争，我们需要限制同一时间能够读写这些变量的线程数量，然而这与 Go 语言鼓励的设计并不相同。</p><p><img src=https://img.draveness.me/2020-01-28-15802171487042-shared-memory.png alt=shared-memory></p><p><strong>图 6-17 多线程使用共享内存传递数据</strong></p><p>虽然我们在 Go 语言中也能使用共享内存加互斥锁进行通信，但是 Go 语言提供了一种不同的并发模型，即通信顺序进程（Communicating sequential processes，CSP）<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据。</p><p><img src=https://img.draveness.me/2020-01-28-15802171487080-channel-and-goroutines.png alt=channel-and-goroutines></p><p><strong>图 6-18 Goroutine 使用 Channel 传递数据</strong></p><p>上图中的两个 Goroutine，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。</p><h3 id=先入先出>先入先出
<a class=anchor href=#%e5%85%88%e5%85%a5%e5%85%88%e5%87%ba>#</a></h3><p>目前的 Channel 收发操作均遵循了先进先出的设计，具体规则如下：</p><ul><li>先从 Channel 读取数据的 Goroutine 会先接收到数据；</li><li>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；</li></ul><p>这种 FIFO 的设计是相对好理解的，但是稍早的 Go 语言实现却没有严格遵循这一语义，我们能在 <a href=https://github.com/golang/go/issues/11506>runtime: make sure blocked channels run operations in FIFO order</a> 中找到关于带缓冲区的 Channel 在执行收发操作时没有遵循先进先出的讨论<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</p><ul><li>发送方会向缓冲区中写入数据，然后唤醒接收方，多个接收方会尝试从缓冲区中读取数据，如果没有读取到会重新陷入休眠；</li><li>接收方会从缓冲区中读取数据，然后唤醒发送方，发送方会尝试向缓冲区写入数据，如果缓冲区已满会重新陷入休眠；</li></ul><p>这种基于重试的机制会导致 Channel 的处理不会遵循先进先出的原则。经过 <a href=https://github.com/golang/go/commit/8e496f1d6923172291658f0a785bdb47cc152325>runtime: simplify buffered channels</a> 和 <a href=https://github.com/golang/go/commit/e410a527b208e0a9acd0cded3775b302d8f2b00a>runtime: simplify chan ops, take 2</a> 两个提交的修改，带缓冲区和不带缓冲区的 Channel 都会遵循先入先出发送和接收数据<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>。</p><h3 id=无锁管道>无锁管道
<a class=anchor href=#%e6%97%a0%e9%94%81%e7%ae%a1%e9%81%93>#</a></h3><p>锁是一种常见的并发控制技术，我们一般会将锁分成乐观锁和悲观锁，即乐观并发控制和悲观并发控制，无锁（lock-free）队列更准确的描述是使用乐观并发控制的队列。乐观并发控制也叫乐观锁，很多人都会误以为乐观锁是与悲观锁差不多，然而它并不是真正的锁，只是一种并发控制的思想<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。</p><p><img src=https://img.draveness.me/2020-01-28-15802171487089-concurrency-control.png alt=concurrency-control></p><p><strong>图 6-19 悲观并发控制与乐观并发控制</strong></p><p>乐观并发控制本质上是基于验证的协议，我们使用原子指令 CAS（compare-and-swap 或者 compare-and-set）在多线程中同步数据，无锁队列的实现也依赖这一原子指令。</p><p>Channel 在运行时的内部表示是 <a href=/golang/tree/runtime.hchan><code>runtime.hchan</code></a>，该结构体中包含了用于保护成员变量的互斥锁，从某种程度上说，Channel 是一个用于同步和通信的有锁队列，使用互斥锁解决程序中可能存在的线程竞争问题是很常见的，我们能很容易地实现有锁队列。</p><p>然而锁导致的休眠和唤醒会带来额外的上下文切换，如果临界区<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>过大，加锁解锁导致的额外开销就会成为性能瓶颈。1994 年的论文 <a href=http://people.cs.pitt.edu/~jacklange/teaching/cs2510-f12/papers/implementing_lock_free.pdf>Implementing lock-free queues</a> 就研究了如何使用无锁的数据结构实现先进先出队列<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>，而 Go 语言社区也在 2014 年提出了无锁 Channel 的实现方案，该方案将 Channel 分成了以下三种类型<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>：</p><ul><li>同步 Channel — 不需要缓冲区，发送方会直接将数据交给（Handoff）接收方；</li><li>异步 Channel — 基于环形缓存的传统生产者消费者模型；</li><li><code>chan struct{}</code> 类型的异步 Channel — <code>struct{}</code> 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义；</li></ul><p>这个提案的目的也不是实现完全无锁的队列，只是在一些关键路径上通过无锁提升 Channel 的性能。社区中已经有无锁 Channel 的实现<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>，但是在实际的基准测试中，无锁队列在多核测试中的表现还需要进一步的改进<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>。</p><p>因为目前通过 CAS 实现<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>的无锁 Channel 没有提供先进先出的特性，所以该提案暂时也被搁浅了<sup id=fnref:12><a href=#fn:12 class=footnote-ref role=doc-noteref>12</a></sup>。</p><h2 id=642-数据结构>6.4.2 数据结构
<a class=anchor href=#642-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p>Go 语言的 Channel 在运行时使用 <a href=/golang/tree/runtime.hchan><code>runtime.hchan</code></a> 结构体表示。我们在 Go 语言中创建新的 Channel 时，实际上创建的都是如下所示的结构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>qcount</span>   <span style=color:#66d9ef>uint</span>
	<span style=color:#a6e22e>dataqsiz</span> <span style=color:#66d9ef>uint</span>
	<span style=color:#a6e22e>buf</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
	<span style=color:#a6e22e>elemsize</span> <span style=color:#66d9ef>uint16</span>
	<span style=color:#a6e22e>closed</span>   <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>elemtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
	<span style=color:#a6e22e>sendx</span>    <span style=color:#66d9ef>uint</span>
	<span style=color:#a6e22e>recvx</span>    <span style=color:#66d9ef>uint</span>
	<span style=color:#a6e22e>recvq</span>    <span style=color:#a6e22e>waitq</span>
	<span style=color:#a6e22e>sendq</span>    <span style=color:#a6e22e>waitq</span>

	<span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span>
}
</code></pre></div><p><a href=/golang/tree/runtime.hchan><code>runtime.hchan</code></a> 结构体中的五个字段 <code>qcount</code>、<code>dataqsiz</code>、<code>buf</code>、<code>sendx</code>、<code>recv</code> 构建底层的循环队列：</p><ul><li><code>qcount</code> — Channel 中的元素个数；</li><li><code>dataqsiz</code> — Channel 中的循环队列的长度；</li><li><code>buf</code> — Channel 的缓冲区数据指针；</li><li><code>sendx</code> — Channel 的发送操作处理到的位置；</li><li><code>recvx</code> — Channel 的接收操作处理到的位置；</li></ul><p>除此之外，<code>elemsize</code> 和 <code>elemtype</code> 分别表示当前 Channel 能够收发的元素类型和大小；<code>sendq</code> 和 <code>recvq</code> 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表，这些等待队列使用双向链表 <a href=/golang/tree/runtime.waitq><code>runtime.waitq</code></a> 表示，链表中所有的元素都是 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 结构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>waitq</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>first</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
	<span style=color:#a6e22e>last</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
}
</code></pre></div><p><a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 表示一个在等待列表中的 Goroutine，该结构中存储了两个分别指向前后 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 的指针以构成链表。</p><h2 id=643-创建管道>6.4.3 创建管道
<a class=anchor href=#643-%e5%88%9b%e5%bb%ba%e7%ae%a1%e9%81%93>#</a></h2><p>Go 语言中所有 Channel 的创建都会使用 <code>make</code> 关键字。编译器会将 <code>make(chan int, 10)</code> 表达式转换成 <code>OMAKE</code> 类型的节点，并在类型检查阶段将 <code>OMAKE</code> 类型的节点转换成 <code>OMAKECHAN</code> 类型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>typecheck1</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>top</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>res</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OMAKE</span>:
		<span style=color:#f92672>...</span>
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Etype</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TCHAN</span>:
			<span style=color:#a6e22e>l</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>args</span>) { <span style=color:#75715e>// 带缓冲区的异步 Channel
</span><span style=color:#75715e></span>				<span style=color:#f92672>...</span>
				<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>l</span>
			} <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 不带缓冲区的同步 Channel
</span><span style=color:#75715e></span>				<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>nodintconst</span>(<span style=color:#ae81ff>0</span>)
			}
			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> = <span style=color:#a6e22e>OMAKECHAN</span>
		}
	}
}
</code></pre></div><p>这一阶段会对传入 <code>make</code> 关键字的缓冲区大小进行检查，如果我们不向 <code>make</code> 传递表示缓冲区大小的参数，那么就会设置一个默认值 0，也就是当前的 Channel 不存在缓冲区。</p><p><code>OMAKECHAN</code> 类型的节点最终都会在 SSA 中间代码生成阶段之前被转换成调用 <a href=/golang/tree/runtime.makechan><code>runtime.makechan</code></a> 或者 <a href=/golang/tree/runtime.makechan64><code>runtime.makechan64</code></a> 的函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkexpr</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OMAKECHAN</span>:
		<span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>
		<span style=color:#a6e22e>fnname</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;makechan64&#34;</span>
		<span style=color:#a6e22e>argtype</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TINT64</span>]

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>IsKind</span>(<span style=color:#a6e22e>TIDEAL</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>maxintval</span>[<span style=color:#a6e22e>size</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>Etype</span>].<span style=color:#a6e22e>Cmp</span>(<span style=color:#a6e22e>maxintval</span>[<span style=color:#a6e22e>TUINT</span>]) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>fnname</span> = <span style=color:#e6db74>&#34;makechan&#34;</span>
			<span style=color:#a6e22e>argtype</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TINT</span>]
		}
		<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>mkcall1</span>(<span style=color:#a6e22e>chanfn</span>(<span style=color:#a6e22e>fnname</span>, <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>), <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>init</span>, <span style=color:#a6e22e>typename</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>), <span style=color:#a6e22e>conv</span>(<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>argtype</span>))
	}
}
</code></pre></div><p><a href=/golang/tree/runtime.makechan><code>runtime.makechan</code></a> 和 <a href=/golang/tree/runtime.makechan64><code>runtime.makechan64</code></a> 会根据传入的参数类型和缓冲区大小创建一个新的 Channel 结构，其中后者用于处理缓冲区大小大于 2 的 32 次方的情况，因为这在 Channel 中并不常见，所以我们重点关注 <a href=/golang/tree/runtime.makechan><code>runtime.makechan</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makechan</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>chantype</span>, <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span> {
	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>
	<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>size</span>))

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>
	<span style=color:#66d9ef>switch</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>mem</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>()
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>kind</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>kindNoPointers</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>:
		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span><span style=color:#f92672>+</span><span style=color:#a6e22e>mem</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>c</span>), <span style=color:#a6e22e>hchanSize</span>)
	<span style=color:#66d9ef>default</span>:
		<span style=color:#a6e22e>c</span> = new(<span style=color:#a6e22e>hchan</span>)
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
	}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemsize</span> = uint16(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span> = <span style=color:#a6e22e>elem</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> = uint(<span style=color:#a6e22e>size</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
}
</code></pre></div><p>上述代码根据 Channel 中收发元素的类型和缓冲区的大小初始化 <a href=/golang/tree/runtime.hchan><code>runtime.hchan</code></a> 和缓冲区：</p><ul><li>如果当前 Channel 中不存在缓冲区，那么就只会为 <a href=/golang/tree/runtime.hchan><code>runtime.hchan</code></a> 分配一段内存空间；</li><li>如果当前 Channel 中存储的类型不是指针类型，会为当前的 Channel 和底层的数组分配一块连续的内存空间；</li><li>在默认情况下会单独为 <a href=/golang/tree/runtime.hchan><code>runtime.hchan</code></a> 和缓冲区分配内存；</li></ul><p>在函数的最后会统一更新 <a href=/golang/tree/runtime.hchan><code>runtime.hchan</code></a> 的 <code>elemsize</code>、<code>elemtype</code> 和 <code>dataqsiz</code> 几个字段。</p><h2 id=644-发送数据>6.4.4 发送数据
<a class=anchor href=#644-%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae>#</a></h2><p>当我们想要向 Channel 发送数据时，就需要使用 <code>ch &lt;- i</code> 语句，编译器会将它解析成 <code>OSEND</code> 节点并在 <a href=/golang/tree/cmd/compile/internal/gc.walkexpr><code>cmd/compile/internal/gc.walkexpr</code></a> 中转换成 <a href=/golang/tree/runtime.chansend1><code>runtime.chansend1</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkexpr</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OSEND</span>:
		<span style=color:#a6e22e>n1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>
		<span style=color:#a6e22e>n1</span> = <span style=color:#a6e22e>assignconv</span>(<span style=color:#a6e22e>n1</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>Elem</span>(), <span style=color:#e6db74>&#34;chan send&#34;</span>)
		<span style=color:#a6e22e>n1</span> = <span style=color:#a6e22e>walkexpr</span>(<span style=color:#a6e22e>n1</span>, <span style=color:#a6e22e>init</span>)
		<span style=color:#a6e22e>n1</span> = <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OADDR</span>, <span style=color:#a6e22e>n1</span>, <span style=color:#66d9ef>nil</span>)
		<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>mkcall1</span>(<span style=color:#a6e22e>chanfn</span>(<span style=color:#e6db74>&#34;chansend1&#34;</span>, <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>), <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>init</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>n1</span>)
	}
}
</code></pre></div><p><a href=/golang/tree/runtime.chansend1><code>runtime.chansend1</code></a> 只是调用了 <a href=/golang/tree/runtime.chansend><code>runtime.chansend</code></a> 并传入 Channel 和需要发送的数据。<a href=/golang/tree/runtime.chansend><code>runtime.chansend</code></a> 是向 Channel 中发送数据时一定会调用的函数，该函数包含了发送数据的全部逻辑，如果我们在调用时将 <code>block</code> 参数设置成 <code>true</code>，那么表示当前发送操作是阻塞的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
	}
</code></pre></div><p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止多个线程并发修改数据。如果 Channel 已经关闭，那么向该 Channel 发送数据时会报 &ldquo;send on closed channel&rdquo; 错误并中止程序。</p><p>因为 <a href=/golang/tree/runtime.chansend><code>runtime.chansend</code></a> 函数的实现比较复杂，所以我们这里将该函数的执行过程分成以下的三个部分：</p><ul><li>当存在等待的接收者时，通过 <a href=/golang/tree/runtime.send><code>runtime.send</code></a> 直接将数据发送给阻塞的接收者；</li><li>当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；</li><li>当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据；</li></ul><h3 id=直接发送>直接发送
<a class=anchor href=#%e7%9b%b4%e6%8e%a5%e5%8f%91%e9%80%81>#</a></h3><p>如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine，那么 <a href=/golang/tree/runtime.chansend><code>runtime.chansend</code></a> 会从接收队列 <code>recvq</code> 中取出最先陷入等待的 Goroutine 并直接向它发送数据：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
	}
</code></pre></div><p>下图展示了 Channel 中存在等待数据的 Goroutine 时，向 Channel 发送数据的过程：</p><p><img src=https://img.draveness.me/2020-01-29-15802354027250-channel-direct-send.png alt=channel-direct-send></p><p><strong>图 6-20 直接发送数据的过程</strong></p><p>发送数据时会调用 <a href=/golang/tree/runtime.send><code>runtime.send</code></a>，该函数的执行可以分成两个部分：</p><ol><li>调用 <a href=/golang/tree/runtime.sendDirect><code>runtime.sendDirect</code></a> 将发送的数据直接拷贝到 <code>x = &lt;-c</code> 表达式中变量 <code>x</code> 所在的内存地址上；</li><li>调用 <a href=/golang/tree/runtime.goready><code>runtime.goready</code></a> 将等待接收数据的 Goroutine 标记成可运行状态 <code>Grunnable</code> 并把该 Goroutine 放到发送方所在的处理器的 <code>runnext</code> 上等待执行，该处理器在下一次调度时会立刻唤醒数据的接收方；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>skip</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>sendDirect</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>)
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
	<span style=color:#a6e22e>unlockf</span>()
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
	<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>skip</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
}
</code></pre></div><p>需要注意的是，发送数据的过程只是将接收方的 Goroutine 放到了处理器的 <code>runnext</code> 中，程序没有立刻执行该 Goroutine。</p><h3 id=缓冲区>缓冲区
<a class=anchor href=#%e7%bc%93%e5%86%b2%e5%8c%ba>#</a></h3><p>如果创建的 Channel 包含缓冲区并且 Channel 中的数据没有装满，会执行下面这段代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &lt; <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>)
		<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>, <span style=color:#a6e22e>ep</span>)
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span><span style=color:#f92672>++</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#ae81ff>0</span>
		}
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>++</span>
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>在这里我们首先会使用 <a href=/golang/tree/runtime.chanbuf><code>runtime.chanbuf</code></a> 计算出下一个可以存储数据的位置，然后通过 <a href=/golang/tree/runtime.typedmemmove><code>runtime.typedmemmove</code></a> 将发送的数据拷贝到缓冲区中并增加 <code>sendx</code> 索引和 <code>qcount</code> 计数器。</p><p><img src=https://img.draveness.me/2020-01-28-15802171487104-channel-buffer-send.png alt=channel-buffer-send></p><p><strong>图 6-21 向缓冲区写入数据</strong></p><p>如果当前 Channel 的缓冲区未满，向 Channel 发送的数据会存储在 Channel 的 <code>sendx</code> 索引所在的位置并将 <code>sendx</code> 索引加一。因为这里的 <code>buf</code> 是一个循环数组，所以当 <code>sendx</code> 等于 <code>dataqsiz</code> 时会重新回到数组开始的位置。</p><h3 id=阻塞发送>阻塞发送
<a class=anchor href=#%e9%98%bb%e5%a1%9e%e5%8f%91%e9%80%81>#</a></h3><p>当 Channel 没有接收者能够处理数据时，向 Channel 发送数据会被下游阻塞，当然使用 <code>select</code> 关键字可以向 Channel 非阻塞地发送消息。向 Channel 阻塞地发送数据会执行下面的代码，我们可以简单梳理一下这段代码的逻辑：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
	}

	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>)
	<span style=color:#a6e22e>goparkunlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>waitReasonChanSend</span>, <span style=color:#a6e22e>traceEvGoBlockSend</span>, <span style=color:#ae81ff>3</span>)

	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
</code></pre></div><ol><li>调用 <a href=/golang/tree/runtime.getg><code>runtime.getg</code></a> 获取发送数据使用的 Goroutine；</li><li>执行 <a href=/golang/tree/runtime.acquireSudog><code>runtime.acquireSudog</code></a> 获取 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 结构并设置这一次阻塞发送的相关信息，例如发送的 Channel、是否在 select 中和待发送数据的内存地址等；</li><li>将刚刚创建并初始化的 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 加入发送等待队列，并设置到当前 Goroutine 的 <code>waiting</code> 上，表示 Goroutine 正在等待该 <code>sudog</code> 准备就绪；</li><li>调用 <a href=/golang/tree/runtime.goparkunlock><code>runtime.goparkunlock</code></a> 将当前的 Goroutine 陷入沉睡等待唤醒；</li><li>被调度器唤醒后会执行一些收尾工作，将一些属性置零并且释放 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 结构体；</li></ol><p>函数在最后会返回 <code>true</code> 表示这次我们已经成功向 Channel 发送了数据。</p><h3 id=小结>小结
<a class=anchor href=#%e5%b0%8f%e7%bb%93>#</a></h3><p>我们在这里可以简单梳理和总结一下使用 <code>ch &lt;- i</code> 表达式向 Channel 发送数据时遇到的几种情况：</p><ol><li>如果当前 Channel 的 <code>recvq</code> 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前 Goroutine 并将其设置成下一个运行的 Goroutine；</li><li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 <code>sendx</code> 所在的位置上；</li><li>如果不满足上面的两种情况，会创建一个 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 结构并将其加入 Channel 的 <code>sendq</code> 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</li></ol><p>发送数据的过程中包含几个会触发 Goroutine 调度的时机：</p><ol><li>发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 <code>runnext</code> 属性，但是并不会立刻触发调度；</li><li>发送数据时并没有找到接收方并且缓冲区已经满了，这时会将自己加入 Channel 的 <code>sendq</code> 队列并调用 <a href=/golang/tree/runtime.goparkunlock><code>runtime.goparkunlock</code></a> 触发 Goroutine 的调度让出处理器的使用权；</li></ol><h2 id=645-接收数据>6.4.5 接收数据
<a class=anchor href=#645-%e6%8e%a5%e6%94%b6%e6%95%b0%e6%8d%ae>#</a></h2><p>我们接下来继续介绍 Channel 操作的另一方：接收数据。Go 语言中可以使用两种不同的方式去接收 Channel 中的数据：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>ch</span>
<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>ch</span>
</code></pre></div><p>这两种不同的方法经过编译器的处理都会变成 <code>ORECV</code> 类型的节点，后者会在类型检查阶段被转换成 <code>OAS2RECV</code> 类型。数据的接收操作遵循以下的路线图：</p><p><img src=https://img.draveness.me/2020-01-28-15802171487111-channel-receive-node.png alt=channel-receive-node></p><p><strong>图 6-22 Channel 接收操作的路线图</strong></p><p>虽然不同的接收方式会被转换成 <a href=/golang/tree/runtime.chanrecv1><code>runtime.chanrecv1</code></a> 和 <a href=/golang/tree/runtime.chanrecv2><code>runtime.chanrecv2</code></a> 两种不同函数的调用，但是这两个函数最终还是会调用 <a href=/golang/tree/runtime.chanrecv><code>runtime.chanrecv</code></a>。</p><p>当我们从一个空 Channel 接收数据时会直接调用 <a href=/golang/tree/runtime.gopark><code>runtime.gopark</code></a> 让出处理器的使用权。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#a6e22e>selected</span>, <span style=color:#a6e22e>received</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
			<span style=color:#66d9ef>return</span>
		}
		<span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanReceiveNilChan</span>, <span style=color:#a6e22e>traceEvGoStop</span>, <span style=color:#ae81ff>2</span>)
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
	}

	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>)
		}
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>
	}
</code></pre></div><p>如果当前 Channel 已经被关闭并且缓冲区中不存在任何数据，那么会清除 <code>ep</code> 指针中的数据并立刻返回。</p><p>除了上述两种特殊情况，使用 <a href=/golang/tree/runtime.chanrecv><code>runtime.chanrecv</code></a> 从 Channel 接收数据时还包含以下三种不同情况：</p><ul><li>当存在等待的发送者时，通过 <a href=/golang/tree/runtime.recv><code>runtime.recv</code></a> 从阻塞的发送者或者缓冲区中获取数据；</li><li>当缓冲区存在数据时，从 Channel 的缓冲区中接收数据；</li><li>当缓冲区中不存在数据时，等待其他 Goroutine 向 Channel 发送数据；</li></ul><h3 id=直接接收>直接接收
<a class=anchor href=#%e7%9b%b4%e6%8e%a5%e6%8e%a5%e6%94%b6>#</a></h3><p>当 Channel 的 <code>sendq</code> 队列中包含处于等待状态的 Goroutine 时，该函数会取出队列头等待的 Goroutine，处理的逻辑和发送时相差无几，只是发送数据时调用的是 <a href=/golang/tree/runtime.send><code>runtime.send</code></a> 函数，而接收数据时使用 <a href=/golang/tree/runtime.recv><code>runtime.recv</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>recv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>
	}
</code></pre></div><p><a href=/golang/tree/runtime.recv><code>runtime.recv</code></a> 的实现比较复杂：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>recv</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>skip</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>recvDirect</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>)
		}
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#a6e22e>qp</span>)
		}
		<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>, <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>)
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#75715e>// c.sendx = (c.sendx+1) % c.dataqsiz
</span><span style=color:#75715e></span>	}
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
	<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>skip</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
}
</code></pre></div><p>该函数会根据缓冲区的大小分别处理不同的情况：</p><ul><li>如果 Channel 不存在缓冲区；<ol><li>调用 <a href=/golang/tree/runtime.recvDirect><code>runtime.recvDirect</code></a> 将 Channel 发送队列中 Goroutine 存储的 <code>elem</code> 数据拷贝到目标内存地址中；</li></ol></li><li>如果 Channel 存在缓冲区；<ol><li>将队列中的数据拷贝到接收方的内存地址；</li><li>将发送队列头的数据拷贝到缓冲区中，释放一个阻塞的发送方；</li></ol></li></ul><p>无论发生哪种情况，运行时都会调用 <a href=/golang/tree/runtime.goready><code>runtime.goready</code></a> 将当前处理器的 <code>runnext</code> 设置成发送数据的 Goroutine，在调度器下一次调度时将阻塞的发送方唤醒。</p><p><img src=https://img.draveness.me/2020-01-28-15802171487118-channel-receive-from-sendq.png alt=channel-receive-from-sendq></p><p><strong>图 6-23 从发送队列中获取数据</strong></p><p>上图展示了 Channel 在缓冲区已经没有空间并且发送队列中存在等待的 Goroutine 时，运行 <code>&lt;-ch</code> 的执行过程。发送队列头的 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 中的元素会替换接收索引 <code>recvx</code> 所在位置的元素，原有的元素会被拷贝到接收数据的变量对应的内存空间上。</p><h3 id=缓冲区-1>缓冲区
<a class=anchor href=#%e7%bc%93%e5%86%b2%e5%8c%ba-1>#</a></h3><p>当 Channel 的缓冲区中已经包含数据时，从 Channel 中接收数据会直接从缓冲区中 <code>recvx</code> 的索引位置中取出数据进行处理：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#a6e22e>selected</span>, <span style=color:#a6e22e>received</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#a6e22e>qp</span>)
		}
		<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>)
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> = <span style=color:#ae81ff>0</span>
		}
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>--</span>
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>如果接收数据的内存地址不为空，那么会使用 <a href=/golang/tree/runtime.typedmemmove><code>runtime.typedmemmove</code></a> 将缓冲区中的数据拷贝到内存中、清除队列中的数据并完成收尾工作。</p><p><img src=https://img.draveness.me/2020-01-28-15802171487125-channel-buffer-receive.png alt=channel-buffer-receive></p><p><strong>图 6-24 从缓冲区中接接收数据</strong></p><p>收尾工作包括递增 <code>recvx</code>，一旦发现索引超过了 Channel 的容量时，会将它归零重置循环队列的索引；除此之外，该函数还会减少 <code>qcount</code> 计数器并释放持有 Channel 的锁。</p><h3 id=阻塞接收>阻塞接收
<a class=anchor href=#%e9%98%bb%e5%a1%9e%e6%8e%a5%e6%94%b6>#</a></h3><p>当 Channel 的发送队列中不存在等待的 Goroutine 并且缓冲区中也不存在任何数据时，从管道中接收数据的操作会变成阻塞的，然而不是所有的接收操作都是阻塞的，与 <code>select</code> 语句结合使用时就可能会使用到非阻塞的接收操作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#a6e22e>selected</span>, <span style=color:#a6e22e>received</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>
	}

	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>)
	<span style=color:#a6e22e>goparkunlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>waitReasonChanReceive</span>, <span style=color:#a6e22e>traceEvGoBlockRecv</span>, <span style=color:#ae81ff>3</span>)

	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>closed</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, !<span style=color:#a6e22e>closed</span>
}
</code></pre></div><p>在正常的接收场景中，我们会使用 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 将当前 Goroutine 包装成一个处于等待状态的 Goroutine 并将其加入到接收队列中。</p><p>完成入队之后，上述代码还会调用 <a href=/golang/tree/runtime.goparkunlock><code>runtime.goparkunlock</code></a> 立刻触发 Goroutine 的调度，让出处理器的使用权并等待调度器的调度。</p><h3 id=小结-1>小结
<a class=anchor href=#%e5%b0%8f%e7%bb%93-1>#</a></h3><p>我们梳理一下从 Channel 中接收数据时可能会发生的五种情况：</p><ol><li>如果 Channel 为空，那么会直接调用 <a href=/golang/tree/runtime.gopark><code>runtime.gopark</code></a> 挂起当前 Goroutine；</li><li>如果 Channel 已经关闭并且缓冲区没有任何数据，<a href=/golang/tree/runtime.chanrecv><code>runtime.chanrecv</code></a> 会直接返回；</li><li>如果 Channel 的 <code>sendq</code> 队列中存在挂起的 Goroutine，会将 <code>recvx</code> 索引所在的数据拷贝到接收变量所在的内存空间上并将 <code>sendq</code> 队列中 Goroutine 的数据拷贝到缓冲区；</li><li>如果 Channel 的缓冲区中包含数据，那么直接读取 <code>recvx</code> 索引对应的数据；</li><li>在默认情况下会挂起当前的 Goroutine，将 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 结构加入 <code>recvq</code> 队列并陷入休眠等待调度器的唤醒；</li></ol><p>我们总结一下从 Channel 接收数据时，会触发 Goroutine 调度的两个时机：</p><ol><li>当 Channel 为空时；</li><li>当缓冲区中不存在数据并且也不存在数据的发送者时；</li></ol><h2 id=646-关闭管道>6.4.6 关闭管道
<a class=anchor href=#646-%e5%85%b3%e9%97%ad%e7%ae%a1%e9%81%93>#</a></h2><p>编译器会将用于关闭管道的 <code>close</code> 关键字转换成 <code>OCLOSE</code> 节点以及 <a href=/golang/tree/runtime.closechan><code>runtime.closechan</code></a> 函数。</p><p>当 Channel 是一个空指针或者已经被关闭时，Go 语言运行时都会直接崩溃并抛出异常：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>closechan</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of nil channel&#34;</span>))
	}

	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of closed channel&#34;</span>))
	}
</code></pre></div><p>处理完了这些异常的情况之后就可以开始执行关闭 Channel 的逻辑了，下面这段代码的主要工作就是将 <code>recvq</code> 和 <code>sendq</code> 两个队列中的数据加入到 Goroutine 列表 <code>gList</code> 中，与此同时该函数会清除所有 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 上未被处理的元素：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> = <span style=color:#ae81ff>1</span>

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>glist</span> <span style=color:#a6e22e>gList</span>
	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>)
			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
		}
		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>)
	}

	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeue</span>()
		<span style=color:#f92672>...</span>
	}
	<span style=color:#66d9ef>for</span> !<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>empty</span>() {
		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>pop</span>()
		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>schedlink</span> = <span style=color:#ae81ff>0</span>
		<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#ae81ff>3</span>)
	}
}
</code></pre></div><p>该函数在最后会为所有被阻塞的 Goroutine 调用 <a href=/golang/tree/runtime.goready><code>runtime.goready</code></a> 触发调度。</p><h2 id=647-小结>6.4.7 小结
<a class=anchor href=#647-%e5%b0%8f%e7%bb%93>#</a></h2><p>Channel 是 Go 语言能够提供强大并发能力的原因之一，我们在这一节中分析了 Channel 的设计原理、数据结构以及发送数据、接收数据和关闭 Channel 这些基本操作，相信能够帮助大家更好地理解 Channel 的工作原理。</p><h2 id=648-扩展阅读>6.4.8 扩展阅读
<a class=anchor href=#648-%e6%89%a9%e5%b1%95%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=https://github.com/golang/go/issues/8899>Dmitry Vyukov. Oct, 2014.&ldquo;runtime: lock-free channels&rdquo;</a></li><li><a href=https://doi.org/10.1145/248052.248106>Simple, fast, and practical non-blocking and blocking concurrent queue algorithms</a></li><li><a href=https://golang.org/ref/spec#Channel_types>Channel types · The Go Programming Language Specification</a></li><li><a href=http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/>Concurrency in Golang</a></li><li><a href=https://en.wikipedia.org/wiki/Communicating_sequential_processes>Communicating sequential processes</a></li><li><a href=https://golang.org/doc/faq#csp>Why build concurrency on the ideas of CSP?</a></li><li><a href=https://dave.cheney.net/2015/08/08/performance-without-the-event-loop>Performance without the event loop</a></li></ul><p><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/ class=book-btn>上一节</a>
<a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>C. A. R. Hoare. 1978. Communicating sequential processes. Commun. ACM 21, 8 (August 1978), 666–677. <a href=https://doi.org/10.1145/359576.359585>https://doi.org/10.1145/359576.359585</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Russ Cox. Jul, 2015. &ldquo;runtime: make sure blocked channels run operations in FIFO order&rdquo; <a href=https://github.com/golang/go/issues/11506>https://github.com/golang/go/issues/11506</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Keith Randall. Mar, 2015. &ldquo;runtime: simplify buffered channels.&rdquo; <a href=https://github.com/golang/go/commit/8e496f1d6923172291658f0a785bdb47cc152325>https://github.com/golang/go/commit/8e496f1d6923172291658f0a785bdb47cc152325</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Keith Randall. Nov, 2015. &ldquo;runtime: simplify chan ops, take 2&rdquo; <a href=https://github.com/golang/go/commit/e410a527b208e0a9acd0cded3775b302d8f2b00a>https://github.com/golang/go/commit/e410a527b208e0a9acd0cded3775b302d8f2b00a</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Draven. Oct 2017. &ldquo;浅谈数据库并发控制 - 锁和 MVCC&rdquo; <a href=/database-concurrency-control>/database-concurrency-control</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>Wikipedia: Critical section <a href=https://en.wikipedia.org/wiki/Critical_section>https://en.wikipedia.org/wiki/Critical_section</a> <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7 role=doc-endnote><p>Valois, J.D., 1994, October. Implementing lock-free queues. In Proceedings of the seventh international conference on Parallel and Distributed Computing Systems (pp. 64-69). <a href=http://people.cs.pitt.edu/~jacklange/teaching/cs2510-f12/papers/implementing_lock_free.pdf>http://people.cs.pitt.edu/~jacklange/teaching/cs2510-f12/papers/implementing_lock_free.pdf</a> <a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8 role=doc-endnote><p>Dmitry Vyukov. Jan, 2014. &ldquo;Go channels on steroids&rdquo; <a href=https://docs.google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub>https://docs.google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub</a> <a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9 role=doc-endnote><p>Ahmed W. A scalable lock-free channel. <a href=https://github.com/OneOfOne/lfchan/blob/master/lfchan.go>https://github.com/OneOfOne/lfchan/blob/master/lfchan.go</a> <a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10 role=doc-endnote><p>Jon Gjengset. Mar, 2016. &ldquo;Fix poor scalability to many (true-SMP) cores&rdquo; <a href=https://github.com/OneOfOne/lfchan/issues/3>https://github.com/OneOfOne/lfchan/issues/3</a> <a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11 role=doc-endnote><p>Dmitry Vyukov. 2014. &ldquo;runtime: chans on steroids&rdquo; <a href=https://codereview.appspot.com/12544043>https://codereview.appspot.com/12544043</a> <a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:12 role=doc-endnote><p>Dmitry Vyukov. Dec, 2016. &ldquo;algorithm does not apply per se&rdquo; <a href=https://github.com/golang/go/issues/8899#issuecomment-269321360>https://github.com/golang/go/issues/8899#issuecomment-269321360</a> <a href=#fnref:12 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-channel data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-channel",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#64-channel>6.4 Channel</a><ul><li><a href=#641-设计原理>6.4.1 设计原理</a><ul><li><a href=#先入先出>先入先出</a></li><li><a href=#无锁管道>无锁管道</a></li></ul></li><li><a href=#642-数据结构>6.4.2 数据结构</a></li><li><a href=#643-创建管道>6.4.3 创建管道</a></li><li><a href=#644-发送数据>6.4.4 发送数据</a><ul><li><a href=#直接发送>直接发送</a></li><li><a href=#缓冲区>缓冲区</a></li><li><a href=#阻塞发送>阻塞发送</a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#645-接收数据>6.4.5 接收数据</a><ul><li><a href=#直接接收>直接接收</a></li><li><a href=#缓冲区-1>缓冲区</a></li><li><a href=#阻塞接收>阻塞接收</a></li><li><a href=#小结-1>小结</a></li></ul></li><li><a href=#646-关闭管道>6.4.6 关闭管道</a></li><li><a href=#647-小结>6.4.7 小结</a></li><li><a href=#648-扩展阅读>6.4.8 扩展阅读</a></li></ul></li></ul></nav></aside></main></body></html>