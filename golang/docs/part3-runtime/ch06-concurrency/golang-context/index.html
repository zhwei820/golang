<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="6.1 上下文 Context #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  上下文 context.Context Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。
context.Context 是 Go 语言在 1.7 版本中引入标准库的接口1，该接口定义了四个需要实现的方法，其中包括：
 Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期； Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 Channel； Err — 返回 context.Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空的值；  如果 context.Context 被取消，会返回 Canceled 错误； 如果 context.Context 超时，会返回 DeadlineExceeded 错误；   Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；  type Context interface { Deadline() (deadline time."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言并发编程与 Context"><meta property="og:description" content="6.1 上下文 Context #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  上下文 context.Context Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。
context.Context 是 Go 语言在 1.7 版本中引入标准库的接口1，该接口定义了四个需要实现的方法，其中包括：
 Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期； Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 Channel； Err — 返回 context.Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空的值；  如果 context.Context 被取消，会返回 Canceled 错误； 如果 context.Context 超时，会返回 DeadlineExceeded 错误；   Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；  type Context interface { Deadline() (deadline time."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part3-runtime/ch06-concurrency/golang-context/"><title>Go 语言并发编程与 Context | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言并发编程与 Context</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#61-上下文-context>6.1 上下文 Context</a><ul><li><a href=#611-设计原理>6.1.1 设计原理</a></li><li><a href=#612-默认上下文>6.1.2 默认上下文</a></li><li><a href=#613-取消信号>6.1.3 取消信号</a></li><li><a href=#614-传值方法>6.1.4 传值方法</a></li><li><a href=#615-小结>6.1.5 小结</a></li><li><a href=#616-延伸阅读>6.1.6 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=61-上下文-context>6.1 上下文 Context
<a class=anchor href=#61-%e4%b8%8a%e4%b8%8b%e6%96%87-context>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>上下文 <a href=/golang/tree/context.Context><code>context.Context</code></a> Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。</p><p><a href=/golang/tree/context.Context><code>context.Context</code></a> 是 Go 语言在 1.7 版本中引入标准库的接口<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，该接口定义了四个需要实现的方法，其中包括：</p><ol><li><code>Deadline</code> — 返回 <a href=/golang/tree/context.Context><code>context.Context</code></a> 被取消的时间，也就是完成工作的截止日期；</li><li><code>Done</code> — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 <code>Done</code> 方法会返回同一个 Channel；</li><li><code>Err</code> — 返回 <a href=/golang/tree/context.Context><code>context.Context</code></a> 结束的原因，它只会在 <code>Done</code> 方法对应的 Channel 关闭时返回非空的值；<ol><li>如果 <a href=/golang/tree/context.Context><code>context.Context</code></a> 被取消，会返回 <code>Canceled</code> 错误；</li><li>如果 <a href=/golang/tree/context.Context><code>context.Context</code></a> 超时，会返回 <code>DeadlineExceeded</code> 错误；</li></ol></li><li><code>Value</code> — 从 <a href=/golang/tree/context.Context><code>context.Context</code></a> 中获取键对应的值，对于同一个上下文来说，多次调用 <code>Value</code> 并传入相同的 <code>Key</code> 会返回相同的结果，该方法可以用来传递请求特定的数据；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Context</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Deadline</span>() (<span style=color:#a6e22e>deadline</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>, <span style=color:#a6e22e>ok</span> <span style=color:#66d9ef>bool</span>)
	<span style=color:#a6e22e>Done</span>() <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}
	<span style=color:#a6e22e>Err</span>() <span style=color:#66d9ef>error</span>
	<span style=color:#a6e22e>Value</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>interface</span>{}
}
</code></pre></div><p><a href=https://github.com/golang/go/tree/master/src/context><code>context</code></a> 包中提供的 <a href=/golang/tree/context.Background><code>context.Background</code></a>、<a href=/golang/tree/context.TODO><code>context.TODO</code></a>、<a href=/golang/tree/context.WithDeadline><code>context.WithDeadline</code></a> 和 <a href=/golang/tree/context.WithValue><code>context.WithValue</code></a> 函数会返回实现该接口的私有结构体，我们会在后面详细介绍它们的工作原理。</p><h2 id=611-设计原理>6.1.1 设计原理
<a class=anchor href=#611-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 <a href=/golang/tree/context.Context><code>context.Context</code></a> 的最大作用。Go 服务的每一个请求都是通过单独的 Goroutine 处理的<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，HTTP/RPC 请求的处理器会启动新的 Goroutine 访问数据库和其他服务。</p><p>如下图所示，我们可能会创建多个 Goroutine 来处理一次请求，而 <a href=/golang/tree/context.Context><code>context.Context</code></a> 的作用是在不同 Goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。</p><p><img src=https://img.draveness.me/golang-context-usage.png alt=golang-context-usage></p><p><strong>图 6-1 Context 与 Goroutine 树</strong></p><p>每一个 <a href=/golang/tree/context.Context><code>context.Context</code></a> 都会从最顶层的 Goroutine 一层一层传递到最下层。<a href=/golang/tree/context.Context><code>context.Context</code></a> 可以在上层 Goroutine 执行出现错误时，将信号及时同步给下层。</p><p><img src=https://img.draveness.me/golang-without-context.png alt=golang-without-context></p><p><strong>图 6-2 不使用 Context 同步信号</strong></p><p>如上图所示，当最上层的 Goroutine 因为某些原因执行失败时，下层的 Goroutine 由于没有接收到这个信号所以会继续工作；但是当我们正确地使用 <a href=/golang/tree/context.Context><code>context.Context</code></a> 时，就可以在下层及时停掉无用的工作以减少额外资源的消耗：</p><p><img src=https://img.draveness.me/golang-with-context.png alt=golang-with-context></p><p><strong>图 6-3 使用 Context 同步信号</strong></p><p>我们可以通过一个代码片段了解 <a href=/golang/tree/context.Context><code>context.Context</code></a> 是如何对信号进行同步的。在这段代码中，我们创建了一个过期时间为 1s 的上下文，并向上下文传入 <code>handle</code> 函数，该方法会使用 500ms 的时间处理传入的请求：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#ae81ff>1</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cancel</span>()

	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>handle</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#ae81ff>500</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#66d9ef>select</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main&#34;</span>, <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>())
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handle</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>duration</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>) {
	<span style=color:#66d9ef>select</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;handle&#34;</span>, <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>())
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>After</span>(<span style=color:#a6e22e>duration</span>):
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;process request with&#34;</span>, <span style=color:#a6e22e>duration</span>)
	}
}
</code></pre></div><p>因为过期时间大于处理时间，所以我们有足够的时间处理该请求，运行上述代码会打印出下面的内容：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>context</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>process</span> <span style=color:#a6e22e>request</span> <span style=color:#a6e22e>with</span> <span style=color:#ae81ff>500</span><span style=color:#a6e22e>ms</span>
<span style=color:#a6e22e>main</span> <span style=color:#a6e22e>context</span> <span style=color:#a6e22e>deadline</span> <span style=color:#a6e22e>exceeded</span>
</code></pre></div><p><code>handle</code> 函数没有进入超时的 <code>select</code> 分支，但是 <code>main</code> 函数的 <code>select</code> 却会等待 <a href=/golang/tree/context.Context><code>context.Context</code></a> 超时并打印出 <code>main context deadline exceeded</code>。</p><p>如果我们将处理请求时间增加至 1500ms，整个程序都会因为上下文的过期而被中止，：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>context</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>main</span> <span style=color:#a6e22e>context</span> <span style=color:#a6e22e>deadline</span> <span style=color:#a6e22e>exceeded</span>
<span style=color:#a6e22e>handle</span> <span style=color:#a6e22e>context</span> <span style=color:#a6e22e>deadline</span> <span style=color:#a6e22e>exceeded</span>
</code></pre></div><p>相信这两个例子能够帮助各位读者理解 <a href=/golang/tree/context.Context><code>context.Context</code></a> 的使用方法和设计原理 — 多个 Goroutine 同时订阅 <code>ctx.Done()</code> 管道中的消息，一旦接收到取消信号就立刻停止当前正在执行的工作。</p><h2 id=612-默认上下文>6.1.2 默认上下文
<a class=anchor href=#612-%e9%bb%98%e8%ae%a4%e4%b8%8a%e4%b8%8b%e6%96%87>#</a></h2><p><a href=https://github.com/golang/go/tree/master/src/context><code>context</code></a> 包中最常用的方法还是 <a href=/golang/tree/context.Background><code>context.Background</code></a>、<a href=/golang/tree/context.TODO><code>context.TODO</code></a>，这两个方法都会返回预先初始化好的私有变量 <code>background</code> 和 <code>todo</code>，它们会在同一个 Go 程序中被复用：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Background</span>() <span style=color:#a6e22e>Context</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>background</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TODO</span>() <span style=color:#a6e22e>Context</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>todo</span>
}
</code></pre></div><p>这两个私有变量都是通过 <code>new(emptyCtx)</code> 语句初始化的，它们是指向私有结构体 <a href=/golang/tree/context.emptyCtx><code>context.emptyCtx</code></a> 的指针，这是最简单、最常用的上下文类型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>emptyCtx</span> <span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyCtx</span>) <span style=color:#a6e22e>Deadline</span>() (<span style=color:#a6e22e>deadline</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>, <span style=color:#a6e22e>ok</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#66d9ef>return</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyCtx</span>) <span style=color:#a6e22e>Done</span>() <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{} {
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyCtx</span>) <span style=color:#a6e22e>Err</span>() <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyCtx</span>) <span style=color:#a6e22e>Value</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>interface</span>{} {
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>从上述代码中，我们不难发现 <a href=/golang/tree/context.emptyCtx><code>context.emptyCtx</code></a> 通过空方法实现了 <a href=/golang/tree/context.Context><code>context.Context</code></a> 接口中的所有方法，它没有任何功能。</p><p><img src=https://img.draveness.me/golang-context-hierarchy.png alt=golang-context-hierarchy></p><p><strong>图 6-4 Context 层级关系</strong></p><p>从源代码来看，<a href=/golang/tree/context.Background><code>context.Background</code></a> 和 <a href=/golang/tree/context.TODO><code>context.TODO</code></a> 也只是互为别名，没有太大的差别，只是在使用和语义上稍有不同：</p><ul><li><a href=/golang/tree/context.Background><code>context.Background</code></a> 是上下文的默认值，所有其他的上下文都应该从它衍生出来；</li><li><a href=/golang/tree/context.TODO><code>context.TODO</code></a> 应该仅在不确定应该使用哪种上下文时使用；</li></ul><p>在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 <a href=/golang/tree/context.Background><code>context.Background</code></a> 作为起始的上下文向下传递。</p><h2 id=613-取消信号>6.1.3 取消信号
<a class=anchor href=#613-%e5%8f%96%e6%b6%88%e4%bf%a1%e5%8f%b7>#</a></h2><p><a href=/golang/tree/context.WithCancel><code>context.WithCancel</code></a> 函数能够从 <a href=/golang/tree/context.Context><code>context.Context</code></a> 中衍生出一个新的子上下文并返回用于取消该上下文的函数。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。</p><p><img src=https://img.draveness.me/2020-01-20-15795072700927-golang-parent-cancel-context.png alt=golang-parent-cancel-context></p><p><strong>图 6-5 Context 子树的取消</strong></p><p>我们直接从 <a href=/golang/tree/context.WithCancel><code>context.WithCancel</code></a> 函数的实现来看它到底做了什么：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>) (<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#a6e22e>CancelFunc</span>) {
	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newCancelCtx</span>(<span style=color:#a6e22e>parent</span>)
	<span style=color:#a6e22e>propagateCancel</span>(<span style=color:#a6e22e>parent</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>Canceled</span>) }
}
</code></pre></div><ul><li><a href=/golang/tree/context.newCancelCtx><code>context.newCancelCtx</code></a> 将传入的上下文包装成私有结构体 <a href=/golang/tree/context.cancelCtx><code>context.cancelCtx</code></a>；</li><li><a href=/golang/tree/context.propagateCancel><code>context.propagateCancel</code></a> 会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消：</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>propagateCancel</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>child</span> <span style=color:#a6e22e>canceler</span>) {
	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Done</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>done</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#75715e>// 父上下文不会触发取消信号
</span><span style=color:#75715e></span>	}
	<span style=color:#66d9ef>select</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>:
		<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Err</span>()) <span style=color:#75715e>// 父上下文已经被取消
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span>
	<span style=color:#66d9ef>default</span>:
	}

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>parentCancelCtx</span>(<span style=color:#a6e22e>parent</span>); <span style=color:#a6e22e>ok</span> {
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>err</span>)
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>children</span>[<span style=color:#a6e22e>child</span>] = <span style=color:#66d9ef>struct</span>{}{}
		}
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
			<span style=color:#66d9ef>select</span> {
			<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Done</span>():
				<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Err</span>())
			<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>Done</span>():
			}
		}()
	}
}
</code></pre></div><p>上述函数总共与父上下文相关的三种不同的情况：</p><ol><li>当 <code>parent.Done() == nil</code>，也就是 <code>parent</code> 不会触发取消事件时，当前函数会直接返回；</li><li>当 <code>child</code> 的继承链包含可以取消的上下文时，会判断 <code>parent</code> 是否已经触发了取消信号；<ul><li>如果已经被取消，<code>child</code> 会立刻被取消；</li><li>如果没有被取消，<code>child</code> 会被加入 <code>parent</code> 的 <code>children</code> 列表中，等待 <code>parent</code> 释放取消信号；</li></ul></li><li>当父上下文是开发者自定义的类型、实现了 <a href=/golang/tree/context.Context><code>context.Context</code></a> 接口并在 <code>Done()</code> 方法中返回了非空的管道时；<ol><li>运行一个新的 Goroutine 同时监听 <code>parent.Done()</code> 和 <code>child.Done()</code> 两个 Channel；</li><li>在 <code>parent.Done()</code> 关闭时调用 <code>child.cancel</code> 取消子上下文；</li></ol></li></ol><p><a href=/golang/tree/context.propagateCancel><code>context.propagateCancel</code></a> 的作用是在 <code>parent</code> 和 <code>child</code> 之间同步取消和结束的信号，保证在 <code>parent</code> 被取消时，<code>child</code> 也会收到对应的信号，不会出现状态不一致的情况。</p><p><a href=/golang/tree/context.cancelCtx><code>context.cancelCtx</code></a> 实现的几个接口方法也没有太多值得分析的地方，该结构体最重要的方法是 <a href=/golang/tree/context.cancelCtx.cancel><code>context.cancelCtx.cancel</code></a>，该方法会关闭上下文中的 Channel 并向所有的子上下文同步取消信号：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>cancelCtx</span>) <span style=color:#a6e22e>cancel</span>(<span style=color:#a6e22e>removeFromParent</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>err</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>done</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>done</span> = <span style=color:#a6e22e>closedchan</span>
	} <span style=color:#66d9ef>else</span> {
		close(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>done</span>)
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>child</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>children</span> {
		<span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>err</span>)
	}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>children</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>removeFromParent</span> {
		<span style=color:#a6e22e>removeChild</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>c</span>)
	}
}
</code></pre></div><p>除了 <a href=/golang/tree/context.WithCancel><code>context.WithCancel</code></a> 之外，<a href=https://github.com/golang/go/tree/master/src/context><code>context</code></a> 包中的另外两个函数 <a href=/golang/tree/context.WithDeadline><code>context.WithDeadline</code></a> 和 <a href=/golang/tree/context.WithTimeout><code>context.WithTimeout</code></a> 也都能创建可以被取消的计时器上下文 <a href=/golang/tree/context.timerCtx><code>context.timerCtx</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>timeout</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>) (<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>CancelFunc</span>) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>WithDeadline</span>(<span style=color:#a6e22e>parent</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>timeout</span>))
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithDeadline</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>d</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>) (<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>CancelFunc</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>Deadline</span>(); <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Before</span>(<span style=color:#a6e22e>d</span>) {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>parent</span>)
	}
	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>timerCtx</span>{
		<span style=color:#a6e22e>cancelCtx</span>: <span style=color:#a6e22e>newCancelCtx</span>(<span style=color:#a6e22e>parent</span>),
		<span style=color:#a6e22e>deadline</span>:  <span style=color:#a6e22e>d</span>,
	}
	<span style=color:#a6e22e>propagateCancel</span>(<span style=color:#a6e22e>parent</span>, <span style=color:#a6e22e>c</span>)
	<span style=color:#a6e22e>dur</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Until</span>(<span style=color:#a6e22e>d</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dur</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>DeadlineExceeded</span>) <span style=color:#75715e>// 已经过了截止日期
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>Canceled</span>) }
	}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>AfterFunc</span>(<span style=color:#a6e22e>dur</span>, <span style=color:#66d9ef>func</span>() {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>DeadlineExceeded</span>)
		})
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>Canceled</span>) }
}
</code></pre></div><p><a href=/golang/tree/context.WithDeadline><code>context.WithDeadline</code></a> 在创建 <a href=/golang/tree/context.timerCtx><code>context.timerCtx</code></a> 的过程中判断了父上下文的截止日期与当前日期，并通过 <a href=/golang/tree/time.AfterFunc><code>time.AfterFunc</code></a> 创建定时器，当时间超过了截止日期后会调用 <a href=/golang/tree/context.timerCtx.cancel><code>context.timerCtx.cancel</code></a> 同步取消信号。</p><p><a href=/golang/tree/context.timerCtx><code>context.timerCtx</code></a> 内部不仅通过嵌入 <a href=/golang/tree/context.cancelCtx><code>context.cancelCtx</code></a> 结构体继承了相关的变量和方法，还通过持有的定时器 <code>timer</code> 和截止时间 <code>deadline</code> 实现了定时取消的功能：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>timerCtx</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>cancelCtx</span>
	<span style=color:#a6e22e>timer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Timer</span> <span style=color:#75715e>// Under cancelCtx.mu.
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>deadline</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>timerCtx</span>) <span style=color:#a6e22e>Deadline</span>() (<span style=color:#a6e22e>deadline</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>, <span style=color:#a6e22e>ok</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>deadline</span>, <span style=color:#66d9ef>true</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>timerCtx</span>) <span style=color:#a6e22e>cancel</span>(<span style=color:#a6e22e>removeFromParent</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancelCtx</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>err</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>removeFromParent</span> {
		<span style=color:#a6e22e>removeChild</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancelCtx</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>c</span>)
	}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span>.<span style=color:#a6e22e>Stop</span>()
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>timer</span> = <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
}
</code></pre></div><p><a href=/golang/tree/context.timerCtx.cancel><code>context.timerCtx.cancel</code></a> 方法不仅调用了 <a href=/golang/tree/context.cancelCtx.cancel><code>context.cancelCtx.cancel</code></a>，还会停止持有的定时器减少不必要的资源浪费。</p><h2 id=614-传值方法>6.1.4 传值方法
<a class=anchor href=#614-%e4%bc%a0%e5%80%bc%e6%96%b9%e6%b3%95>#</a></h2><p>在最后我们需要了解如何使用上下文传值，<a href=https://github.com/golang/go/tree/master/src/context><code>context</code></a> 包中的 <a href=/golang/tree/context.WithValue><code>context.WithValue</code></a> 能从父上下文中创建一个子上下文，传值的子上下文使用 <a href=/golang/tree/context.valueCtx><code>context.valueCtx</code></a> 类型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithValue</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Context</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>key</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#e6db74>&#34;nil key&#34;</span>)
	}
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>reflectlite</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>key</span>).<span style=color:#a6e22e>Comparable</span>() {
		panic(<span style=color:#e6db74>&#34;key is not comparable&#34;</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>valueCtx</span>{<span style=color:#a6e22e>parent</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span>}
}
</code></pre></div><p><a href=/golang/tree/context.valueCtx><code>context.valueCtx</code></a> 结构体会将除了 <code>Value</code> 之外的 <code>Err</code>、<code>Deadline</code> 等方法代理到父上下文中，它只会响应 <a href=/golang/tree/context.valueCtx.Value><code>context.valueCtx.Value</code></a> 方法，该方法的实现也很简单：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>valueCtx</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Context</span>
	<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>interface</span>{}
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>valueCtx</span>) <span style=color:#a6e22e>Value</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>interface</span>{} {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>key</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>key</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>val</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Context</span>.<span style=color:#a6e22e>Value</span>(<span style=color:#a6e22e>key</span>)
}
</code></pre></div><p>如果 <a href=/golang/tree/context.valueCtx><code>context.valueCtx</code></a> 中存储的键值对与 <a href=/golang/tree/context.valueCtx.Value><code>context.valueCtx.Value</code></a> 方法中传入的参数不匹配，就会从父上下文中查找该键对应的值直到某个父上下文中返回 <code>nil</code> 或者查找到对应的值。</p><h2 id=615-小结>6.1.5 小结
<a class=anchor href=#615-%e5%b0%8f%e7%bb%93>#</a></h2><p>Go 语言中的 <a href=/golang/tree/context.Context><code>context.Context</code></a> 的主要作用还是在多个 Goroutine 组成的树中同步取消信号以减少对资源的消耗和占用，虽然它也有传值的功能，但是这个功能我们还是很少用到。</p><p>在真正使用传值的功能时我们也应该非常谨慎，使用 <a href=/golang/tree/context.Context><code>context.Context</code></a> 传递请求的所有参数一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。</p><h2 id=616-延伸阅读>6.1.6 延伸阅读
<a class=anchor href=#616-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=https://golang.org/pkg/context/>Package context · Golang</a></li><li><a href=https://blog.golang.org/context>Go Concurrency Patterns: Context</a></li><li><a href=https://www.sohamkamani.com/blog/golang/2018-06-17-golang-using-context-cancellation/>Using context cancellation in Go</a></li></ul><p><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/ class=book-btn>上一节</a>
<a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>proposal: context: new package for standard library #14660 <a href=https://github.com/golang/go/issues/14660>https://github.com/golang/go/issues/14660</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Sameer Ajmani. 29 July 2014. &ldquo;Go Concurrency Patterns: Context&rdquo; <a href=https://blog.golang.org/context>https://blog.golang.org/context</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-context data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-context",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#61-上下文-context>6.1 上下文 Context</a><ul><li><a href=#611-设计原理>6.1.1 设计原理</a></li><li><a href=#612-默认上下文>6.1.2 默认上下文</a></li><li><a href=#613-取消信号>6.1.3 取消信号</a></li><li><a href=#614-传值方法>6.1.4 传值方法</a></li><li><a href=#615-小结>6.1.5 小结</a></li><li><a href=#616-延伸阅读>6.1.6 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>