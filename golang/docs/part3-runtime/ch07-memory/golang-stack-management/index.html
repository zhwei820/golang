<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="7.3 栈空间管理 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  应用程序的内存一般会分成堆区和栈区，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收，我们在上两节已经详细分析了堆内存的申请和释放过程，本节会介绍 Go 语言栈内存的管理。
7.3.1 设计原理 #  栈区的内存一般由编译器自动分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在，这种线性的内存分配策略有着极高地效率，但是工程师也往往不能控制栈内存的分配，这部分工作基本都是由编译器完成的。
寄存器 #  寄存器1是中央处理器（CPU）中的稀缺资源，它的存储能力非常有限，但是能提供最快的读写速度，充分利用寄存器的速度可以构建高性能的应用程序。寄存器在物理机上非常有限，然而栈区的操作会使用到两个以上的寄存器，这足以说明栈内存在应用程序的重要性。
栈寄存器是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈2，Go 语言的汇编代码包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址，栈内存与函数调用的关系非常紧密，我们在函数调用一节中曾经介绍过栈区，BP 和 SP 之间的内存就是当前函数的调用栈。
图 7-43 栈寄存器与内存
因为历史原因，栈区内存都是从高地址向低地址扩展的，当应用程序申请或者释放栈内存时只需要修改 SP 寄存器的值，这种线性的内存分配方式与堆内存相比更加快速，仅会带来极少的额外开销。
线程栈 #  如果我们在 Linux 操作系统中执行 pthread_create 系统调用，进程会启动一个新的线程，如果用户没有通过软资源限制 RLIMIT_STACK 指定线程栈的大小，那么操作系统会根据架构选择不同的默认栈大小3。
   架构 默认栈大小     i386 2 MB   IA-64 32 MB   PowerPC 4 MB   &mldr; &mldr;   x86_64 2 MB    表 7-4 架构和线程默认栈大小"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言的栈内存和逃逸分析"><meta property="og:description" content="7.3 栈空间管理 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  应用程序的内存一般会分成堆区和栈区，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收，我们在上两节已经详细分析了堆内存的申请和释放过程，本节会介绍 Go 语言栈内存的管理。
7.3.1 设计原理 #  栈区的内存一般由编译器自动分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在，这种线性的内存分配策略有着极高地效率，但是工程师也往往不能控制栈内存的分配，这部分工作基本都是由编译器完成的。
寄存器 #  寄存器1是中央处理器（CPU）中的稀缺资源，它的存储能力非常有限，但是能提供最快的读写速度，充分利用寄存器的速度可以构建高性能的应用程序。寄存器在物理机上非常有限，然而栈区的操作会使用到两个以上的寄存器，这足以说明栈内存在应用程序的重要性。
栈寄存器是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈2，Go 语言的汇编代码包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址，栈内存与函数调用的关系非常紧密，我们在函数调用一节中曾经介绍过栈区，BP 和 SP 之间的内存就是当前函数的调用栈。
图 7-43 栈寄存器与内存
因为历史原因，栈区内存都是从高地址向低地址扩展的，当应用程序申请或者释放栈内存时只需要修改 SP 寄存器的值，这种线性的内存分配方式与堆内存相比更加快速，仅会带来极少的额外开销。
线程栈 #  如果我们在 Linux 操作系统中执行 pthread_create 系统调用，进程会启动一个新的线程，如果用户没有通过软资源限制 RLIMIT_STACK 指定线程栈的大小，那么操作系统会根据架构选择不同的默认栈大小3。
   架构 默认栈大小     i386 2 MB   IA-64 32 MB   PowerPC 4 MB   &mldr; &mldr;   x86_64 2 MB    表 7-4 架构和线程默认栈大小"><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part3-runtime/ch07-memory/golang-stack-management/"><title>Go 语言的栈内存和逃逸分析 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言的栈内存和逃逸分析</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#73-栈空间管理>7.3 栈空间管理</a><ul><li><a href=#731-设计原理>7.3.1 设计原理</a><ul><li><a href=#寄存器>寄存器</a></li><li><a href=#线程栈>线程栈</a></li><li><a href=#逃逸分析>逃逸分析</a></li><li><a href=#栈内存空间>栈内存空间</a></li></ul></li><li><a href=#732-栈操作>7.3.2 栈操作</a><ul><li><a href=#栈初始化>栈初始化</a></li><li><a href=#栈分配>栈分配</a></li><li><a href=#栈扩容>栈扩容</a></li><li><a href=#栈缩容>栈缩容</a></li></ul></li><li><a href=#733-小结>7.3.3 小结</a></li><li><a href=#734-延伸阅读>7.3.4 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=73-栈空间管理>7.3 栈空间管理
<a class=anchor href=#73-%e6%a0%88%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>应用程序的内存一般会分成堆区和栈区，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收，我们在上两节已经详细分析了堆内存的申请和释放过程，本节会介绍 Go 语言栈内存的管理。</p><h2 id=731-设计原理>7.3.1 设计原理
<a class=anchor href=#731-%e8%ae%be%e8%ae%a1%e5%8e%9f%e7%90%86>#</a></h2><p>栈区的内存一般由编译器自动分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在，这种线性的内存分配策略有着极高地效率，但是工程师也往往不能控制栈内存的分配，这部分工作基本都是由编译器完成的。</p><h3 id=寄存器>寄存器
<a class=anchor href=#%e5%af%84%e5%ad%98%e5%99%a8>#</a></h3><p>寄存器<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>是中央处理器（CPU）中的稀缺资源，它的存储能力非常有限，但是能提供最快的读写速度，充分利用寄存器的速度可以构建高性能的应用程序。寄存器在物理机上非常有限，然而栈区的操作会使用到两个以上的寄存器，这足以说明栈内存在应用程序的重要性。</p><p>栈寄存器是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，Go 语言的汇编代码包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址，栈内存与函数调用的关系非常紧密，我们在函数调用一节中曾经介绍过栈区，BP 和 SP 之间的内存就是当前函数的调用栈。</p><p><img src=https://img.draveness.me/2020-03-23-15849514795843-stack-registers.png alt=stack-registers></p><p><strong>图 7-43 栈寄存器与内存</strong></p><p>因为历史原因，栈区内存都是从高地址向低地址扩展的，当应用程序申请或者释放栈内存时只需要修改 SP 寄存器的值，这种线性的内存分配方式与堆内存相比更加快速，仅会带来极少的额外开销。</p><h3 id=线程栈>线程栈
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e6%a0%88>#</a></h3><p>如果我们在 Linux 操作系统中执行 <code>pthread_create</code> 系统调用，进程会启动一个新的线程，如果用户没有通过软资源限制 <code>RLIMIT_STACK</code> 指定线程栈的大小，那么操作系统会根据架构选择不同的默认栈大小<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>。</p><table><thead><tr><th style=text-align:left>架构</th><th style=text-align:right>默认栈大小</th></tr></thead><tbody><tr><td style=text-align:left>i386</td><td style=text-align:right>2 MB</td></tr><tr><td style=text-align:left>IA-64</td><td style=text-align:right>32 MB</td></tr><tr><td style=text-align:left>PowerPC</td><td style=text-align:right>4 MB</td></tr><tr><td style=text-align:left>&mldr;</td><td style=text-align:right>&mldr;</td></tr><tr><td style=text-align:left>x86_64</td><td style=text-align:right>2 MB</td></tr></tbody></table><p><strong>表 7-4 架构和线程默认栈大小</strong></p><p>多数架构上默认栈大小都在 2 ~ 4 MB 左右，极少数架构会使用 32 MB 的栈，用户程序可以在分配的栈上存储函数参数和局部变量。然而这个固定的栈大小在某些场景下不是合适的值，如果程序需要同时运行几百个甚至上千个线程，这些线程中的大部分都只会用到很少的栈空间，当函数的调用栈非常深时，固定栈大小也无法满足用户程序的需求。</p><p>线程和进程都是代码执行的上下文<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>，但是如果一个应用程序包含成百上千个执行上下文并且每个上下文都是线程，会占用大量的内存空间并带来其他的额外开销，Go 语言在设计时认为执行上下文是轻量级的，所以它在用户态实现 Goroutine 作为执行上下文。</p><h3 id=逃逸分析>逃逸分析
<a class=anchor href=#%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90>#</a></h3><p>在 C 语言和 C++ 这类需要手动管理内存的编程语言中，将对象或者结构体分配到栈上或者堆上是由工程师自主决定的，这也为工程师的工作带来的挑战，如果工程师能够精准地为每一个变量分配合理的空间，那么整个程序的运行效率和内存使用效率一定是最高的，但是手动分配内存会导致如下的两个问题：</p><ol><li>不需要分配到堆上的对象分配到了堆上 — 浪费内存空间；</li><li>需要分配到堆上的对象分配到了栈上 — 悬挂指针、影响内存安全；</li></ol><p>与悬挂指针相比，浪费内存空间反而是小问题。在 C 语言中，栈上的变量被函数作为返回值返回给调用方是一个常见的错误，在如下所示的代码中，栈上的变量 <code>i</code> 被错误返回：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>dangling_pointer</span>() {
    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>i;
}
</code></pre></div><p>当 <code>dangling_pointer</code> 函数返回后，它的本地变量会被编译器回收，调用方获取的是危险的悬挂指针，我们不确定当前指针指向的值是否合法时，这种问题在大型项目中是比较难以发现和定位的。</p><p>在编译器优化中，逃逸分析是用来决定指针动态作用域的方法<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，其中包括使用 <code>new</code>、<code>make</code> 和字面量等方法隐式分配的内存，Go 语言的逃逸分析遵循以下两个不变性：</p><ol><li>指向栈对象的指针不能存在于堆中；</li><li>指向栈对象的指针不能在栈对象回收后存活；</li></ol><p><img src=https://img.draveness.me/2020-03-23-15849514795864-escape-analysis-and-key-invariants.png alt=escape-analysis-and-key-invariants></p><p><strong>图 7-44 逃逸分析和不变性</strong></p><p>我们通过上图展示两条不变性存在的意义，当我们违反了第一条不变性时，堆上的绿色指针指向了栈中的黄色内存，一旦函数返回后函数栈会被回收，该绿色指针指向的值就不再合法；如果我们违反了第二条不变性，因为寄存器 SP 下面的内存由于函数返回已经释放，所以黄色指针指向的内存已经不再合法。</p><p>逃逸分析是静态分析的一种，在编译器解析了 Go 语言源文件后，它可以获得整个程序的抽象语法树（Abstract syntax tree，AST），编译器可以根据抽象语法树分析静态的数据流，我们会通过以下几个步骤实现静态分析的全过程<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>：</p><ol><li>构建带权重的有向图，其中顶点 <a href=/golang/tree/cmd/compile/internal/gc.EscLocation><code>cmd/compile/internal/gc.EscLocation</code></a> 表示被分配的变量，边 <a href=/golang/tree/cmd/compile/internal/gc.EscEdge><code>cmd/compile/internal/gc.EscEdge</code></a> 表示变量之间的分配关系，权重表示寻址和取地址的次数；</li><li>遍历对象分配图并查找违反两条不变性的变量分配关系，如果堆上的变量指向了栈上的变量，那么该变量需要分配在堆上；</li><li>记录从函数的调用参数到堆以及返回值的数据流，增强函数参数的逃逸分析；</li></ol><p>决定变量是在栈上还是堆上虽然重要，但是这是一个定义相对清晰的问题，我们可以通过编译器统一作决策。为了保证内存的绝对安全，编译器可能会将一些变量错误地分配到堆上，但是因为堆也会被垃圾收集器扫描，所以不会造成内存泄露以及悬挂指针等安全问题，解放了工程师的生产力。</p><h3 id=栈内存空间>栈内存空间
<a class=anchor href=#%e6%a0%88%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4>#</a></h3><p>Go 语言使用用户态线程 Goroutine 作为执行上下文，它的额外开销和默认栈大小都比线程小很多，然而 Goroutine 的栈内存空间和栈结构也在早期几个版本中发生过一些变化：</p><ol><li>v1.0 ~ v1.1 — 最小栈内存空间为 4KB；</li><li>v1.2 — 将最小栈内存提升到了 8KB<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>；</li><li>v1.3 — 使用<strong>连续栈</strong>替换之前版本的分段栈<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>；</li><li>v1.4 — 将最小栈内存降低到了 2KB<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>；</li></ol><p>Goroutine 的初始栈内存在最初的几个版本中多次修改，从 4KB 提升到 8KB 是临时的解决方案，其目的是为了减轻分段栈中的栈分裂对程序的性能影响；在 v1.3 版本引入连续栈之后，Goroutine 的初始栈大小降低到了 2KB，进一步减少了 Goroutine 占用的内存空间。</p><h4 id=分段栈>分段栈
<a class=anchor href=#%e5%88%86%e6%ae%b5%e6%a0%88>#</a></h4><p>分段栈是 Go 语言在 v1.3 版本之前的实现，所有 Goroutine 在初始化时都会调用 <a href=/golang/tree/runtime.stackalloc:go1.2><code>runtime.stackalloc:go1.2</code></a> 分配一块固定大小的内存空间，这块内存的大小由 <a href=/golang/tree/runtime.StackMin:go1.2><code>runtime.StackMin:go1.2</code></a> 表示，在 v1.2 版本中为 8KB：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> runtime<span style=color:#960050;background-color:#1e0010>·</span>stackalloc(uint32 n) {
	uint32 pos;
	<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>v;
	<span style=color:#66d9ef>if</span>(n <span style=color:#f92672>==</span> FixedStack <span style=color:#f92672>||</span> m<span style=color:#f92672>-&gt;</span>mallocing <span style=color:#f92672>||</span> m<span style=color:#f92672>-&gt;</span>gcing) {
		<span style=color:#66d9ef>if</span>(m<span style=color:#f92672>-&gt;</span>stackcachecnt <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
			stackcacherefill();
		pos <span style=color:#f92672>=</span> m<span style=color:#f92672>-&gt;</span>stackcachepos;
		pos <span style=color:#f92672>=</span> (pos <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> StackCacheSize;
		v <span style=color:#f92672>=</span> m<span style=color:#f92672>-&gt;</span>stackcache[pos];
		m<span style=color:#f92672>-&gt;</span>stackcachepos <span style=color:#f92672>=</span> pos;
		m<span style=color:#f92672>-&gt;</span>stackcachecnt<span style=color:#f92672>--</span>;
		m<span style=color:#f92672>-&gt;</span>stackinuse<span style=color:#f92672>++</span>;
		<span style=color:#66d9ef>return</span> v;
	}
	<span style=color:#66d9ef>return</span> runtime<span style=color:#960050;background-color:#1e0010>·</span>mallocgc(n, <span style=color:#ae81ff>0</span>, FlagNoProfiling<span style=color:#f92672>|</span>FlagNoGC<span style=color:#f92672>|</span>FlagNoZero<span style=color:#f92672>|</span>FlagNoInvokeGC);
}
</code></pre></div><p>如果通过该方法申请的内存大小为固定的 8KB 或者满足其他的条件，运行时会在全局的栈缓存链表中找到空闲的内存块并作为新 Goroutine 的栈空间返回；在其余情况下，栈内存空间会从堆上申请一块合适的内存。</p><p>当 Goroutine 调用的函数层级或者局部变量需要的越来越多时，运行时会调用 <a href=/golang/tree/runtime.morestack:go1.2><code>runtime.morestack:go1.2</code></a> 和 <a href=/golang/tree/runtime.newstack:go1.2><code>runtime.newstack:go1.2</code></a> 创建一个新的栈空间，这些栈空间虽然不连续，但是当前 Goroutine 的多个栈空间会以链表的形式串联起来，运行时会通过指针找到连续的栈片段：</p><p><img src=https://img.draveness.me/2020-03-23-15849514795874-segmented-stacks.png alt=segmented-stacks></p><p><strong>图 7-45 分段栈的内存布局</strong></p><p>一旦 Goroutine 申请的栈空间不在被需要，运行时会调用 <a href=/golang/tree/runtime.lessstack:go1.2><code>runtime.lessstack:go1.2</code></a> 和 <a href=/golang/tree/runtime.oldstack:go1.2><code>runtime.oldstack:go1.2</code></a> 释放不再使用的内存空间。</p><p>分段栈机制虽然能够按需为当前 Goroutine 分配内存并且及时减少内存的占用，但是它也存在两个比较大的问题：</p><ol><li>如果当前 Goroutine 的栈几乎充满，那么任意的函数调用都会触发栈扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）；</li><li>一旦 Goroutine 使用的内存<strong>越过</strong>了分段栈的扩缩容阈值，运行时会触发栈的扩容和缩容，带来额外的工作量；</li></ol><h4 id=连续栈>连续栈
<a class=anchor href=#%e8%bf%9e%e7%bb%ad%e6%a0%88>#</a></h4><p>连续栈可以解决分段栈中存在的两个问题，其核心原理是每当程序的栈空间不足时，初始化一片更大的栈空间并将原栈中的所有值都迁移到新栈中，新的局部变量或者函数调用就有充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：</p><ol><li>在内存空间中分配更大的栈内存空间；</li><li>将旧栈中的所有内容复制到新栈中；</li><li><strong>将指向旧栈对应变量的指针重新指向新栈</strong>；</li><li>销毁并回收旧栈的内存空间；</li></ol><p>在扩容的过程中，最重要的是调整指针的第三步，这一步能够保证指向栈的指针的正确性，因为栈中的所有变量内存都会发生变化，所以原本指向栈中变量的指针也需要调整。我们在前面提到过经过逃逸分析的 Go 语言程序的遵循以下不变性 —— <strong>指向栈对象的指针不能存在于堆中</strong>，所以指向栈中变量的指针只能在栈上，我们只需要调整栈中的所有变量就可以保证内存的安全了。</p><p><img src=https://img.draveness.me/2020-03-23-15849514795883-continuous-stacks.png alt=continuous-stacks></p><p><strong>图 7-46 连续栈的内存布局</strong></p><p>因为需要拷贝变量和调整指针，连续栈增加了栈扩容时的额外开销，但是通过合理栈缩容机制就能避免热分裂带来的性能问题<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>，在 GC 期间如果 Goroutine 使用了栈内存的四分之一，那就将其内存减少一半，这样在栈内存几乎充满时也只会扩容一次，不会因为函数调用频繁扩缩容。</p><h2 id=732-栈操作>7.3.2 栈操作
<a class=anchor href=#732-%e6%a0%88%e6%93%8d%e4%bd%9c>#</a></h2><p>Go 语言中的执行栈由 <a href=/golang/tree/runtime.stack><code>runtime.stack</code></a> 表示，该结构体中只包含两个字段，分别表示栈的顶部和栈的底部，每个栈结构体都表示范围为 <code>[lo, hi)</code> 的内存空间：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>stack</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>lo</span> <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>hi</span> <span style=color:#66d9ef>uintptr</span>
}
</code></pre></div><p>栈的结构虽然非常简单，但是想要理解 Goroutine 栈的实现原理，还是需要我们从编译期间和运行时两个阶段入手：</p><ol><li>编译器会在编译阶段会通过 <a href=/golang/tree/cmd/internal/obj/x86.stacksplit><code>cmd/internal/obj/x86.stacksplit</code></a> 在调用函数前插入 <a href=/golang/tree/runtime.morestack><code>runtime.morestack</code></a> 或者 <a href=/golang/tree/runtime.morestack_noctxt><code>runtime.morestack_noctxt</code></a> 函数；</li><li>运行时在创建新的 Goroutine 时会在 <a href=/golang/tree/runtime.malg><code>runtime.malg</code></a> 中调用 <a href=/golang/tree/runtime.stackalloc><code>runtime.stackalloc</code></a> 申请新的栈内存，并在编译器插入的 <a href=/golang/tree/runtime.morestack><code>runtime.morestack</code></a> 中检查栈空间是否充足；</li></ol><p>需要注意的是，Go 语言的编译器不会为所有的函数插入 <a href=/golang/tree/runtime.morestack><code>runtime.morestack</code></a>，它只会在必要时插入指令以减少运行时的额外开销，编译指令 <code>nosplit</code> 可以跳过栈溢出的检查，虽然这能降低一些开销，不过固定大小的栈也存在溢出的风险。本节将分别分析栈的初始化、创建 Goroutine 时栈的分配、编译器和运行时协作完成的栈扩容以及当栈空间利用率不足时的缩容过程。</p><h3 id=栈初始化>栈初始化
<a class=anchor href=#%e6%a0%88%e5%88%9d%e5%a7%8b%e5%8c%96>#</a></h3><p>栈空间在运行时中包含两个重要的全局变量，分别是 <a href=/golang/tree/runtime.stackpool><code>runtime.stackpool</code></a> 和 <a href=/golang/tree/runtime.stackLarge><code>runtime.stackLarge</code></a>，这两个变量分别表示全局的栈缓存和大栈缓存，前者可以分配小于 32KB 的内存，后者用来分配大于 32KB 的栈空间：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stackpool</span> [<span style=color:#a6e22e>_NumStackOrders</span>]<span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>item</span> <span style=color:#a6e22e>stackpoolItem</span>
	<span style=color:#a6e22e>_</span>    [<span style=color:#a6e22e>cpu</span>.<span style=color:#a6e22e>CacheLinePadSize</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>stackpoolItem</span>{})<span style=color:#f92672>%</span><span style=color:#a6e22e>cpu</span>.<span style=color:#a6e22e>CacheLinePadSize</span>]<span style=color:#66d9ef>byte</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>stackpoolItem</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>mu</span>   <span style=color:#a6e22e>mutex</span>
	<span style=color:#a6e22e>span</span> <span style=color:#a6e22e>mSpanList</span>
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stackLarge</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span>
	<span style=color:#a6e22e>free</span> [<span style=color:#a6e22e>heapAddrBits</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>pageShift</span>]<span style=color:#a6e22e>mSpanList</span>
}
</code></pre></div><p>这两个用于分配空间的全局变量都与内存管理单元 <a href=/golang/tree/runtime.mspan><code>runtime.mspan</code></a> 有关，我们可以认为 Go 语言的栈内存都是分配在堆上的，运行时初始化会调用 <a href=/golang/tree/runtime.stackinit><code>runtime.stackinit</code></a> 初始化这些全局变量：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>stackinit</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>stackpool</span> {
		<span style=color:#a6e22e>stackpool</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>init</span>()
	}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>stackLarge</span>.<span style=color:#a6e22e>free</span> {
		<span style=color:#a6e22e>stackLarge</span>.<span style=color:#a6e22e>free</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>init</span>()
	}
}
</code></pre></div><p>从调度器和内存分配的经验来看，如果运行时只使用全局变量来分配内存的话，势必会造成线程之间的锁竞争进而影响程序的执行效率，栈内存由于与线程关系比较密切，所以我们在每一个线程缓存 <a href=/golang/tree/runtime.mcache><code>runtime.mcache</code></a> 中都加入了栈缓存减少锁竞争影响。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mcache</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>stackcache</span> [<span style=color:#a6e22e>_NumStackOrders</span>]<span style=color:#a6e22e>stackfreelist</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>stackfreelist</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>list</span> <span style=color:#a6e22e>gclinkptr</span>
	<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>uintptr</span>
}
</code></pre></div><p><img src=https://img.draveness.me/2020-03-23-15849514795892-stack-memory.png alt=stack-memory></p><p><strong>图 7-47 线程栈缓存和全局栈缓存</strong></p><p>运行时使用全局的 <a href=/golang/tree/runtime.stackpool><code>runtime.stackpool</code></a> 和线程缓存中的空闲链表分配 32KB 以下的栈内存，使用全局的 <a href=/golang/tree/runtime.stackLarge><code>runtime.stackLarge</code></a> 和堆内存分配 32KB 以上的栈内存，提高本地分配栈内存的性能。</p><h3 id=栈分配>栈分配
<a class=anchor href=#%e6%a0%88%e5%88%86%e9%85%8d>#</a></h3><p>运行时会在 Goroutine 的初始化函数 <a href=/golang/tree/runtime.malg><code>runtime.malg</code></a> 中调用 <a href=/golang/tree/runtime.stackalloc><code>runtime.stackalloc</code></a> 分配一个大小足够栈内存空间，根据线程缓存和申请栈的大小，该函数会通过三种不同的方法分配栈空间：</p><ol><li>如果栈空间较小，使用全局栈缓存或者线程缓存上固定大小的空闲链表分配内存；</li><li>如果栈空间较大，从全局的大栈缓存 <a href=/golang/tree/runtime.stackLarge><code>runtime.stackLarge</code></a> 中获取内存空间；</li><li>如果栈空间较大并且 <a href=/golang/tree/runtime.stackLarge><code>runtime.stackLarge</code></a> 空间不足，在堆上申请一片大小足够内存空间；</li></ol><p>我们在这里会按照栈的大小分两部分介绍运行时对栈空间的分配。在 Linux 上，<code>_FixedStack = 2048</code>、<code>_NumStackOrders = 4</code>、<code>_StackCacheSize = 32768</code>，也就是如果申请的栈空间小于 32KB，我们会在全局栈缓存池或者线程的栈缓存中初始化内存：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>stackalloc</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>uint32</span>) <span style=color:#a6e22e>stack</span> {
	<span style=color:#a6e22e>thisg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>v</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> &lt; <span style=color:#a6e22e>_FixedStack</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#a6e22e>_NumStackOrders</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span> &lt; <span style=color:#a6e22e>_StackCacheSize</span> {
		<span style=color:#a6e22e>order</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>0</span>)
		<span style=color:#a6e22e>n2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>n2</span> &gt; <span style=color:#a6e22e>_FixedStack</span> {
			<span style=color:#a6e22e>order</span><span style=color:#f92672>++</span>
			<span style=color:#a6e22e>n2</span> <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>
		}
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#a6e22e>gclinkptr</span>
		<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>thisg</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>mcache</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>stackNoCache</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>thisg</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>preemptoff</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
			<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>stackpoolalloc</span>(<span style=color:#a6e22e>order</span>)
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>stackcache</span>[<span style=color:#a6e22e>order</span>].<span style=color:#a6e22e>list</span>
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>ptr</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>stackcacherefill</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>order</span>)
				<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>stackcache</span>[<span style=color:#a6e22e>order</span>].<span style=color:#a6e22e>list</span>
			}
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>stackcache</span>[<span style=color:#a6e22e>order</span>].<span style=color:#a6e22e>list</span> = <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>next</span>
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>stackcache</span>[<span style=color:#a6e22e>order</span>].<span style=color:#a6e22e>size</span> <span style=color:#f92672>-=</span> uintptr(<span style=color:#a6e22e>n</span>)
		}
		<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>x</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#f92672>...</span>
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p><a href=/golang/tree/runtime.stackpoolalloc><code>runtime.stackpoolalloc</code></a> 会在全局的栈缓存池 <a href=/golang/tree/runtime.stackpool><code>runtime.stackpool</code></a> 中获取新的内存，如果栈缓存池中不包含剩余的内存，运行时会从堆上申请一片内存空间；如果线程缓存中包含足够的空间，我们可以从线程本地的缓存中获取内存，一旦发现空间不足就会调用 <a href=/golang/tree/runtime.stackcacherefill><code>runtime.stackcacherefill</code></a> 从堆上获取新的内存。</p><p>如果 Goroutine 申请的内存空间过大，运行时会查看 <a href=/golang/tree/runtime.stackLarge><code>runtime.stackLarge</code></a> 中是否有剩余的空间，如果不存在剩余空间，它也会从堆上申请新的内存：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>stackalloc</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>uint32</span>) <span style=color:#a6e22e>stack</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> &lt; <span style=color:#a6e22e>_FixedStack</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#a6e22e>_NumStackOrders</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span> &lt; <span style=color:#a6e22e>_StackCacheSize</span> {
		<span style=color:#f92672>...</span>
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
		<span style=color:#a6e22e>npage</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>n</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>_PageShift</span>
		<span style=color:#a6e22e>log2npage</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stacklog2</span>(<span style=color:#a6e22e>npage</span>)

		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>stackLarge</span>.<span style=color:#a6e22e>free</span>[<span style=color:#a6e22e>log2npage</span>].<span style=color:#a6e22e>isEmpty</span>() {
			<span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>stackLarge</span>.<span style=color:#a6e22e>free</span>[<span style=color:#a6e22e>log2npage</span>].<span style=color:#a6e22e>first</span>
			<span style=color:#a6e22e>stackLarge</span>.<span style=color:#a6e22e>free</span>[<span style=color:#a6e22e>log2npage</span>].<span style=color:#a6e22e>remove</span>(<span style=color:#a6e22e>s</span>)
		}

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>mheap_</span>.<span style=color:#a6e22e>allocManual</span>(<span style=color:#a6e22e>npage</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>memstats</span>.<span style=color:#a6e22e>stacks_inuse</span>)
			<span style=color:#a6e22e>osStackAlloc</span>(<span style=color:#a6e22e>s</span>)
			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>elemsize</span> = uintptr(<span style=color:#a6e22e>n</span>)
		}
		<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>base</span>())
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>stack</span>{uintptr(<span style=color:#a6e22e>v</span>), uintptr(<span style=color:#a6e22e>v</span>) <span style=color:#f92672>+</span> uintptr(<span style=color:#a6e22e>n</span>)}
}
</code></pre></div><p>需要注意的是，因为 OpenBSD 6.4+ 对栈内存有特殊的需求，所以只要我们从堆上申请栈内存，需要调用 <a href=/golang/tree/runtime.osStackAlloc><code>runtime.osStackAlloc</code></a> 做一些额外处理，然而其他的操作系统就没有这种限制了。</p><h3 id=栈扩容>栈扩容
<a class=anchor href=#%e6%a0%88%e6%89%a9%e5%ae%b9>#</a></h3><p>编译器会在 <a href=/golang/tree/cmd/internal/obj/x86.stacksplit><code>cmd/internal/obj/x86.stacksplit</code></a> 中为函数调用插入 <a href=/golang/tree/runtime.morestack><code>runtime.morestack</code></a> 运行时检查，它会在几乎所有的函数调用之前检查当前 Goroutine 的栈内存是否充足，如果当前栈需要扩容，我们会保存一些栈的相关信息并调用 <a href=/golang/tree/runtime.newstack><code>runtime.newstack</code></a> 创建新的栈：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newstack</span>() {
	<span style=color:#a6e22e>thisg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>thisg</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span>
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>preempt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Loaduintptr</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stackguard0</span>) <span style=color:#f92672>==</span> <span style=color:#a6e22e>stackPreempt</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>preempt</span> {
		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>canPreemptM</span>(<span style=color:#a6e22e>thisg</span>.<span style=color:#a6e22e>m</span>) {
			<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_StackGuard</span>
			<span style=color:#a6e22e>gogo</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>)
		}
	}

	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sp</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>preempt</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>preemptShrink</span> {
			<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>preemptShrink</span> = <span style=color:#66d9ef>false</span>
			<span style=color:#a6e22e>shrinkstack</span>(<span style=color:#a6e22e>gp</span>)
		}

		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>preemptStop</span> {
			<span style=color:#a6e22e>preemptPark</span>(<span style=color:#a6e22e>gp</span>)
		}

		<span style=color:#a6e22e>gopreempt_m</span>(<span style=color:#a6e22e>gp</span>)
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p><a href=/golang/tree/runtime.newstack><code>runtime.newstack</code></a> 会先做一些准备工作并检查当前 Goroutine 是否发出了抢占请求，如果发出了抢占请求：</p><ol><li>当前线程可以被抢占时，直接调用 <a href=/golang/tree/runtime.gogo><code>runtime.gogo</code></a> 触发调度器的调度；</li><li>如果当前 Goroutine 在垃圾回收被 <a href=/golang/tree/runtime.scanstack><code>runtime.scanstack</code></a> 标记成了需要收缩栈，调用 <a href=/golang/tree/runtime.shrinkstack><code>runtime.shrinkstack</code></a>；</li><li>如果当前 Goroutine 被 <a href=/golang/tree/runtime.suspendG><code>runtime.suspendG</code></a> 函数挂起，调用 <a href=/golang/tree/runtime.preemptPark><code>runtime.preemptPark</code></a> 被动让出当前处理器的控制权并将 Goroutine 的状态修改至 <code>_Gpreempted</code>；</li><li>调用 <a href=/golang/tree/runtime.gopreempt_m><code>runtime.gopreempt_m</code></a> 主动让出当前处理器的控制权；</li></ol><p>如果当前 Goroutine 不需要被抢占，意味着我们需要新的栈空间来支持函数调用和本地变量的初始化，运行时会先检查目标大小的栈是否会溢出：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newstack</span>() {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>oldsize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span>
	<span style=color:#a6e22e>newsize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>oldsize</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newsize</span> &gt; <span style=color:#a6e22e>maxstacksize</span> {
		print(<span style=color:#e6db74>&#34;runtime: goroutine stack exceeds &#34;</span>, <span style=color:#a6e22e>maxstacksize</span>, <span style=color:#e6db74>&#34;-byte limit\n&#34;</span>)
		print(<span style=color:#e6db74>&#34;runtime: sp=&#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>sp</span>), <span style=color:#e6db74>&#34; stack=[&#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span>), <span style=color:#e6db74>&#34;, &#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span>), <span style=color:#e6db74>&#34;]\n&#34;</span>)
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;stack overflow&#34;</span>)
	}

	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gcopystack</span>)
	<span style=color:#a6e22e>copystack</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>newsize</span>)
	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gcopystack</span>, <span style=color:#a6e22e>_Grunning</span>)
	<span style=color:#a6e22e>gogo</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>)
}
</code></pre></div><p>如果目标栈的大小没有超出程序的限制，我们会将 Goroutine 切换至 <code>_Gcopystack</code> 状态并调用 <a href=/golang/tree/runtime.copystack><code>runtime.copystack</code></a> 开始栈拷贝。在拷贝栈内存之前，运行时会通过 <a href=/golang/tree/runtime.stackalloc><code>runtime.stackalloc</code></a> 分配新的栈空间：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>copystack</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>newsize</span> <span style=color:#66d9ef>uintptr</span>) {
	<span style=color:#a6e22e>old</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>
	<span style=color:#a6e22e>used</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>hi</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sp</span>

	<span style=color:#a6e22e>new</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stackalloc</span>(uint32(<span style=color:#a6e22e>newsize</span>))
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>新栈的初始化和数据的复制是一个比较简单的过程，不过这不是整个过程中最复杂的地方，我们还需要将指向源栈中内存指向新的栈，在这期间我们需要分别调整以下的指针：</p><ol><li>调用 <a href=/golang/tree/runtime.adjustsudogs><code>runtime.adjustsudogs</code></a> 或者 <a href=/golang/tree/runtime.syncadjustsudogs><code>runtime.syncadjustsudogs</code></a> 调整 <a href=/golang/tree/runtime.sudog><code>runtime.sudog</code></a> 结构体的指针；</li><li>调用 <a href=/golang/tree/runtime.memmove><code>runtime.memmove</code></a> 将源栈中的整片内存拷贝到新的栈中；</li><li>调用 <a href=/golang/tree/runtime.adjustctxt><code>runtime.adjustctxt</code></a>、<a href=/golang/tree/runtime.adjustdefers><code>runtime.adjustdefers</code></a> 和 <a href=/golang/tree/runtime.adjustpanics><code>runtime.adjustpanics</code></a> 调整剩余 Goroutine 相关数据结构的指针；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>copystack</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>newsize</span> <span style=color:#66d9ef>uintptr</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>adjinfo</span> <span style=color:#a6e22e>adjustinfo</span>
	<span style=color:#a6e22e>adjinfo</span>.<span style=color:#a6e22e>old</span> = <span style=color:#a6e22e>old</span>
	<span style=color:#a6e22e>adjinfo</span>.<span style=color:#a6e22e>delta</span> = <span style=color:#a6e22e>new</span>.<span style=color:#a6e22e>hi</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>hi</span> <span style=color:#75715e>// 计算新栈和旧栈之间内存地址差
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>ncopy</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>used</span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> {
		<span style=color:#a6e22e>adjustsudogs</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>adjinfo</span>)
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>adjinfo</span>.<span style=color:#a6e22e>sghi</span> = <span style=color:#a6e22e>findsghi</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>old</span>)
		<span style=color:#a6e22e>ncopy</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>syncadjustsudogs</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>used</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>adjinfo</span>)
	}

	<span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>new</span>.<span style=color:#a6e22e>hi</span><span style=color:#f92672>-</span><span style=color:#a6e22e>ncopy</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>hi</span><span style=color:#f92672>-</span><span style=color:#a6e22e>ncopy</span>), <span style=color:#a6e22e>ncopy</span>)

	<span style=color:#a6e22e>adjustctxt</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>adjinfo</span>)
	<span style=color:#a6e22e>adjustdefers</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>adjinfo</span>)
	<span style=color:#a6e22e>adjustpanics</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>adjinfo</span>)

	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>new</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stackguard0</span> = <span style=color:#a6e22e>new</span>.<span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_StackGuard</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>new</span>.<span style=color:#a6e22e>hi</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>used</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stktopsp</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>adjinfo</span>.<span style=color:#a6e22e>delta</span>
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>stackfree</span>(<span style=color:#a6e22e>old</span>)
}
</code></pre></div><p>调整指向栈内存的指针都会调用 <a href=/golang/tree/runtime.adjustpointer><code>runtime.adjustpointer</code></a>，该函数会利用 <a href=/golang/tree/runtime.adjustinfo><code>runtime.adjustinfo</code></a> 计算的新栈和旧栈之间的内存地址差来调整指针。所有的指针都被调整后，我们就可以更新 Goroutine 的几个变量并通过 <a href=/golang/tree/runtime.stackfree><code>runtime.stackfree</code></a> 释放原始栈的内存空间了。</p><h3 id=栈缩容>栈缩容
<a class=anchor href=#%e6%a0%88%e7%bc%a9%e5%ae%b9>#</a></h3><p><a href=/golang/tree/runtime.shrinkstack><code>runtime.shrinkstack</code></a> 栈缩容时调用的函数，该函数的实现原理非常简单，其中大部分都是检查是否满足缩容前置条件的代码，核心逻辑只有以下这几行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>shrinkstack</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>oldsize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span>
	<span style=color:#a6e22e>newsize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>oldsize</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newsize</span> &lt; <span style=color:#a6e22e>_FixedStack</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>avail</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>used</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sp</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_StackLimit</span>; <span style=color:#a6e22e>used</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>avail</span><span style=color:#f92672>/</span><span style=color:#ae81ff>4</span> {
		<span style=color:#66d9ef>return</span>
	}

	<span style=color:#a6e22e>copystack</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>newsize</span>)
}
</code></pre></div><p>如果要触发栈的缩容，新栈的大小会是原始栈的一半，不过如果新栈的大小低于程序的最低限制 2KB，那么缩容的过程就会停止。</p><p><img src=https://img.draveness.me/2020-03-23-15849514795902-shrink-stacks.png alt=shrink-stacks></p><p><strong>图 7-48 栈的缩容操作</strong></p><p>运行时只会在栈内存使用不足 1/4 时进行缩容，缩容也会调用扩容时使用的 <a href=/golang/tree/runtime.copystack><code>runtime.copystack</code></a> 开辟新的栈空间。</p><h2 id=733-小结>7.3.3 小结
<a class=anchor href=#733-%e5%b0%8f%e7%bb%93>#</a></h2><p>栈内存是应用程序中重要的内存空间，它能够支持本地的局部变量和函数调用，栈空间中的变量会与栈一同创建和销毁，这部分内存空间不需要工程师过多的干预和管理，现代的编程语言通过逃逸分析减少了我们的工作量，理解栈空间的分配对于理解 Go 语言的运行时有很大的帮助。</p><h2 id=734-延伸阅读>7.3.4 延伸阅读
<a class=anchor href=#734-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=https://dave.cheney.net/2014/09/01/gos-runtime-c-to-go-rewrite-by-the-numbers>Go’s runtime C to Go rewrite, by the numbers</a></li><li><a href=http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html>Re: proc fs and shared pids</a></li><li><a href=https://docs.google.com/document/d/1lyPIbmsYbXnpNj57a261hgOYVpNRcgydurVQIyZOz_o/pub>Go 1.2 Runtime Symbol Information</a></li><li><a href=https://docs.google.com/document/d/13v_u3UrN2pgUtPnH4y-qfmlXwEEryikFu0SQiwk35SA/pub>Precise Stack Roots</a></li><li><a href="https://docs.google.com/document/d/1un-Jn47yByHL7I0aVIP_uVCMxjdM5mpelJhiKlIqxkE/edit#heading=h.bvezjdnoi4no">GC scanning of stacks</a></li><li><a href=https://medium.com/a-journey-with-go/go-how-does-the-goroutine-stack-size-evolve-447fc02085e5>Go: How Does the Goroutine Stack Size Evolve?</a></li></ul><p><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/ class=book-btn>上一节</a>
<a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Wikipedia: Processor register <a href=https://en.wikipedia.org/wiki/Processor_register>https://en.wikipedia.org/wiki/Processor_register</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Wikipedia: Stack register <a href=https://en.wikipedia.org/wiki/Stack_register>https://en.wikipedia.org/wiki/Stack_register</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>pthread_create - create a new thread <a href=http://man7.org/linux/man-pages/man3/pthread_create.3.html>http://man7.org/linux/man-pages/man3/pthread_create.3.html</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Linus Torvalds. &ldquo;Re: proc fs and shared pids&rdquo; <a href=http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html>http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Wikipedia: Escape analysis <a href=https://en.wikipedia.org/wiki/Escape_analysis>https://en.wikipedia.org/wiki/Escape_analysis</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>Escape analysis <a href=https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/escape.go>https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/escape.go</a> <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7 role=doc-endnote><p>Stack size · Go 1.2 Release Notes <a href=https://golang.org/doc/go1.2#stack_size>https://golang.org/doc/go1.2#stack_size</a> <a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8 role=doc-endnote><p>Stack · Go 1.3 Release Notes <a href=https://golang.org/doc/go1.3#stacks>https://golang.org/doc/go1.3#stacks</a> <a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9 role=doc-endnote><p>Changes to the runtime · Go 1.4 Release Notes <a href=https://golang.org/doc/go1.4#runtime>https://golang.org/doc/go1.4#runtime</a> <a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10 role=doc-endnote><p>Shrinking · Contiguous stacks <a href=https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub>https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub</a> <a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-stack-management data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-stack-management",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#73-栈空间管理>7.3 栈空间管理</a><ul><li><a href=#731-设计原理>7.3.1 设计原理</a><ul><li><a href=#寄存器>寄存器</a></li><li><a href=#线程栈>线程栈</a></li><li><a href=#逃逸分析>逃逸分析</a></li><li><a href=#栈内存空间>栈内存空间</a></li></ul></li><li><a href=#732-栈操作>7.3.2 栈操作</a><ul><li><a href=#栈初始化>栈初始化</a></li><li><a href=#栈分配>栈分配</a></li><li><a href=#栈扩容>栈扩容</a></li><li><a href=#栈缩容>栈缩容</a></li></ul></li><li><a href=#733-小结>7.3.3 小结</a></li><li><a href=#734-延伸阅读>7.3.4 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>