<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="2.5 机器码生成 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  Go 语言编译的最后一个阶段是根据 SSA 中间代码生成机器码，这里谈的机器码是在目标 CPU 架构上能够运行的二进制代码，中间代码生成一节简单介绍的从抽象语法树到 SSA 中间代码的生成过程，将近 50 个生成中间代码的步骤中有一些过程严格上说是属于机器码生成阶段的。
机器码的生成过程其实是对 SSA 中间代码的降级（lower）过程，在 SSA 中间代码降级的过程中，编译器将一些值重写成了目标 CPU 架构的特定值，降级的过程处理了所有机器特定的重写规则并对代码进行了一定程度的优化；在 SSA 中间代码生成阶段的最后，Go 函数体的代码会被转换成 cmd/compile/internal/obj.Prog 结构。
2.5.1 指令集架构 #  首先需要介绍的就是指令集架构，虽然我们在第一节编译过程概述中曾经讲解过指令集架构，但是在这里还是需要引入更多的指令集架构知识。
图 2-16 计算机软硬件之间的桥梁
指令集架构是计算机的抽象模型，在很多时候也被称作架构或者计算机架构，它是计算机软件和硬件之间的接口和桥梁1；一个为特定指令集架构编写的应用程序能够运行在所有支持这种指令集架构的机器上，也就是说如果当前应用程序支持 x86 的指令集，那么就可以运行在所有使用 x86 指令集的机器上，这其实就是抽象层的作用，每一个指令集架构都定义了支持的数据结构、寄存器、管理主内存的硬件支持（例如内存一致、地址模型和虚拟内存）、支持的指令集和 IO 模型，它的引入其实就在软件和硬件之间引入了一个抽象层，让同一个二进制文件能够在不同版本的硬件上运行。
如果一个编程语言想要在所有的机器上运行，它就可以将中间代码转换成使用不同指令集架构的机器码，这可比为不同硬件单独移植要简单的太多了。
图 2-17 复杂指令集（CISC）和精简指令集（RISC）
最常见的指令集架构分类方法是根据指令的复杂度将其分为复杂指令集（CISC）和精简指令集（RISC），复杂指令集架构包含了很多特定的指令，但是其中的一些指令很少会被程序使用，而精简指令集只实现了经常被使用的指令，不常用的操作都会通过组合简单指令来实现。
复杂指令集的特点就是指令数目多并且复杂，每条指令的字节长度并不相等，x86 就是常见的复杂指令集处理器，它的指令长度大小范围非常广，从 1 到 15 字节不等，对于长度不固定的指令，计算机必须额外对指令进行判断，这需要付出额外的性能损失2。
而精简指令集对指令的数目和寻址方式做了精简，大大减少指令数量的同时更容易实现，指令集中的每一个指令都使用标准的字节长度、执行时间相比复杂指令集会少很多，处理器在处理指令时也可以流水执行，提高了对并行的支持。作为一种常见的精简指令集处理器，arm 使用 4 个字节作为指令的固定长度，省略了判断指令的性能损失3，精简指令集其实就是利用了我们耳熟能详的 20/80 原则，用 20% 的基础指令和它们的组合来解决问题。
最开始的计算机使用复杂指令集是因为当时计算机的性能和内存比较有限，业界需要尽可能地减少机器需要执行的指令，所以更倾向于高度编码、长度不等以及多操作数的指令。不过随着计算机性能的提升，出现了精简指令集这种牺牲代码密度换取简单实现的设计；除此之外，硬件的飞速提升还带来了更多的寄存器和更高的时钟频率，软件开发人员也不再直接接触汇编代码，而是通过编译器和汇编器生成指令，复杂的机器指令对于编译器来说很难利用，所以精简指令在这种场景下更适合。
复杂指令集和精简指令集的使用是设计上的权衡，经过这么多年的发展，两种指令集也相互借鉴和学习，与最开始刚被设计出来时已经有了较大的差别，对于软件工程师来讲，复杂的硬件设备对于我们来说已经是领域下三层的知识了，其实不太需要掌握太多，但是对指令集架构感兴趣的读者可以找一些资料开拓眼界。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="指令集架构、机器码与 Go 语言"><meta property="og:description" content="2.5 机器码生成 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  Go 语言编译的最后一个阶段是根据 SSA 中间代码生成机器码，这里谈的机器码是在目标 CPU 架构上能够运行的二进制代码，中间代码生成一节简单介绍的从抽象语法树到 SSA 中间代码的生成过程，将近 50 个生成中间代码的步骤中有一些过程严格上说是属于机器码生成阶段的。
机器码的生成过程其实是对 SSA 中间代码的降级（lower）过程，在 SSA 中间代码降级的过程中，编译器将一些值重写成了目标 CPU 架构的特定值，降级的过程处理了所有机器特定的重写规则并对代码进行了一定程度的优化；在 SSA 中间代码生成阶段的最后，Go 函数体的代码会被转换成 cmd/compile/internal/obj.Prog 结构。
2.5.1 指令集架构 #  首先需要介绍的就是指令集架构，虽然我们在第一节编译过程概述中曾经讲解过指令集架构，但是在这里还是需要引入更多的指令集架构知识。
图 2-16 计算机软硬件之间的桥梁
指令集架构是计算机的抽象模型，在很多时候也被称作架构或者计算机架构，它是计算机软件和硬件之间的接口和桥梁1；一个为特定指令集架构编写的应用程序能够运行在所有支持这种指令集架构的机器上，也就是说如果当前应用程序支持 x86 的指令集，那么就可以运行在所有使用 x86 指令集的机器上，这其实就是抽象层的作用，每一个指令集架构都定义了支持的数据结构、寄存器、管理主内存的硬件支持（例如内存一致、地址模型和虚拟内存）、支持的指令集和 IO 模型，它的引入其实就在软件和硬件之间引入了一个抽象层，让同一个二进制文件能够在不同版本的硬件上运行。
如果一个编程语言想要在所有的机器上运行，它就可以将中间代码转换成使用不同指令集架构的机器码，这可比为不同硬件单独移植要简单的太多了。
图 2-17 复杂指令集（CISC）和精简指令集（RISC）
最常见的指令集架构分类方法是根据指令的复杂度将其分为复杂指令集（CISC）和精简指令集（RISC），复杂指令集架构包含了很多特定的指令，但是其中的一些指令很少会被程序使用，而精简指令集只实现了经常被使用的指令，不常用的操作都会通过组合简单指令来实现。
复杂指令集的特点就是指令数目多并且复杂，每条指令的字节长度并不相等，x86 就是常见的复杂指令集处理器，它的指令长度大小范围非常广，从 1 到 15 字节不等，对于长度不固定的指令，计算机必须额外对指令进行判断，这需要付出额外的性能损失2。
而精简指令集对指令的数目和寻址方式做了精简，大大减少指令数量的同时更容易实现，指令集中的每一个指令都使用标准的字节长度、执行时间相比复杂指令集会少很多，处理器在处理指令时也可以流水执行，提高了对并行的支持。作为一种常见的精简指令集处理器，arm 使用 4 个字节作为指令的固定长度，省略了判断指令的性能损失3，精简指令集其实就是利用了我们耳熟能详的 20/80 原则，用 20% 的基础指令和它们的组合来解决问题。
最开始的计算机使用复杂指令集是因为当时计算机的性能和内存比较有限，业界需要尽可能地减少机器需要执行的指令，所以更倾向于高度编码、长度不等以及多操作数的指令。不过随着计算机性能的提升，出现了精简指令集这种牺牲代码密度换取简单实现的设计；除此之外，硬件的飞速提升还带来了更多的寄存器和更高的时钟频率，软件开发人员也不再直接接触汇编代码，而是通过编译器和汇编器生成指令，复杂的机器指令对于编译器来说很难利用，所以精简指令在这种场景下更适合。
复杂指令集和精简指令集的使用是设计上的权衡，经过这么多年的发展，两种指令集也相互借鉴和学习，与最开始刚被设计出来时已经有了较大的差别，对于软件工程师来讲，复杂的硬件设备对于我们来说已经是领域下三层的知识了，其实不太需要掌握太多，但是对指令集架构感兴趣的读者可以找一些资料开拓眼界。"><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/"><title>指令集架构、机器码与 Go 语言 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>指令集架构、机器码与 Go 语言</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#25-机器码生成>2.5 机器码生成</a><ul><li><a href=#251-指令集架构>2.5.1 指令集架构</a></li><li><a href=#252-机器码生成>2.5.2 机器码生成</a><ul><li><a href=#ssa-降级>SSA 降级</a></li><li><a href=#汇编器>汇编器</a></li></ul></li><li><a href=#253-小结>2.5.3 小结</a></li><li><a href=#254-延伸阅读>2.5.4 延伸阅读</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=25-机器码生成>2.5 机器码生成
<a class=anchor href=#25-%e6%9c%ba%e5%99%a8%e7%a0%81%e7%94%9f%e6%88%90>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>Go 语言编译的最后一个阶段是根据 SSA 中间代码生成机器码，这里谈的机器码是在目标 CPU 架构上能够运行的二进制代码，<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>中间代码生成</a>一节简单介绍的从抽象语法树到 SSA 中间代码的生成过程，将近 50 个生成中间代码的步骤中有一些过程严格上说是属于机器码生成阶段的。</p><p>机器码的生成过程其实是对 SSA 中间代码的降级（lower）过程，在 SSA 中间代码降级的过程中，编译器将一些值重写成了目标 CPU 架构的特定值，降级的过程处理了所有机器特定的重写规则并对代码进行了一定程度的优化；在 SSA 中间代码生成阶段的最后，Go 函数体的代码会被转换成 <a href=/golang/tree/cmd/compile/internal/obj.Prog><code>cmd/compile/internal/obj.Prog</code></a> 结构。</p><h2 id=251-指令集架构>2.5.1 指令集架构
<a class=anchor href=#251-%e6%8c%87%e4%bb%a4%e9%9b%86%e6%9e%b6%e6%9e%84>#</a></h2><p>首先需要介绍的就是指令集架构，虽然我们在第一节<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>编译过程概述</a>中曾经讲解过指令集架构，但是在这里还是需要引入更多的指令集架构知识。</p><p><img src=https://img.draveness.me/2019-02-08-instruction-set-architecture.png alt=instruction-set-architecture></p><p><strong>图 2-16 计算机软硬件之间的桥梁</strong></p><p><a href=https://en.wikipedia.org/wiki/Instruction_set_architecture>指令集架构</a>是计算机的抽象模型，在很多时候也被称作架构或者计算机架构，它是计算机软件和硬件之间的接口和桥梁<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>；一个为特定指令集架构编写的应用程序能够运行在所有支持这种指令集架构的机器上，也就是说如果当前应用程序支持 x86 的指令集，那么就可以运行在所有使用 x86 指令集的机器上，这其实就是抽象层的作用，每一个指令集架构都定义了支持的数据结构、寄存器、管理主内存的硬件支持（例如内存一致、地址模型和虚拟内存）、支持的指令集和 IO 模型，它的引入其实就在软件和硬件之间引入了一个抽象层，让同一个二进制文件能够在不同版本的硬件上运行。</p><p>如果一个编程语言想要在所有的机器上运行，它就可以将中间代码转换成使用不同指令集架构的机器码，这可比为不同硬件单独移植要简单的太多了。</p><p><img src=https://img.draveness.me/2019-12-26-15773759175895-cisc-and-risc.png alt=cisc-and-ris></p><p><strong>图 2-17 复杂指令集（CISC）和精简指令集（RISC）</strong></p><p>最常见的指令集架构分类方法是根据指令的复杂度将其分为复杂指令集（CISC）和精简指令集（RISC），复杂指令集架构包含了很多特定的指令，但是其中的一些指令很少会被程序使用，而精简指令集只实现了经常被使用的指令，不常用的操作都会通过组合简单指令来实现。</p><p><a href=https://en.wikipedia.org/wiki/Complex_instruction_set_computer>复杂指令集</a>的特点就是指令数目多并且复杂，每条指令的字节长度并不相等，x86 就是常见的复杂指令集处理器，它的指令长度大小范围非常广，从 1 到 15 字节不等，对于长度不固定的指令，计算机必须额外对指令进行判断，这需要付出额外的性能损失<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</p><p>而<a href=https://en.wikipedia.org/wiki/Reduced_instruction_set_computer>精简指令集</a>对指令的数目和寻址方式做了精简，大大减少指令数量的同时更容易实现，指令集中的每一个指令都使用标准的字节长度、执行时间相比复杂指令集会少很多，处理器在处理指令时也可以流水执行，提高了对并行的支持。作为一种常见的精简指令集处理器，arm 使用 4 个字节作为指令的固定长度，省略了判断指令的性能损失<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，精简指令集其实就是利用了我们耳熟能详的 20/80 原则，用 20% 的基础指令和它们的组合来解决问题。</p><p>最开始的计算机使用复杂指令集是因为当时计算机的性能和内存比较有限，业界需要尽可能地减少机器需要执行的指令，所以更倾向于高度编码、长度不等以及多操作数的指令。不过随着计算机性能的提升，出现了精简指令集这种牺牲代码密度换取简单实现的设计；除此之外，硬件的飞速提升还带来了更多的寄存器和更高的时钟频率，软件开发人员也不再直接接触汇编代码，而是通过编译器和汇编器生成指令，复杂的机器指令对于编译器来说很难利用，所以精简指令在这种场景下更适合。</p><p>复杂指令集和精简指令集的使用是设计上的权衡，经过这么多年的发展，两种指令集也相互借鉴和学习，与最开始刚被设计出来时已经有了较大的差别，对于软件工程师来讲，复杂的硬件设备对于我们来说已经是领域下三层的知识了，其实不太需要掌握太多，但是对指令集架构感兴趣的读者可以找一些资料开拓眼界。</p><h2 id=252-机器码生成>2.5.2 机器码生成
<a class=anchor href=#252-%e6%9c%ba%e5%99%a8%e7%a0%81%e7%94%9f%e6%88%90>#</a></h2><p>机器码的生成在 Go 的编译器中主要由两部分协同工作，其中一部分是负责 SSA 中间代码降级和根据目标架构进行特定处理的 <a href=https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa><code>cmd/compile/internal/ssa</code></a> 包，另一部分是负责生成机器码的 <a href=https://github.com/golang/go/tree/master/src/cmd/internal/obj><code>cmd/internal/obj</code></a><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>：</p><ul><li><a href=https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa><code>cmd/compile/internal/ssa</code></a> 主要负责对 SSA 中间代码进行降级、执行架构特定的优化和重写并生成 <a href=/golang/tree/cmd/compile/internal/obj.Prog><code>cmd/compile/internal/obj.Prog</code></a> 指令；</li><li><a href=https://github.com/golang/go/tree/master/src/cmd/internal/obj><code>cmd/internal/obj</code></a> 作为汇编器会将这些指令转换成机器码完成这次编译；</li></ul><h3 id=ssa-降级>SSA 降级
<a class=anchor href=#ssa-%e9%99%8d%e7%ba%a7>#</a></h3><p>SSA 降级是在中间代码生成的过程中完成的，其中将近 50 轮处理的过程中，<code>lower</code> 以及后面的阶段都属于 SSA 降级这一过程，这么多轮的处理会将 SSA 转换成机器特定的操作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>passes</span> = [<span style=color:#f92672>...</span>]<span style=color:#a6e22e>pass</span>{
	<span style=color:#f92672>...</span>
	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;lower&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>lower</span>, <span style=color:#a6e22e>required</span>: <span style=color:#66d9ef>true</span>},
	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;lowered deadcode for cse&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>deadcode</span>}, <span style=color:#75715e>// deadcode immediately before CSE avoids CSE making dead values live again
</span><span style=color:#75715e></span>	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;lowered cse&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>cse</span>},
	<span style=color:#f92672>...</span>
	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;trim&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>trim</span>}, <span style=color:#75715e>// remove empty blocks
</span><span style=color:#75715e></span>}
</code></pre></div><p>SSA 降级执行的第一个阶段就是 <code>lower</code>，该阶段的入口方法是 <a href=/golang/tree/cmd/compile/internal/ssa.lower><code>cmd/compile/internal/ssa.lower</code></a> 函数，它会将 SSA 的中间代码转换成机器特定的指令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>lower</span>(<span style=color:#a6e22e>f</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Func</span>) {
	<span style=color:#a6e22e>applyRewrite</span>(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Config</span>.<span style=color:#a6e22e>lowerBlock</span>, <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Config</span>.<span style=color:#a6e22e>lowerValue</span>)
}
</code></pre></div><p>向 <a href=/golang/tree/cmd/compile/internal/ssa.applyRewrite><code>cmd/compile/internal/ssa.applyRewrite</code></a> 传入的两个函数 <code>lowerBlock</code> 和 <code>lowerValue</code> 是在<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>中间代码生成</a>阶段初始化 SSA 配置时确定的，这两个函数会分别转换函数中的代码块和代码块中的值。</p><p>假设目标机器使用 x86 的架构，最终会调用 <a href=/golang/tree/cmd/compile/internal/ssa.rewriteBlock386><code>cmd/compile/internal/ssa.rewriteBlock386</code></a> 和 <a href=/golang/tree/cmd/compile/internal/ssa.rewriteValue386><code>cmd/compile/internal/ssa.rewriteValue386</code></a> 两个函数，这两个函数是两个巨大的 switch 语句，前者总共有 2000 多行，后者将近 700 行，用于处理 x86 架构重写的函数总共有将近 30000 行代码，你能在 <a href=https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/rewrite386.go><code>cmd/compile/internal/ssa/rewrite386.go</code></a> 这里找到文件的全部内容，我们只节选其中的一段展示一下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rewriteValue386</span>(<span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Op386ADCL</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rewriteValue386_Op386ADCL_0</span>(<span style=color:#a6e22e>v</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Op386ADDL</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rewriteValue386_Op386ADDL_0</span>(<span style=color:#a6e22e>v</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>rewriteValue386_Op386ADDL_10</span>(<span style=color:#a6e22e>v</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>rewriteValue386_Op386ADDL_20</span>(<span style=color:#a6e22e>v</span>)
	<span style=color:#f92672>...</span>
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rewriteValue386_Op386ADCL_0</span>(<span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#75715e>// match: (ADCL x (MOVLconst [c]) f)
</span><span style=color:#75715e></span>	<span style=color:#75715e>// cond:
</span><span style=color:#75715e></span>	<span style=color:#75715e>// result: (ADCLconst [c] x f)
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>2</span>]
		<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>0</span>]
		<span style=color:#a6e22e>v_1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>]
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v_1</span>.<span style=color:#a6e22e>Op</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>Op386MOVLconst</span> {
			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v_1</span>.<span style=color:#a6e22e>AuxInt</span>
		<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>2</span>]
		<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>reset</span>(<span style=color:#a6e22e>Op386ADCLconst</span>)
		<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>AuxInt</span> = <span style=color:#a6e22e>c</span>
		<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>AddArg</span>(<span style=color:#a6e22e>x</span>)
		<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>AddArg</span>(<span style=color:#a6e22e>f</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>重写的过程会将通用的 SSA 中间代码转换成目标架构特定的指令，上述的 <code>rewriteValue386_Op386ADCL_0</code> 函数会使用 <code>ADCLconst</code> 替换 <code>ADCL</code> 和 <code>MOVLconst</code> 两条指令，它能通过对指令的压缩和优化减少在目标硬件上执行所需要的时间和资源。</p><p>我们在上一节中间代码生成中已经介绍过 <a href=/golang/tree/cmd/compile/internal/gc.compileSSA><code>cmd/compile/internal/gc.compileSSA</code></a> 中调用 <a href=/golang/tree/cmd/compile/internal/gc.buildssa><code>cmd/compile/internal/gc.buildssa</code></a> 的执行过程，我们在这里继续介绍 <a href=/golang/tree/cmd/compile/internal/gc.buildssa><code>cmd/compile/internal/gc.buildssa</code></a> 函数返回后的逻辑：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>compileSSA</span>(<span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>worker</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>buildssa</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>worker</span>)
	<span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newProgs</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>worker</span>)
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>Free</span>()
	<span style=color:#a6e22e>genssa</span>(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>pp</span>)

	<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>Flush</span>()
}
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/gc.genssa><code>cmd/compile/internal/gc.genssa</code></a> 函数会创建一个新的 <a href=/golang/tree/cmd/compile/internal/gc.Progs><code>cmd/compile/internal/gc.Progs</code></a> 结构并将生成的 SSA 中间代码都存入新建的结构体中，我们在上一节得到的 ssa.html 文件就包含最后生成的中间代码：</p><p><img src=https://img.draveness.me/2019-12-26-15773759175909-genssa.png alt=genssa></p><p><strong>图 2-18 genssa 的执行结果</strong></p><p>上述输出结果跟最后生成的汇编代码已经非常相似了，随后调用的 <a href=/golang/tree/cmd/compile/internal/gc.Progs.Flush><code>cmd/compile/internal/gc.Progs.Flush</code></a> 会使用 <a href=https://github.com/golang/go/tree/master/src/cmd/internal/obj><code>cmd/internal/obj</code></a> 包中的汇编器将 SSA 转换成汇编代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Progs</span>) <span style=color:#a6e22e>Flush</span>() {
	<span style=color:#a6e22e>plist</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>Plist</span>{<span style=color:#a6e22e>Firstpc</span>: <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>Text</span>, <span style=color:#a6e22e>Curfn</span>: <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>curfn</span>}
	<span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>Flushplist</span>(<span style=color:#a6e22e>Ctxt</span>, <span style=color:#a6e22e>plist</span>, <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>NewProg</span>, <span style=color:#a6e22e>myimportpath</span>)
}
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/gc.buildssa><code>cmd/compile/internal/gc.buildssa</code></a> 中的 <code>lower</code> 和随后的多个阶段会对 SSA 进行转换、检查和优化，生成机器特定的中间代码，接下来通过 <a href=/golang/tree/cmd/compile/internal/gc.genssa><code>cmd/compile/internal/gc.genssa</code></a> 将代码输出到 <a href=/golang/tree/cmd/compile/internal/gc.Progs><code>cmd/compile/internal/gc.Progs</code></a> 对象中，这也是代码进入汇编器前的最后一个步骤。</p><h3 id=汇编器>汇编器
<a class=anchor href=#%e6%b1%87%e7%bc%96%e5%99%a8>#</a></h3><p>汇编器是将汇编语言翻译为机器语言的程序，Go 语言的汇编器是基于 Plan 9 汇编器的输入类型设计的，Go 语言对于汇编语言 Plan 9 和汇编器的资料十分缺乏，网上能够找到的资料也大多都含糊不清，官方对汇编器在不同处理器架构上的实现细节也没有明确定义：</p><blockquote><p>The details vary with architecture, and we apologize for the imprecision; the situation is <strong>not well-defined</strong>.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p></blockquote><p>我们在研究汇编器和汇编语言时不应该陷入细节，只需要理解汇编语言的执行逻辑就能够帮助我们快速读懂汇编代码。当我们将如下的代码编译成汇编指令时，会得到如下的内容：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#a6e22e>cat</span> <span style=color:#a6e22e>hello</span>.<span style=color:#66d9ef>go</span>
<span style=color:#f92672>package</span> <span style=color:#a6e22e>hello</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
}
<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#a6e22e>GOOS</span>=<span style=color:#a6e22e>linux</span> <span style=color:#a6e22e>GOARCH</span>=<span style=color:#a6e22e>amd64</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>tool</span> <span style=color:#a6e22e>compile</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>S</span> <span style=color:#a6e22e>hello</span>.<span style=color:#66d9ef>go</span>
<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>hello</span> <span style=color:#a6e22e>STEXT</span> <span style=color:#a6e22e>nosplit</span> <span style=color:#a6e22e>size</span>=<span style=color:#ae81ff>15</span> <span style=color:#a6e22e>args</span>=<span style=color:#ae81ff>0x10</span> <span style=color:#a6e22e>locals</span>=<span style=color:#ae81ff>0x0</span>
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>3</span>)	<span style=color:#a6e22e>TEXT</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>16</span>
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>3</span>)	<span style=color:#a6e22e>FUNCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>gclocals</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#ae81ff>33</span><span style=color:#a6e22e>cdeccccebe80329f1fdbee7f5874cb</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>3</span>)	<span style=color:#a6e22e>FUNCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>gclocals</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#ae81ff>33</span><span style=color:#a6e22e>cdeccccebe80329f1fdbee7f5874cb</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>3</span>)	<span style=color:#a6e22e>FUNCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>3</span>, <span style=color:#a6e22e>gclocals</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#ae81ff>33</span><span style=color:#a6e22e>cdeccccebe80329f1fdbee7f5874cb</span>(<span style=color:#a6e22e>SB</span>)
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>00000</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>
	<span style=color:#ae81ff>0x0005</span> <span style=color:#ae81ff>00005</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>4</span>)	<span style=color:#a6e22e>ADDQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>AX</span>
	<span style=color:#ae81ff>0x0009</span> <span style=color:#ae81ff>0000</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>)
	<span style=color:#ae81ff>0x000e</span> <span style=color:#ae81ff>00014</span> (<span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>5</span>)	<span style=color:#a6e22e>RET</span>
	<span style=color:#ae81ff>0x0000</span> <span style=color:#ae81ff>48</span> <span style=color:#ae81ff>8</span><span style=color:#a6e22e>b</span> <span style=color:#ae81ff>44</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>08</span> <span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> <span style=color:#a6e22e>c0</span> <span style=color:#ae81ff>02</span> <span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> <span style=color:#ae81ff>44</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>10</span> <span style=color:#a6e22e>c3</span>     <span style=color:#a6e22e>H</span>.<span style=color:#a6e22e>D</span><span style=color:#960050;background-color:#1e0010>$</span>.<span style=color:#a6e22e>H</span><span style=color:#f92672>...</span><span style=color:#a6e22e>H</span>.<span style=color:#a6e22e>D</span><span style=color:#960050;background-color:#1e0010>$</span>..
<span style=color:#f92672>...</span>
</code></pre></div><p>上述汇编代码都是由 <a href=/golang/tree/cmd/internal/obj.Flushplist><code>cmd/internal/obj.Flushplist</code></a> 这个函数生成的，该函数会调用架构特定的 <code>Preprocess</code> 和 <code>Assemble</code> 方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Flushplist</span>(<span style=color:#a6e22e>ctxt</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Link</span>, <span style=color:#a6e22e>plist</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Plist</span>, <span style=color:#a6e22e>newprog</span> <span style=color:#a6e22e>ProgAlloc</span>, <span style=color:#a6e22e>myimportpath</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#f92672>...</span>

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>text</span> {
		<span style=color:#a6e22e>mkfwd</span>(<span style=color:#a6e22e>s</span>)
		<span style=color:#a6e22e>linkpatch</span>(<span style=color:#a6e22e>ctxt</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>newprog</span>)
		<span style=color:#a6e22e>ctxt</span>.<span style=color:#a6e22e>Arch</span>.<span style=color:#a6e22e>Preprocess</span>(<span style=color:#a6e22e>ctxt</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>newprog</span>)
		<span style=color:#a6e22e>ctxt</span>.<span style=color:#a6e22e>Arch</span>.<span style=color:#a6e22e>Assemble</span>(<span style=color:#a6e22e>ctxt</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>newprog</span>)
		<span style=color:#a6e22e>linkpcln</span>(<span style=color:#a6e22e>ctxt</span>, <span style=color:#a6e22e>s</span>)
		<span style=color:#a6e22e>ctxt</span>.<span style=color:#a6e22e>populateDWARF</span>(<span style=color:#a6e22e>plist</span>.<span style=color:#a6e22e>Curfn</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>myimportpath</span>)
	}
}
</code></pre></div><p>Go 编译器会在最外层的主函数确定调用的 <code>Preprocess</code> 和 <code>Assemble</code> 方法，编译器在 2.1.4 中提到的 <a href=/golang/tree/cmd/compile.archInits><code>cmd/compile.archInits</code></a> 中根据目标硬件初始化当前架构使用的配置。</p><p>如果目标机器的架构是 x86，那么这两个函数最终会使用 <a href=/golang/tree/cmd/internal/obj/x86.preprocess><code>cmd/internal/obj/x86.preprocess</code></a> 和 <a href=/golang/tree/cmd/internal/obj/x86.span6><code>cmd/internal/obj/x86.span6</code></a>，作者在这里就不展开介绍这两个特别复杂的底层函数了，有兴趣的读者可以通过链接找到目标函数的位置了解预处理和汇编的处理过程，机器码的生成也都是由这两个函数组合完成的。</p><h2 id=253-小结>2.5.3 小结
<a class=anchor href=#253-%e5%b0%8f%e7%bb%93>#</a></h2><p>机器码生成作为 Go 语言编译的最后一步，其实已经到了硬件和机器指令这一层，其中对于内存、寄存器的处理非常复杂并且难以阅读，想要真正掌握这里的处理的步骤和原理还是需要耗费很多精力。</p><p>作为软件工程师，如果不是 Go 语言编译器的开发者或者需要经常处理汇编语言和机器指令，掌握这些知识的投资回报率实在太低，我们只需要对这个过程有所了解，补全知识上的盲点，在遇到问题时能够快速定位即可。</p><h2 id=254-延伸阅读>2.5.4 延伸阅读
<a class=anchor href=#254-%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb>#</a></h2><ul><li><a href=https://9p.io/sys/doc/asm.html>A Manual for the Plan 9 assembler</a></li></ul><p><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/ class=book-btn>上一节</a>
<a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Instruction set architecture <a href=https://en.wikipedia.org/wiki/Instruction_set_architecture>https://en.wikipedia.org/wiki/Instruction_set_architecture</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>复杂指令集 Complex instruction set computer <a href=https://en.wikipedia.org/wiki/Complex_instruction_set_computer>https://en.wikipedia.org/wiki/Complex_instruction_set_computer</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>精简指令集 Reduced instruction set computer <a href=https://en.wikipedia.org/wiki/Reduced_instruction_set_computer>https://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Introduction to the Go compiler <a href=https://github.com/golang/go/blob/master/src/cmd/compile/README.md>https://github.com/golang/go/blob/master/src/cmd/compile/README.md</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>A Quick Guide to Go&rsquo;s Assembler <a href=https://golang.org/doc/asm>https://golang.org/doc/asm</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-machinecode data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-machinecode",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#25-机器码生成>2.5 机器码生成</a><ul><li><a href=#251-指令集架构>2.5.1 指令集架构</a></li><li><a href=#252-机器码生成>2.5.2 机器码生成</a><ul><li><a href=#ssa-降级>SSA 降级</a></li><li><a href=#汇编器>汇编器</a></li></ul></li><li><a href=#253-小结>2.5.3 小结</a></li><li><a href=#254-延伸阅读>2.5.4 延伸阅读</a></li></ul></li></ul></nav></aside></main></body></html>