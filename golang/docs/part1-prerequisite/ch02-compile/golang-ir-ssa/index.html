<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="2.4 中间代码生成 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  前两节介绍的词法与语法分析以及类型检查两个部分都属于编译器前端，它们负责对源代码进行分析并检查其中存在的词法和语法错误，经过这两个阶段生成的抽象语法树已经不存在语法错误了，本节将继续介绍编译器的后端工作 —— 中间代码生成。
2.4.1 概述 #  中间代码是编译器或者虚拟机使用的语言，它可以来帮助我们分析计算机程序。在编译过程中，编译器会在将源代码转换到机器码的过程中，先把源代码转换成一种中间的表示形式，即中间代码1。
图 2-12 源代码、中间代码和机器码
很多读者可能认为中间代码没有太多价值，我们可以直接将源代码翻译成目标语言，这种看起来可行的办法实际上有很多问题，其中最主要的是：它忽略了编译器面对的复杂场景，很多编译器需要将源代码翻译成多种机器码，直接翻译高级编程语言相对比较困难。
将编程语言到机器码的过程拆成中间代码生成和机器码生成两个简单步骤可以简化该问题，中间代码是一种更接近机器语言的表示形式，对中间代码的优化和分析相比直接分析高级编程语言更容易。
Go 语言编译器的中间代码具有静态单赋值（SSA）的特性，我们在 Go 语言编译过程一节曾经介绍过静态单赋值，对这个特性不了解的读者可以回到上面的章节阅读相关的内容。
我们再来回忆一下编译阶段入口的主函数 cmd/compile/internal/gc.Main 中关于中间代码生成的部分，这一段代码会初始化 SSA 生成的配置，在配置初始化结束后会调用 cmd/compile/internal/gc.funccompile 编译函数：
func Main(archInit func(*Arch)) { ... initssaconfig() for i := 0; i < len(xtop); i++ { n := xtop[i] if n.Op == ODCLFUNC { funccompile(n) } } compileFunctions() } 这一节将分别介绍配置的初始化以及函数编译两部分内容，我们会以 cmd/compile/internal/gc.initssaconfig 和 cmd/compile/internal/gc.funccompile 这两个函数作为入口来分析中间代码生成的具体过程和实现原理。
2.4.2 配置初始化 #  SSA 配置的初始化过程是中间代码生成之前的准备工作，在该过程中，我们会缓存可能用到的类型指针、初始化 SSA 配置和一些之后会调用的运行时函数，例如：用于处理 defer 关键字的 runtime."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="详解 Go 语言中间代码生成"><meta property="og:description" content="2.4 中间代码生成 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  前两节介绍的词法与语法分析以及类型检查两个部分都属于编译器前端，它们负责对源代码进行分析并检查其中存在的词法和语法错误，经过这两个阶段生成的抽象语法树已经不存在语法错误了，本节将继续介绍编译器的后端工作 —— 中间代码生成。
2.4.1 概述 #  中间代码是编译器或者虚拟机使用的语言，它可以来帮助我们分析计算机程序。在编译过程中，编译器会在将源代码转换到机器码的过程中，先把源代码转换成一种中间的表示形式，即中间代码1。
图 2-12 源代码、中间代码和机器码
很多读者可能认为中间代码没有太多价值，我们可以直接将源代码翻译成目标语言，这种看起来可行的办法实际上有很多问题，其中最主要的是：它忽略了编译器面对的复杂场景，很多编译器需要将源代码翻译成多种机器码，直接翻译高级编程语言相对比较困难。
将编程语言到机器码的过程拆成中间代码生成和机器码生成两个简单步骤可以简化该问题，中间代码是一种更接近机器语言的表示形式，对中间代码的优化和分析相比直接分析高级编程语言更容易。
Go 语言编译器的中间代码具有静态单赋值（SSA）的特性，我们在 Go 语言编译过程一节曾经介绍过静态单赋值，对这个特性不了解的读者可以回到上面的章节阅读相关的内容。
我们再来回忆一下编译阶段入口的主函数 cmd/compile/internal/gc.Main 中关于中间代码生成的部分，这一段代码会初始化 SSA 生成的配置，在配置初始化结束后会调用 cmd/compile/internal/gc.funccompile 编译函数：
func Main(archInit func(*Arch)) { ... initssaconfig() for i := 0; i < len(xtop); i++ { n := xtop[i] if n.Op == ODCLFUNC { funccompile(n) } } compileFunctions() } 这一节将分别介绍配置的初始化以及函数编译两部分内容，我们会以 cmd/compile/internal/gc.initssaconfig 和 cmd/compile/internal/gc.funccompile 这两个函数作为入口来分析中间代码生成的具体过程和实现原理。
2.4.2 配置初始化 #  SSA 配置的初始化过程是中间代码生成之前的准备工作，在该过程中，我们会缓存可能用到的类型指针、初始化 SSA 配置和一些之后会调用的运行时函数，例如：用于处理 defer 关键字的 runtime."><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/"><title>详解 Go 语言中间代码生成 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>详解 Go 语言中间代码生成</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#24-中间代码生成>2.4 中间代码生成</a><ul><li><a href=#241-概述>2.4.1 概述</a></li><li><a href=#242-配置初始化>2.4.2 配置初始化</a></li><li><a href=#243-遍历和替换>2.4.3 遍历和替换</a></li><li><a href=#244-ssa-生成>2.4.4 SSA 生成</a><ul><li><a href=#ast-到-ssa>AST 到 SSA</a></li><li><a href=#多轮转换>多轮转换</a></li></ul></li><li><a href=#245-小结>2.4.5 小结</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=24-中间代码生成>2.4 中间代码生成
<a class=anchor href=#24-%e4%b8%ad%e9%97%b4%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>前两节介绍的<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>词法与语法分析</a>以及<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>类型检查</a>两个部分都属于编译器前端，它们负责对源代码进行分析并检查其中存在的词法和语法错误，经过这两个阶段生成的抽象语法树已经不存在语法错误了，本节将继续介绍编译器的后端工作 —— 中间代码生成。</p><h2 id=241-概述>2.4.1 概述
<a class=anchor href=#241-%e6%a6%82%e8%bf%b0>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Intermediate_representation>中间代码</a>是编译器或者虚拟机使用的语言，它可以来帮助我们分析计算机程序。在编译过程中，编译器会在将源代码转换到机器码的过程中，先把源代码转换成一种中间的表示形式，即中间代码<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。</p><p><img src=https://img.draveness.me/2019-12-23-15771129929822-intermediate-representation.png alt=intermediate-representation></p><p><strong>图 2-12 源代码、中间代码和机器码</strong></p><p>很多读者可能认为中间代码没有太多价值，我们可以直接将源代码翻译成目标语言，这种看起来可行的办法实际上有很多问题，其中最主要的是：它忽略了编译器面对的复杂场景，很多编译器需要将源代码翻译成多种机器码，直接翻译高级编程语言相对比较困难。</p><p>将编程语言到机器码的过程拆成中间代码生成和机器码生成两个简单步骤可以简化该问题，中间代码是一种更接近机器语言的表示形式，对中间代码的优化和分析相比直接分析高级编程语言更容易。</p><p>Go 语言编译器的中间代码具有静态单赋值（SSA）的特性，我们在 <a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>Go 语言编译过程</a>一节曾经介绍过静态单赋值，对这个特性不了解的读者可以回到上面的章节阅读相关的内容。</p><p>我们再来回忆一下编译阶段入口的主函数 <a href=/golang/tree/cmd/compile/internal/gc.Main><code>cmd/compile/internal/gc.Main</code></a> 中关于中间代码生成的部分，这一段代码会初始化 SSA 生成的配置，在配置初始化结束后会调用 <a href=/golang/tree/cmd/compile/internal/gc.funccompile><code>cmd/compile/internal/gc.funccompile</code></a> 编译函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Main</span>(<span style=color:#a6e22e>archInit</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>Arch</span>)) {
	<span style=color:#f92672>...</span>

	<span style=color:#a6e22e>initssaconfig</span>()

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>xtop</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>xtop</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ODCLFUNC</span> {
			<span style=color:#a6e22e>funccompile</span>(<span style=color:#a6e22e>n</span>)
		}
	}

	<span style=color:#a6e22e>compileFunctions</span>()
}
</code></pre></div><p>这一节将分别介绍配置的初始化以及函数编译两部分内容，我们会以 <a href=/golang/tree/cmd/compile/internal/gc.initssaconfig><code>cmd/compile/internal/gc.initssaconfig</code></a> 和 <a href=/golang/tree/cmd/compile/internal/gc.funccompile><code>cmd/compile/internal/gc.funccompile</code></a> 这两个函数作为入口来分析中间代码生成的具体过程和实现原理。</p><h2 id=242-配置初始化>2.4.2 配置初始化
<a class=anchor href=#242-%e9%85%8d%e7%bd%ae%e5%88%9d%e5%a7%8b%e5%8c%96>#</a></h2><p>SSA 配置的初始化过程是中间代码生成之前的准备工作，在该过程中，我们会缓存可能用到的类型指针、初始化 SSA 配置和一些之后会调用的运行时函数，例如：用于处理 <code>defer</code> 关键字的 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a>、用于创建 Goroutine 的 <a href=/golang/tree/runtime.newproc><code>runtime.newproc</code></a> 和扩容切片的 <a href=/golang/tree/runtime.growslice><code>runtime.growslice</code></a> 等，除此之外还会根据当前的目标设备初始化特定的 ABI<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。我们以 <a href=/golang/tree/cmd/compile/internal/gc.initssaconfig><code>cmd/compile/internal/gc.initssaconfig</code></a> 作为入口开始分析配置初始化的过程。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>initssaconfig</span>() {
	<span style=color:#a6e22e>types_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>NewTypes</span>()

	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewPtr</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TINTER</span>])                             <span style=color:#75715e>// *interface{}
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewPtr</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewPtr</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TSTRING</span>]))              <span style=color:#75715e>// **string
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewPtr</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewPtr</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Idealstring</span>))                 <span style=color:#75715e>// **string
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewPtr</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewSlice</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TINTER</span>]))             <span style=color:#75715e>// *[]interface{}
</span><span style=color:#75715e></span>	..
	<span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewPtr</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Errortype</span>)                                 <span style=color:#75715e>// *error
</span></code></pre></div><p>这个函数的执行过程总共可以分成三个部分，首先就是调用 <a href=/golang/tree/cmd/compile/internal/ssa.NewTypes><code>cmd/compile/internal/ssa.NewTypes</code></a> 初始化 <a href=/golang/tree/cmd/compile/internal/ssa.Types><code>cmd/compile/internal/ssa.Types</code></a> 结构体并调用 <a href=/golang/tree/cmd/compile/internal/types.NewPtr><code>cmd/compile/internal/types.NewPtr</code></a> 函数缓存类型的信息，<a href=/golang/tree/cmd/compile/internal/ssa.Types><code>cmd/compile/internal/ssa.Types</code></a> 中存储了所有 Go 语言中基本类型对应的指针，比如 <code>Bool</code>、<code>Int8</code>、以及 <code>String</code> 等。</p><p><img src=https://img.draveness.me/2019-02-05-golang-type-and-pointer.png alt=golang-type-and-pointer></p><p><strong>图 2-12 类型和类型指针</strong></p><p><a href=/golang/tree/cmd/compile/internal/types.NewPtr><code>cmd/compile/internal/types.NewPtr</code></a> 函数的主要作用是根据类型生成指向这些类型的指针，同时它会根据编译器的配置将生成的指针类型缓存在当前类型中，优化类型指针的获取效率：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewPtr</span>(<span style=color:#a6e22e>elem</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Type</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Type</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Cache</span>.<span style=color:#a6e22e>ptr</span>; <span style=color:#a6e22e>t</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Elem</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>elem</span> {
			<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;NewPtr: elem mismatch&#34;</span>)
		}
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>
	}

	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>TPTR</span>)
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Extra</span> = <span style=color:#a6e22e>Ptr</span>{<span style=color:#a6e22e>Elem</span>: <span style=color:#a6e22e>elem</span>}
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Width</span> = int64(<span style=color:#a6e22e>Widthptr</span>)
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Align</span> = uint8(<span style=color:#a6e22e>Widthptr</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>NewPtrCacheEnabled</span> {
		<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Cache</span>.<span style=color:#a6e22e>ptr</span> = <span style=color:#a6e22e>t</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>
}
</code></pre></div><p>配置初始化的第二步是根据当前的 CPU 架构初始化 SSA 配置，我们会向 <a href=/golang/tree/cmd/compile/internal/ssa.NewConfig><code>cmd/compile/internal/ssa.NewConfig</code></a> 函数传入目标机器的 CPU 架构、上述代码初始化的 <a href=/golang/tree/cmd/compile/internal/ssa.Types><code>cmd/compile/internal/ssa.Types</code></a> 结构体、上下文信息和 Debug 配置：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>ssaConfig</span> = <span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>NewConfig</span>(<span style=color:#a6e22e>thearch</span>.<span style=color:#a6e22e>LinkArch</span>.<span style=color:#a6e22e>Name</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>types_</span>, <span style=color:#a6e22e>Ctxt</span>, <span style=color:#a6e22e>Debug</span>[<span style=color:#e6db74>&#39;N&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/ssa.NewConfig><code>cmd/compile/internal/ssa.NewConfig</code></a> 会根据传入的 CPU 架构设置用于生成中间代码和机器码的函数，当前编译器使用的指针、寄存器大小、可用寄存器列表、掩码等编译选项：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewConfig</span>(<span style=color:#a6e22e>arch</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>types</span> <span style=color:#a6e22e>Types</span>, <span style=color:#a6e22e>ctxt</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>Link</span>, <span style=color:#a6e22e>optimize</span> <span style=color:#66d9ef>bool</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Config</span> {
	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Config</span>{<span style=color:#a6e22e>arch</span>: <span style=color:#a6e22e>arch</span>, <span style=color:#a6e22e>Types</span>: <span style=color:#a6e22e>types</span>}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>useAvg</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>useHmul</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>arch</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;amd64&#34;</span>:
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>PtrSize</span> = <span style=color:#ae81ff>8</span>
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>RegSize</span> = <span style=color:#ae81ff>8</span>
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lowerBlock</span> = <span style=color:#a6e22e>rewriteBlockAMD64</span>
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lowerValue</span> = <span style=color:#a6e22e>rewriteValueAMD64</span>
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>registers</span> = <span style=color:#a6e22e>registersAMD64</span>[:]
		<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;arm64&#34;</span>:
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;wasm&#34;</span>:
	<span style=color:#66d9ef>default</span>:
		<span style=color:#a6e22e>ctxt</span>.<span style=color:#a6e22e>Diag</span>(<span style=color:#e6db74>&#34;arch %s not implemented&#34;</span>, <span style=color:#a6e22e>arch</span>)
	}
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>ctxt</span> = <span style=color:#a6e22e>ctxt</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>optimize</span> = <span style=color:#a6e22e>optimize</span>

	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
}
</code></pre></div><p>所有的配置项一旦被创建，在整个编译期间都是只读的并且被全部编译阶段共享，也就是中间代码生成和机器码生成这两部分都会使用这一份配置完成自己的工作。在 <a href=/golang/tree/cmd/compile/internal/gc.initssaconfig><code>cmd/compile/internal/gc.initssaconfig</code></a> 方法调用的最后，会初始化一些编译器可能用到的 Go 语言运行时的函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>assertE2I</span> = <span style=color:#a6e22e>sysfunc</span>(<span style=color:#e6db74>&#34;assertE2I&#34;</span>)
	<span style=color:#a6e22e>assertE2I2</span> = <span style=color:#a6e22e>sysfunc</span>(<span style=color:#e6db74>&#34;assertE2I2&#34;</span>)
	<span style=color:#a6e22e>assertI2I</span> = <span style=color:#a6e22e>sysfunc</span>(<span style=color:#e6db74>&#34;assertI2I&#34;</span>)
	<span style=color:#a6e22e>assertI2I2</span> = <span style=color:#a6e22e>sysfunc</span>(<span style=color:#e6db74>&#34;assertI2I2&#34;</span>)
	<span style=color:#a6e22e>deferproc</span> = <span style=color:#a6e22e>sysfunc</span>(<span style=color:#e6db74>&#34;deferproc&#34;</span>)
	<span style=color:#a6e22e>Deferreturn</span> = <span style=color:#a6e22e>sysfunc</span>(<span style=color:#e6db74>&#34;deferreturn&#34;</span>)
	<span style=color:#f92672>...</span>
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/ssa.sysfunc><code>cmd/compile/internal/ssa.sysfunc</code></a> 函数会在对应的运行时包结构体 <a href=/golang/tree/cmd/compile/internal/types.Pkg><code>cmd/compile/internal/types.Pkg</code></a> 中创建一个新的符号 <a href=/golang/tree/cmd/compile/internal/obj.LSym><code>cmd/compile/internal/obj.LSym</code></a>，表示该方法已经注册到运行时包中。后面的中间代码生成阶段中直接使用这些方法，例如：上述代码片段中的 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 和 <a href=/golang/tree/runtime.deferreturn><code>runtime.deferreturn</code></a> 就是 Go 语言用于实现 defer 关键字的运行时函数，你能从后面的章节中了解更多内容。</p><h2 id=243-遍历和替换>2.4.3 遍历和替换
<a class=anchor href=#243-%e9%81%8d%e5%8e%86%e5%92%8c%e6%9b%bf%e6%8d%a2>#</a></h2><p>在生成中间代码之前，编译器还需要替换抽象语法树中节点的一些元素，这个替换的过程是通过 <a href=/golang/tree/cmd/compile/internal/gc.walk><code>cmd/compile/internal/gc.walk</code></a> 和以相关函数实现的，这里简单展示几个函数的签名：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walk</span>(<span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>)
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkappend</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>, <span style=color:#a6e22e>dst</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>
<span style=color:#f92672>...</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkrange</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkselect</span>(<span style=color:#a6e22e>sel</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>)
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkselectcases</span>(<span style=color:#a6e22e>cases</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkstmt</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkstmtlist</span>(<span style=color:#a6e22e>s</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>)
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkswitch</span>(<span style=color:#a6e22e>sw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>)
</code></pre></div><p>这些用于遍历抽象语法树的函数会将一些关键字和内建函数转换成函数调用，例如： 上述函数会将 <code>panic</code>、<code>recover</code> 两个内建函数转换成 <a href=/golang/tree/runtime.gopanic><code>runtime.gopanic</code></a> 和 <a href=/golang/tree/runtime.gorecover><code>runtime.gorecover</code></a> 两个真正运行时函数，而关键字 <code>new</code> 也会被转换成调用 <a href=/golang/tree/runtime.newobject><code>runtime.newobject</code></a> 函数。</p><p><img src=https://img.draveness.me/2019-02-05-golang-keyword-and-builtin-mapping.png alt=golang-keyword-and-builtin-mapping></p><p><strong>图 2-13 关键字和操作符和运行时函数的映射</strong></p><p>上图是从关键字或内建函数到运行时函数的映射，其中涉及 Channel、哈希、<code>make</code>、<code>new</code> 关键字以及控制流中的关键字 <code>select</code> 等。转换后的全部函数都属于运行时包，我们能在 <a href=https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/builtin/runtime.go><code>src/cmd/compile/internal/gc/builtin/runtime.go</code></a> 文件中找到函数对应的签名和定义。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makemap64</span>(<span style=color:#a6e22e>mapType</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>hint</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>mapbuf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>any</span>) (<span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>any</span>]<span style=color:#a6e22e>any</span>)
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makemap</span>(<span style=color:#a6e22e>mapType</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>hint</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>mapbuf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>any</span>) (<span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>any</span>]<span style=color:#a6e22e>any</span>)
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makemap_small</span>() (<span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>any</span>]<span style=color:#a6e22e>any</span>)
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapaccess1</span>(<span style=color:#a6e22e>mapType</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>any</span>]<span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>key</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>any</span>) (<span style=color:#a6e22e>val</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>any</span>)
<span style=color:#f92672>...</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makechan64</span>(<span style=color:#a6e22e>chanType</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int64</span>) (<span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>any</span>)
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makechan</span>(<span style=color:#a6e22e>chanType</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>any</span>)
<span style=color:#f92672>...</span>
</code></pre></div><p>这里的定义只是让 Go 语言完成编译，它们的实现都在另一个 <a href=https://github.com/golang/go/tree/master/src/runtime><code>runtime</code></a> 包中。简单总结一下，编译器会将 Go 语言关键字转换成运行时包中的函数，也就是说关键字和内置函数的功能是由编译器和运行时共同完成的。</p><p>我们简单了解一下遍历节点时几个 Channel 操作是如何转换成运行时对应方法的，首先介绍向 Channel 发送消息或者从 Channel 接收消息两个操作，编译器会分别使用 <code>OSEND</code> 和 <code>ORECV</code> 表示发送和接收消息两个操作，在 <a href=/golang/tree/cmd/compile/internal/gc.walkexpr><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中会根据节点类型的不同进入不同的分支：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkexpr</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OSEND</span>:
		<span style=color:#a6e22e>n1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>
		<span style=color:#a6e22e>n1</span> = <span style=color:#a6e22e>assignconv</span>(<span style=color:#a6e22e>n1</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>Elem</span>(), <span style=color:#e6db74>&#34;chan send&#34;</span>)
		<span style=color:#a6e22e>n1</span> = <span style=color:#a6e22e>walkexpr</span>(<span style=color:#a6e22e>n1</span>, <span style=color:#a6e22e>init</span>)
		<span style=color:#a6e22e>n1</span> = <span style=color:#a6e22e>nod</span>(<span style=color:#a6e22e>OADDR</span>, <span style=color:#a6e22e>n1</span>, <span style=color:#66d9ef>nil</span>)
		<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>mkcall1</span>(<span style=color:#a6e22e>chanfn</span>(<span style=color:#e6db74>&#34;chansend1&#34;</span>, <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>), <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>init</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>n1</span>)
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>当遇到 <code>OSEND</code> 操作时，会使用 <a href=/golang/tree/cmd/compile/internal/gc.mkcall1><code>cmd/compile/internal/gc.mkcall1</code></a> 创建一个操作为 <code>OCALL</code> 的节点，这个节点包含当前调用的函数 <a href=/golang/tree/runtime.chansend1><code>runtime.chansend1</code></a> 和参数，新的 <code>OCALL</code> 节点会替换当前的 <code>OSEND</code> 节点，这就完成了对 <code>OSEND</code> 子树的改写。</p><p><img src=https://img.draveness.me/2019-12-23-15771129929846-golang-ocall-node.png alt=golang-ocall-node></p><p><strong>图 2-14 改写后的 Channel 发送操作</strong></p><p>在中间代码生成的阶段遇到 <code>ORECV</code> 操作时，编译器的处理与遇到 <code>OSEND</code> 时相差无几，我们只是将 <a href=/golang/tree/runtime.chansend1><code>runtime.chansend1</code></a> 换成了 <a href=/golang/tree/runtime.chanrecv1><code>runtime.chanrecv1</code></a>，其他的参数没有发生太大的变化：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>		<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>mkcall1</span>(<span style=color:#a6e22e>chanfn</span>(<span style=color:#e6db74>&#34;chanrecv1&#34;</span>, <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>), <span style=color:#66d9ef>nil</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>init</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>nodnil</span>())
</code></pre></div><p>使用 <code>close</code> 关键字的 <code>OCLOSE</code> 操作也会在 <a href=/golang/tree/cmd/compile/internal/gc.walkexpr><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中被转换成调用 <a href=/golang/tree/runtime.closechan><code>runtime.closechan</code></a> 的 <code>OCALL</code> 节点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>walkexpr</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>init</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Nodes</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OCLOSE</span>:
		<span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syslook</span>(<span style=color:#e6db74>&#34;closechan&#34;</span>)

		<span style=color:#a6e22e>fn</span> = <span style=color:#a6e22e>substArgTypes</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Type</span>)
		<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>mkcall1</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>init</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>)
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>编译器会在编译期间将 Channel 的这些内置操作转换成几个运行时函数，很多人都想要了解 Channel 底层的实现，但是并不知道函数的入口，通过本节的分析我们就知道 <a href=/golang/tree/runtime.chanrecv1><code>runtime.chanrecv1</code></a>、<a href=/golang/tree/runtime.chansend1><code>runtime.chansend1</code></a> 和 <a href=/golang/tree/runtime.closechan><code>runtime.closechan</code></a> 几个函数分别实现了 Channel 的接收、发送和关闭操作。</p><h2 id=244-ssa-生成>2.4.4 SSA 生成
<a class=anchor href=#244-ssa-%e7%94%9f%e6%88%90>#</a></h2><p>经过 <code>walk</code> 系列函数的处理之后，抽象语法树就不会改变了，Go 语言的编译器会使用 <a href=/golang/tree/cmd/compile/internal/gc.compileSSA><code>cmd/compile/internal/gc.compileSSA</code></a> 函数将抽象语法树转换成中间代码，我们可以先看一下该函数的简要实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>compileSSA</span>(<span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>worker</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>buildssa</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>worker</span>)
	<span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newProgs</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>worker</span>)
	<span style=color:#a6e22e>genssa</span>(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>pp</span>)

	<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>Flush</span>()
}
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/gc.buildssa><code>cmd/compile/internal/gc.buildssa</code></a> 负责生成具有 SSA 特性的中间代码，我们可以使用命令行工具来观察中间代码的生成过程，假设我们有以下的 Go 语言源代码，其中只包含一个简单的 <code>hello</code> 函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>hello</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
}
</code></pre></div><p>我们可以使用 <code>GOSSAFUNC</code> 环境变量构建上述代码并获取从源代码到最终的中间代码经历的几十次迭代，其中所有的数据都存储到了 <code>ssa.html</code> 文件中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#a6e22e>GOSSAFUNC</span>=<span style=color:#a6e22e>hello</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>build</span> <span style=color:#a6e22e>hello</span>.<span style=color:#66d9ef>go</span>
<span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>command</span><span style=color:#f92672>-</span><span style=color:#a6e22e>line</span><span style=color:#f92672>-</span><span style=color:#a6e22e>arguments</span>
<span style=color:#a6e22e>dumped</span> <span style=color:#a6e22e>SSA</span> <span style=color:#a6e22e>to</span> .<span style=color:#f92672>/</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>html</span>
</code></pre></div><p>上述文件中包含源代码对应的抽象语法树、几十个版本的中间代码以及最终生成的 SSA，在这里截取文件的一部分让各位读者简单了解该文件的内容：</p><p><img src=https://img.draveness.me/2019-12-23-15771129929852-ssa-html.png alt=ssa-htm></p><p><strong>图 2-15 SSA 中间代码生成过程</strong></p><p>如上图所示，其中最左侧就是源代码，中间是源代码生成的抽象语法树，最右侧是生成的第一轮中间代码，后面还有几十轮，感兴趣的读者可以自己尝试编译一下。<code>hello</code> 函数对应的抽象语法树会包含当前函数的 <code>Enter</code>、<code>NBody</code> 和 <code>Exit</code> 三个属性，<a href=/golang/tree/cmd/compile/internal/gc.buildssa><code>cmd/compile/internal/gc.buildssa</code></a> 函数会输出这些属性，你能从这个简化的逻辑中看到上述输出的影子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>buildssa</span>(<span style=color:#a6e22e>fn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>worker</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Func</span> {
	<span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>funcname</span>()
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>astBuf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> <span style=color:#a6e22e>state</span>

	<span style=color:#a6e22e>fe</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ssafn</span>{
		<span style=color:#a6e22e>curfn</span>: <span style=color:#a6e22e>fn</span>,
		<span style=color:#a6e22e>log</span>:   <span style=color:#a6e22e>printssa</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>ssaDumpStdout</span>,
	}
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>curfn</span> = <span style=color:#a6e22e>fn</span>

	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>f</span> = <span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>NewFunc</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>fe</span>)
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>config</span> = <span style=color:#a6e22e>ssaConfig</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Type</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Config</span> = <span style=color:#a6e22e>ssaConfig</span>

	<span style=color:#f92672>...</span>

	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>stmtList</span>(<span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Func</span>.<span style=color:#a6e22e>Enter</span>)
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>stmtList</span>(<span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Nbody</span>)

	<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Compile</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>f</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>f</span>
}
</code></pre></div><p><code>ssaConfig</code> 是我们在这里的第一小节初始化的结构体，其中包含了与 CPU 架构相关的函数和配置，随后的中间代码生成其实也分成两个阶段，第一阶段使用 <a href=/golang/tree/cmd/compile/internal/gc.state.stmtList><code>cmd/compile/internal/gc.state.stmtList</code></a> 以及相关函数将抽象语法树转换成中间代码，第二阶段调用 <a href=https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa><code>cmd/compile/internal/ssa</code></a> 包的 <a href=/golang/tree/cmd/compile/internal/ssa.Compile><code>cmd/compile/internal/ssa.Compile</code></a> 通过多轮迭代更新 SSA 中间代码。</p><h3 id=ast-到-ssa>AST 到 SSA
<a class=anchor href=#ast-%e5%88%b0-ssa>#</a></h3><p><a href=/golang/tree/cmd/compile/internal/gc.state.stmtList><code>cmd/compile/internal/gc.state.stmtList</code></a> 会为传入数组中的每个节点调用 <a href=/golang/tree/cmd/compile/internal/gc.state.stmt><code>cmd/compile/internal/gc.state.stmt</code></a> 方法，编译器会根据节点操作符的不同将当前 AST 节点转换成对应的中间代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>stmt</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OCALLMETH</span>, <span style=color:#a6e22e>OCALLINTER</span>:
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>callNormal</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>OCALLFUNC</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ONAME</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Class</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>PFUNC</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Sym</span>.<span style=color:#a6e22e>Name</span>; <span style=color:#a6e22e>compiling_runtime</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;throw&#34;</span> <span style=color:#f92672>||</span>
				<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Sym</span>.<span style=color:#a6e22e>Pkg</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Runtimepkg</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>fn</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;throwinit&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;gopanic&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;panicwrap&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;block&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;panicmakeslicelen&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;panicmakeslicecap&#34;</span>) {
				<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mem</span>()
				<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>endBlock</span>()
				<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Kind</span> = <span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>BlockExit</span>
				<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>SetControl</span>(<span style=color:#a6e22e>m</span>)
			}
		}
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>callDefer</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OGO</span>:
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>callGo</span>)
	<span style=color:#f92672>...</span>
	}
}
</code></pre></div><p>从上面节选的代码中我们会发现，在遇到函数调用、方法调用、使用 defer 或者 go 关键字时都会执行 <a href=/golang/tree/cmd/compile/internal/gc.state.callResult><code>cmd/compile/internal/gc.state.callResult</code></a> 和 <a href=/golang/tree/cmd/compile/internal/gc.state.call><code>cmd/compile/internal/gc.state.call</code></a> 生成调用函数的 SSA 节点，这些在开发者看来不同的概念在编译器中都会被实现成静态的函数调用，上层的关键字和方法只是语言为我们提供的语法糖：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>callResult</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>k</span> <span style=color:#a6e22e>callKind</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>k</span>, <span style=color:#66d9ef>false</span>)
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>state</span>) <span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>k</span> <span style=color:#a6e22e>callKind</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span> {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>call</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>Value</span>
	<span style=color:#66d9ef>switch</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>callDefer</span>:
		<span style=color:#a6e22e>call</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>newValue1A</span>(<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>OpStaticCall</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>TypeMem</span>, <span style=color:#a6e22e>deferproc</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mem</span>())
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>callGo</span>:
		<span style=color:#a6e22e>call</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>newValue1A</span>(<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>OpStaticCall</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>TypeMem</span>, <span style=color:#a6e22e>newproc</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mem</span>())
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>sym</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>:
		<span style=color:#a6e22e>call</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>newValue1A</span>(<span style=color:#a6e22e>ssa</span>.<span style=color:#a6e22e>OpStaticCall</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>TypeMem</span>, <span style=color:#a6e22e>sym</span>.<span style=color:#a6e22e>Linksym</span>(), <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>mem</span>())
	..
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>首先，从 AST 到 SSA 的转化过程中，编译器会生成将函数调用的参数放到栈上的中间代码，处理参数之后才会生成一条运行函数的命令 <code>ssa.OpStaticCall</code>：</p><ol><li>当使用 defer 关键字时，插入 <a href=/golang/tree/runtime.deferproc><code>runtime.deferproc</code></a> 函数；</li><li>当使用 go 关键字时，插入 <a href=/golang/tree/runtime.newproc><code>runtime.newproc</code></a> 函数符号；</li><li>在遇到其他情况时会插入表示普通函数对应的符号；</li></ol><p><a href=https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/ssa.go><code>cmd/compile/internal/gc/ssa.go</code></a> 这个拥有将近 7000 行代码的文件包含用于处理不同节点的各种方法，编译器会根据节点类型的不同在一个巨型 switch 语句处理不同的情况，这也是我们在编译器这种独特的场景下才能看到的现象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>compiling</span> <span style=color:#a6e22e>hello</span>
<span style=color:#a6e22e>hello</span> <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>
  <span style=color:#a6e22e>b1</span>:
    <span style=color:#a6e22e>v1</span> = <span style=color:#a6e22e>InitMem</span> &lt;<span style=color:#a6e22e>mem</span>&gt;
    <span style=color:#a6e22e>v2</span> = <span style=color:#a6e22e>SP</span> &lt;<span style=color:#66d9ef>uintptr</span>&gt;
    <span style=color:#a6e22e>v3</span> = <span style=color:#a6e22e>SB</span> &lt;<span style=color:#66d9ef>uintptr</span>&gt; <span style=color:#a6e22e>DEAD</span>
    <span style=color:#a6e22e>v4</span> = <span style=color:#a6e22e>LocalAddr</span> &lt;<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>&gt; {<span style=color:#a6e22e>a</span>} <span style=color:#a6e22e>v2</span> <span style=color:#a6e22e>v1</span> <span style=color:#a6e22e>DEAD</span>
    <span style=color:#a6e22e>v5</span> = <span style=color:#a6e22e>LocalAddr</span> &lt;<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>&gt; {<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r1</span>} <span style=color:#a6e22e>v2</span> <span style=color:#a6e22e>v1</span>
    <span style=color:#a6e22e>v6</span> = <span style=color:#a6e22e>Arg</span> &lt;<span style=color:#66d9ef>int</span>&gt; {<span style=color:#a6e22e>a</span>}
    <span style=color:#a6e22e>v7</span> = <span style=color:#a6e22e>Const64</span> &lt;<span style=color:#66d9ef>int</span>&gt; [<span style=color:#ae81ff>0</span>] <span style=color:#a6e22e>DEAD</span>
    <span style=color:#a6e22e>v8</span> = <span style=color:#a6e22e>Const64</span> &lt;<span style=color:#66d9ef>int</span>&gt; [<span style=color:#ae81ff>2</span>]
    <span style=color:#a6e22e>v9</span> = <span style=color:#a6e22e>Add64</span> &lt;<span style=color:#66d9ef>int</span>&gt; <span style=color:#a6e22e>v6</span> <span style=color:#a6e22e>v8</span> (<span style=color:#a6e22e>c</span>[<span style=color:#66d9ef>int</span>])
    <span style=color:#a6e22e>v10</span> = <span style=color:#a6e22e>VarDef</span> &lt;<span style=color:#a6e22e>mem</span>&gt; {<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r1</span>} <span style=color:#a6e22e>v1</span>
    <span style=color:#a6e22e>v11</span> = <span style=color:#a6e22e>Store</span> &lt;<span style=color:#a6e22e>mem</span>&gt; {<span style=color:#66d9ef>int</span>} <span style=color:#a6e22e>v5</span> <span style=color:#a6e22e>v9</span> <span style=color:#a6e22e>v10</span>
    <span style=color:#a6e22e>Ret</span> <span style=color:#a6e22e>v11</span>
</code></pre></div><p>上述代码就是在这个过程生成的，你可以看到中间代码主体中的每一行都定义了一个新的变量，这是我们在前面提到的具有静态单赋值（SSA）特性的中间代码，如果你使用 <code>GOSSAFUNC=hello go build hello.go</code> 命令亲自编译一下会对这种中间代码有更深的印象。</p><h3 id=多轮转换>多轮转换
<a class=anchor href=#%e5%a4%9a%e8%bd%ae%e8%bd%ac%e6%8d%a2>#</a></h3><p>虽然我们在 <a href=/golang/tree/cmd/compile/internal/gc.state.stmt><code>cmd/compile/internal/gc.state.stmt</code></a> 以及相关方法中生成了 SSA 中间代码，但是这些中间代码仍然需要编译器优化以去掉无用代码并精简操作数，编译器优化中间代码的过程都是由 <a href=/golang/tree/cmd/compile/internal/ssa.Compile><code>cmd/compile/internal/ssa.Compile</code></a> 函数执行的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Compile</span>(<span style=color:#a6e22e>f</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Func</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Log</span>() {
		<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Logf</span>(<span style=color:#e6db74>&#34;compiling %s\n&#34;</span>, <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Name</span>)
	}

	<span style=color:#a6e22e>phaseName</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;init&#34;</span>

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>passes</span> {
		<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>pass</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>fn</span>(<span style=color:#a6e22e>f</span>)
	}

	<span style=color:#a6e22e>phaseName</span> = <span style=color:#e6db74>&#34;&#34;</span>
}
</code></pre></div><p>上述函数删除了很多打印日志和性能分析的代码，SSA 需要经历的多轮处理也都保存在了 <code>passes</code> 变量中，这个变量中存储了每一轮处理的名字、使用的函数以及表示是否必要的 <code>required</code> 字段：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>passes</span> = [<span style=color:#f92672>...</span>]<span style=color:#a6e22e>pass</span>{
	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;number lines&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>numberLines</span>, <span style=color:#a6e22e>required</span>: <span style=color:#66d9ef>true</span>},
	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;early phielim&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>phielim</span>},
	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;early copyelim&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>copyelim</span>},
	<span style=color:#f92672>...</span>
	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;loop rotate&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>loopRotate</span>},
	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;stackframe&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>stackframe</span>, <span style=color:#a6e22e>required</span>: <span style=color:#66d9ef>true</span>},
	{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;trim&#34;</span>, <span style=color:#a6e22e>fn</span>: <span style=color:#a6e22e>trim</span>},
}
</code></pre></div><p>目前的编译器总共引入了将近 50 个需要执行的过程，我们能在 <code>GOSSAFUNC=hello go build hello.go</code> 命令生成的文件中看到每一轮处理后的中间代码，例如最后一个 <code>trim</code> 阶段就生成了如下的 SSA 代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>  <span style=color:#a6e22e>pass</span> <span style=color:#a6e22e>trim</span> <span style=color:#a6e22e>begin</span>
  <span style=color:#a6e22e>pass</span> <span style=color:#a6e22e>trim</span> <span style=color:#a6e22e>end</span> [<span style=color:#ae81ff>738</span> <span style=color:#a6e22e>ns</span>]
<span style=color:#a6e22e>hello</span> <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>
  <span style=color:#a6e22e>b1</span>:
    <span style=color:#a6e22e>v1</span> = <span style=color:#a6e22e>InitMem</span> &lt;<span style=color:#a6e22e>mem</span>&gt;
    <span style=color:#a6e22e>v10</span> = <span style=color:#a6e22e>VarDef</span> &lt;<span style=color:#a6e22e>mem</span>&gt; {<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r1</span>} <span style=color:#a6e22e>v1</span>
    <span style=color:#a6e22e>v2</span> = <span style=color:#a6e22e>SP</span> &lt;<span style=color:#66d9ef>uintptr</span>&gt; : <span style=color:#a6e22e>SP</span>
    <span style=color:#a6e22e>v6</span> = <span style=color:#a6e22e>Arg</span> &lt;<span style=color:#66d9ef>int</span>&gt; {<span style=color:#a6e22e>a</span>} : <span style=color:#a6e22e>a</span>[<span style=color:#66d9ef>int</span>]
    <span style=color:#a6e22e>v8</span> = <span style=color:#a6e22e>LoadReg</span> &lt;<span style=color:#66d9ef>int</span>&gt; <span style=color:#a6e22e>v6</span> : <span style=color:#a6e22e>AX</span>
    <span style=color:#a6e22e>v9</span> = <span style=color:#a6e22e>ADDQconst</span> &lt;<span style=color:#66d9ef>int</span>&gt; [<span style=color:#ae81ff>2</span>] <span style=color:#a6e22e>v8</span> : <span style=color:#a6e22e>AX</span> (<span style=color:#a6e22e>c</span>[<span style=color:#66d9ef>int</span>])
    <span style=color:#a6e22e>v11</span> = <span style=color:#a6e22e>MOVQstore</span> &lt;<span style=color:#a6e22e>mem</span>&gt; {<span style=color:#960050;background-color:#1e0010>~</span><span style=color:#a6e22e>r1</span>} <span style=color:#a6e22e>v2</span> <span style=color:#a6e22e>v9</span> <span style=color:#a6e22e>v10</span>
    <span style=color:#a6e22e>Ret</span> <span style=color:#a6e22e>v11</span>
</code></pre></div><p>经过将近 50 轮处理的中间代码相比处理之前有了非常大的改变，执行效率会有比较大的提升，多轮的处理已经包含了一些机器特定的修改，包括根据目标架构对代码进行改写，不过这里就不会展开介绍每一轮处理的内容了。</p><h2 id=245-小结>2.4.5 小结
<a class=anchor href=#245-%e5%b0%8f%e7%bb%93>#</a></h2><p>中间代码的生成过程是从 AST 抽象语法树到 SSA 中间代码的转换过程，在这期间会对语法树中的关键字再进行改写，改写后的语法树会经过多轮处理转变成最后的 SSA 中间代码，相关代码中包括了大量 switch 语句、复杂的函数和调用栈，阅读和分析起来也非常困难。</p><p>很多 Go 语言中的关键字和内置函数都是在这个阶段被转换成运行时包中方法的，作者在后面的章节会从具体的语言关键字和内置函数的角度介绍一些数据结构和内置函数的实现。</p><p><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/ class=book-btn>上一节</a>
<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>中间代码，也被翻译成中间表示，即 Intermediate representation <a href=https://en.wikipedia.org/wiki/Intermediate_representation>https://en.wikipedia.org/wiki/Intermediate_representation</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>应用程序二进制接口，Application Binary Interface（ABI） <a href=https://en.wikipedia.org/wiki/Application_binary_interface>https://en.wikipedia.org/wiki/Application_binary_interface</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-ir-ssa data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-ir-ssa",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#24-中间代码生成>2.4 中间代码生成</a><ul><li><a href=#241-概述>2.4.1 概述</a></li><li><a href=#242-配置初始化>2.4.2 配置初始化</a></li><li><a href=#243-遍历和替换>2.4.3 遍历和替换</a></li><li><a href=#244-ssa-生成>2.4.4 SSA 生成</a><ul><li><a href=#ast-到-ssa>AST 到 SSA</a></li><li><a href=#多轮转换>多轮转换</a></li></ul></li><li><a href=#245-小结>2.4.5 小结</a></li></ul></li></ul></nav></aside></main></body></html>