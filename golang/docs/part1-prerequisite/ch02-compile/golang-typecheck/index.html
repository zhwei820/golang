<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="2.3 类型检查 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  我们在上一节中介绍了 Go 语言编译的第一个阶段 — 通过词法和语法分析器的解析得到了抽象语法树，本节会继续介绍编译器执行的下一个阶段 — 类型检查。
提到类型检查和编程语言的类型系统，很多朋友可能会想到几个有些模糊并且不好理解的术语：强类型、弱类型、静态类型和动态类型。但是我们既然要谈到 Go 语言编译器的类型检查过程，我们接下来就彻底搞清楚这几个『类型』的含义与异同。
2.3.1 强弱类型 #  强类型和弱类型1经常会被放在一起讨论，然而这两者并没有一个学术上的严格定义，多查阅些资料理解起来反而更加困难，很多资料甚至相互矛盾。
图 2-10 强类型和弱类型
由于权威的定义的缺失，对于强弱类型，我们很多时候也只能根据现象和特性从直觉上进行判断，一般会有如下结论2：
 强类型的编程语言在编译期间会有更严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误； 弱类型的编程语言在出现类型错误时可能会在运行时进行隐式的类型转换，在类型转换时可能会造成运行错误。  依据上面的结论，我们就可以认为 Java、C# 等在编译期间进行类型检查的编程语言是强类型的。同样地，因为 Go 语言会在编译期间发现类型错误，也应该是强类型的编程语言。
如果强类型与弱类型这一对概念定义不严格且有歧义，那么在概念上较真本身是没有太多太多实际价值的，起码对于我们真正使用和理解编程语言帮助不大。问题来了，作为一种抽象的定义，我们使用它是为了什么呢？答案是，更多时候是为了方便沟通和分类。让我们忽略强弱类型，把更多注意力放到下面的问题上：
 类型的转换是显式的还是隐式的？ 编译器会帮助我们推断变量的类型么？  这些具体的问题在这种语境下其实更有价值，也希望各位读者能够减少对强弱类型的争执。
2.3.2 静态类型与动态类型 #  静态类型和动态类型的编程语言其实也是两个不精确的表述，正确的表达应该是使用静态类型检查和动态类型检查的编程语言，这一小节会分别介绍两种类型检查的特点以及它们的区别。
静态类型检查 #  静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程3，如果我们的代码能够通过静态类型检查，那么当前程序在一定程度上可以满足类型安全的要求，它能够减少程序在运行时的类型检查，也可以被看作是一种代码优化的方式。
作为一个开发者来说，静态类型检查能够帮助我们在编译期间发现程序中出现的类型错误，一些动态类型的编程语言都会有社区提供的工具为这些编程语言加入静态类型检查，例如 JavaScript 的 Flow4，这些工具能够在编译期间发现代码中的类型错误。
相信很多读者也都听过『动态类型一时爽，代码重构火葬场』5，使用 Python、Ruby 等编程语言的开发者一定对这句话深有体会，静态类型为代码在编译期间提供了约束，编译器能够在编译期间约束变量的类型。
静态类型检查在重构时能够帮助我们节省大量时间并避免遗漏，但是如果编程语言仅支持动态类型检查，那么就需要写大量的单元测试保证重构不会出现类型错误。当然这里并不是说测试不重要，我们写的任何代码都应该有良好的测试，这与语言没有太多的关系。
动态类型检查 #  动态类型检查是在运行时确定程序类型安全的过程，它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性6。动态类型检查能为工程师提供更多的操作空间，让我们能在运行时获取一些类型相关的上下文并根据对象的类型完成一些动态操作。
只使用动态类型检查的编程语言叫做动态类型编程语言，常见的动态类型编程语言就包括 JavaScript、Ruby 和 PHP，虽然这些编程语言在使用上非常灵活也不需要经过编译，但是有问题的代码该不会因为更加灵活就会减少错误，该出错时仍然会出错，它们在提高灵活性的同时，也提高了对工程师的要求。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Go 语言如何进行类型检查"><meta property="og:description" content="2.3 类型检查 #    各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 链接 购买。  我们在上一节中介绍了 Go 语言编译的第一个阶段 — 通过词法和语法分析器的解析得到了抽象语法树，本节会继续介绍编译器执行的下一个阶段 — 类型检查。
提到类型检查和编程语言的类型系统，很多朋友可能会想到几个有些模糊并且不好理解的术语：强类型、弱类型、静态类型和动态类型。但是我们既然要谈到 Go 语言编译器的类型检查过程，我们接下来就彻底搞清楚这几个『类型』的含义与异同。
2.3.1 强弱类型 #  强类型和弱类型1经常会被放在一起讨论，然而这两者并没有一个学术上的严格定义，多查阅些资料理解起来反而更加困难，很多资料甚至相互矛盾。
图 2-10 强类型和弱类型
由于权威的定义的缺失，对于强弱类型，我们很多时候也只能根据现象和特性从直觉上进行判断，一般会有如下结论2：
 强类型的编程语言在编译期间会有更严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误； 弱类型的编程语言在出现类型错误时可能会在运行时进行隐式的类型转换，在类型转换时可能会造成运行错误。  依据上面的结论，我们就可以认为 Java、C# 等在编译期间进行类型检查的编程语言是强类型的。同样地，因为 Go 语言会在编译期间发现类型错误，也应该是强类型的编程语言。
如果强类型与弱类型这一对概念定义不严格且有歧义，那么在概念上较真本身是没有太多太多实际价值的，起码对于我们真正使用和理解编程语言帮助不大。问题来了，作为一种抽象的定义，我们使用它是为了什么呢？答案是，更多时候是为了方便沟通和分类。让我们忽略强弱类型，把更多注意力放到下面的问题上：
 类型的转换是显式的还是隐式的？ 编译器会帮助我们推断变量的类型么？  这些具体的问题在这种语境下其实更有价值，也希望各位读者能够减少对强弱类型的争执。
2.3.2 静态类型与动态类型 #  静态类型和动态类型的编程语言其实也是两个不精确的表述，正确的表达应该是使用静态类型检查和动态类型检查的编程语言，这一小节会分别介绍两种类型检查的特点以及它们的区别。
静态类型检查 #  静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程3，如果我们的代码能够通过静态类型检查，那么当前程序在一定程度上可以满足类型安全的要求，它能够减少程序在运行时的类型检查，也可以被看作是一种代码优化的方式。
作为一个开发者来说，静态类型检查能够帮助我们在编译期间发现程序中出现的类型错误，一些动态类型的编程语言都会有社区提供的工具为这些编程语言加入静态类型检查，例如 JavaScript 的 Flow4，这些工具能够在编译期间发现代码中的类型错误。
相信很多读者也都听过『动态类型一时爽，代码重构火葬场』5，使用 Python、Ruby 等编程语言的开发者一定对这句话深有体会，静态类型为代码在编译期间提供了约束，编译器能够在编译期间约束变量的类型。
静态类型检查在重构时能够帮助我们节省大量时间并避免遗漏，但是如果编程语言仅支持动态类型检查，那么就需要写大量的单元测试保证重构不会出现类型错误。当然这里并不是说测试不重要，我们写的任何代码都应该有良好的测试，这与语言没有太多的关系。
动态类型检查 #  动态类型检查是在运行时确定程序类型安全的过程，它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性6。动态类型检查能为工程师提供更多的操作空间，让我们能在运行时获取一些类型相关的上下文并根据对象的类型完成一些动态操作。
只使用动态类型检查的编程语言叫做动态类型编程语言，常见的动态类型编程语言就包括 JavaScript、Ruby 和 PHP，虽然这些编程语言在使用上非常灵活也不需要经过编译，但是有问题的代码该不会因为更加灵活就会减少错误，该出错时仍然会出错，它们在提高灵活性的同时，也提高了对工程师的要求。"><meta property="og:type" content="article"><meta property="og:url" content="/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/"><title>Go 语言如何进行类型检查 | Go 语言设计与实现</title><link rel=manifest href=/golang/manifest.json><link rel=icon href=/golang/favicon.png type=image/x-icon><link rel=stylesheet href=/golang/book.min.bf064a71a8e587ec4bfe3f4ec7da33e2110269e1cd15b03e0a984aa16eeec2ab.css integrity="sha256-vwZKcajlh+xL/j9Ox9oz4hECaeHNFbA+CphKoW7uwqs="><script defer src=/golang/cn.search.min.34d3810a1ddfff99eab3ef038758ed373d5fd740414a9cc58628e2785e18d378.js integrity="sha256-NNOBCh3f/5nqs+8Dh1jtNz1f10BBSpzFhijieF4Y03g="></script><script type=text/javascript>!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");gio('init','a78e562f3dfff84c',{});gio('send');</script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/golang><span>Go 语言设计与实现</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/golang-book-release>购买纸质书</a></li><li><a href=>面向信仰编程</a></li><li><a href=https://github.com/draveness>GitHub</a></li><li><a href=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png>微信公众号</a></li><li><a href=https://twitter.com/draven0xff>Twitter</a></li><li><a href=https://weibo.com/u/5123574960>Weibo</a></li></ul><hr><ul><li>第一部分 预备知识<ul><li>第一章 准备工作<ul><li><a href=/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/>1.1 调试源代码</a></li></ul></li><li>第二章 编译原理<ul><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 编译过程</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>2.2 词法分析和语法分析</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/>2.3 类型检查</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>2.4 中间代码生成</a></li><li><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/>2.5 机器码生成</a></li></ul></li></ul></li></ul><ul><li>第二部分 基础知识<ul><li>第三章 数据结构<ul><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array/>3.1 数组</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/>3.2 切片</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>3.3 哈希表</a></li><li><a href=/golang/docs/part2-foundation/ch03-datastructure/golang-string/>3.4 字符串</a></li></ul></li><li>第四章 语言基础<ul><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-function-call/>4.1 函数调用</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-interface/>4.2 接口</a></li><li><a href=/golang/docs/part2-foundation/ch04-basic/golang-reflect/>4.3 反射</a></li></ul></li><li>第五章 常用关键字<ul><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-for-range/>5.1 for 和 range</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-select/>5.2 select</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-defer/>5.3 defer</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>5.4 panic 和 recover</a></li><li><a href=/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/>5.5 make 和 new</a></li></ul></li></ul></li><li>第三部分 运行时<ul><li>第六章 并发编程<ul><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-context/>6.1 上下文 Context</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/>6.2 同步原语与锁</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-timer/>6.3 定时器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>6.4 Channel</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>6.5 调度器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/>6.6 网络轮询器</a></li><li><a href=/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/>6.7 系统监控</a></li></ul></li><li>第七章 内存管理<ul><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>7.1 内存分配器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/>7.2 垃圾收集器</a></li><li><a href=/golang/docs/part3-runtime/ch07-memory/golang-stack-management/>7.3 栈内存管理</a></li></ul></li></ul></li><li>第四部分 进阶内容<ul><li>第八章 元编程<ul><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/>8.1 插件系统</a></li><li><a href=/golang/docs/part4-advanced/ch08-metaprogramming/golang-code-gen/>8.2 代码生成</a></li></ul></li><li>第九章 标准库<ul><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-json/>9.1 JSON</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/>9.2 HTTP</a></li><li><a href=/golang/docs/part4-advanced/ch09-stdlib/golang-database-sql/>9.3 数据库</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/golang/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go 语言如何进行类型检查</strong>
<label for=toc-control><img src=/golang/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#23-类型检查>2.3 类型检查</a><ul><li><a href=#231-强弱类型>2.3.1 强弱类型</a></li><li><a href=#232-静态类型与动态类型>2.3.2 静态类型与动态类型</a><ul><li><a href=#静态类型检查>静态类型检查</a></li><li><a href=#动态类型检查>动态类型检查</a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#233-执行过程>2.3.3 执行过程</a><ul><li><a href=#切片-otarray>切片 OTARRAY</a></li><li><a href=#哈希-otmap>哈希 OTMAP</a></li><li><a href=#关键字-omake>关键字 OMAKE</a></li></ul></li><li><a href=#234-小结>2.3.4 小结</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=23-类型检查>2.3 类型检查
<a class=anchor href=#23-%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5>#</a></h1><blockquote><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！《Go语言设计与实现》的纸质版图书已经上架京东，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>购买。</p></blockquote><p>我们在上一节中介绍了 Go 语言编译的第一个阶段 — 通过<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/>词法和语法分析器</a>的解析得到了抽象语法树，本节会继续介绍编译器执行的下一个阶段 — 类型检查。</p><p>提到类型检查和编程语言的类型系统，很多朋友可能会想到几个有些模糊并且不好理解的术语：强类型、弱类型、静态类型和动态类型。但是我们既然要谈到 Go 语言编译器的类型检查过程，我们接下来就彻底搞清楚这几个『类型』的含义与异同。</p><h2 id=231-强弱类型>2.3.1 强弱类型
<a class=anchor href=#231-%e5%bc%ba%e5%bc%b1%e7%b1%bb%e5%9e%8b>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Strong_and_weak_typing>强类型和弱类型</a><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>经常会被放在一起讨论，然而这两者并没有一个学术上的严格定义，多查阅些资料理解起来反而更加困难，很多资料甚至相互矛盾。</p><p><img src=https://img.draveness.me/2019-12-22-15770067978360-strong-and-weak-typing.png alt=strong-and-weak-typing></p><p><strong>图 2-10 强类型和弱类型</strong></p><p>由于权威的定义的缺失，对于强弱类型，我们很多时候也只能根据现象和特性从直觉上进行判断，一般会有如下结论<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>：</p><ul><li>强类型的编程语言在编译期间会有更严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误；</li><li>弱类型的编程语言在出现类型错误时可能会在运行时进行隐式的类型转换，在类型转换时可能会造成运行错误。</li></ul><p>依据上面的结论，我们就可以认为 Java、C# 等在编译期间进行类型检查的编程语言是强类型的。同样地，因为 Go 语言会在编译期间发现类型错误，也应该是强类型的编程语言。</p><p>如果强类型与弱类型这一对概念定义不严格且有歧义，那么在概念上较真本身是没有太多太多实际价值的，起码对于我们真正使用和理解编程语言帮助不大。问题来了，作为一种抽象的定义，我们使用它是为了什么呢？答案是，更多时候是为了方便沟通和分类。让我们忽略强弱类型，把更多注意力放到下面的问题上：</p><ul><li>类型的转换是显式的还是隐式的？</li><li>编译器会帮助我们推断变量的类型么？</li></ul><p>这些具体的问题在这种语境下其实更有价值，也希望各位读者能够减少对强弱类型的争执。</p><h2 id=232-静态类型与动态类型>2.3.2 静态类型与动态类型
<a class=anchor href=#232-%e9%9d%99%e6%80%81%e7%b1%bb%e5%9e%8b%e4%b8%8e%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b>#</a></h2><p>静态类型和动态类型的编程语言其实也是两个不精确的表述，正确的表达应该是使用<a href=https://en.wikipedia.org/wiki/Type_system#Static_type_checking>静态类型检查</a>和<a href=https://en.wikipedia.org/wiki/Type_system#Dynamic_type_checking_and_runtime_type_information>动态类型检查</a>的编程语言，这一小节会分别介绍两种类型检查的特点以及它们的区别。</p><h3 id=静态类型检查>静态类型检查
<a class=anchor href=#%e9%9d%99%e6%80%81%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5>#</a></h3><p>静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，如果我们的代码能够通过静态类型检查，那么当前程序在一定程度上可以满足类型安全的要求，它能够减少程序在运行时的类型检查，也可以被看作是一种代码优化的方式。</p><p>作为一个开发者来说，静态类型检查能够帮助我们在编译期间发现程序中出现的类型错误，一些动态类型的编程语言都会有社区提供的工具为这些编程语言加入静态类型检查，例如 JavaScript 的 <a href=https://flow.org/>Flow</a><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>，这些工具能够在编译期间发现代码中的类型错误。</p><p>相信很多读者也都听过『动态类型一时爽，代码重构火葬场』<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>，使用 Python、Ruby 等编程语言的开发者一定对这句话深有体会，静态类型为代码在编译期间提供了约束，编译器能够在编译期间约束变量的类型。</p><p>静态类型检查在重构时能够帮助我们节省大量时间并避免遗漏，但是如果编程语言仅支持动态类型检查，那么就需要写大量的单元测试保证重构不会出现类型错误。当然这里并不是说测试不重要，我们写的<strong>任何代码都应该有良好的测试</strong>，这与语言没有太多的关系。</p><h3 id=动态类型检查>动态类型检查
<a class=anchor href=#%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5>#</a></h3><p>动态类型检查是在运行时确定程序类型安全的过程，它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>。动态类型检查能为工程师提供更多的操作空间，让我们能在运行时获取一些类型相关的上下文并根据对象的类型完成一些动态操作。</p><p>只使用动态类型检查的编程语言叫做动态类型编程语言，常见的动态类型编程语言就包括 JavaScript、Ruby 和 PHP，虽然这些编程语言在使用上非常灵活也不需要经过编译，但是有问题的代码该不会因为更加灵活就会减少错误，该出错时仍然会出错，它们在提高灵活性的同时，也提高了对工程师的要求。</p><h3 id=小结>小结
<a class=anchor href=#%e5%b0%8f%e7%bb%93>#</a></h3><p>静态类型检查和动态类型检查不是完全冲突和对立的，很多编程语言都会同时使用两种类型检查，例如：Java 不仅在编译期间提前检查类型发现类型错误，还为对象添加了类型信息，在运行时使用反射根据对象的类型动态地执行方法增强灵活性并减少冗余代码。</p><h2 id=233-执行过程>2.3.3 执行过程
<a class=anchor href=#233-%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b>#</a></h2><p>Go 语言的编译器不仅使用静态类型检查来保证程序运行的类型安全，还会在编程期间引入类型信息，让工程师能够使用反射来判断参数和变量的类型。当我们想要将 <code>interface{}</code> 转换成具体类型时会进行动态类型检查，如果无法发生转换就会发生程序崩溃。</p><p>这里会重点介绍编译期间的静态类型检查，在 <a href=/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/>2.1 概述</a>中，我们曾经介绍过 Go 语言编译器主程序中的 <a href=/golang/tree/cmd/compile/internal/gc.Main><code>cmd/compile/internal/gc.Main</code></a> 函数，其中有一段是这样的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>xtop</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>xtop</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span>; <span style=color:#a6e22e>op</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>ODCL</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>OAS</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>OAS2</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>op</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>ODCLTYPE</span> <span style=color:#f92672>||</span> !<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Name</span>.<span style=color:#a6e22e>Param</span>.<span style=color:#a6e22e>Alias</span>) {
			<span style=color:#a6e22e>xtop</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>ctxStmt</span>)
		}
	}

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>xtop</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>xtop</span>[<span style=color:#a6e22e>i</span>]
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span>; <span style=color:#a6e22e>op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ODCL</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>OAS</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>OAS2</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ODCLTYPE</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Name</span>.<span style=color:#a6e22e>Param</span>.<span style=color:#a6e22e>Alias</span> {
			<span style=color:#a6e22e>xtop</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>ctxStmt</span>)
		}
	}

	<span style=color:#f92672>...</span>

	<span style=color:#a6e22e>checkMapKeys</span>()
</code></pre></div><p>这段代码的执行过程可以分成两个部分，首先通过 <a href=https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/typecheck.go><code>src/cmd/compile/internal/gc/typecheck.go</code></a> 文件中的 <a href=/golang/tree/cmd/compile/internal/gc.typecheck><code>cmd/compile/internal/gc.typecheck</code></a> 函数检查常量、类型、函数声明以及变量赋值语句的类型，然后使用 <a href=/golang/tree/cmd/compile/internal/gc.checkMapKeys><code>cmd/compile/internal/gc.checkMapKeys</code></a> 检查哈希中键的类型，我们会分几个部分对上述代码的实现原理进行分析。</p><p>编译器类型检查的主要逻辑都在 <a href=/golang/tree/cmd/compile/internal/gc.typecheck><code>cmd/compile/internal/gc.typecheck</code></a> 和 <a href=/golang/tree/cmd/compile/internal/gc.typecheck1><code>cmd/compile/internal/gc.typecheck1</code></a> 这中，其中 <a href=/golang/tree/cmd/compile/internal/gc.typecheck><code>cmd/compile/internal/gc.typecheck</code></a> 中逻辑不是特别多，它会做一些类型检查之前的准备工作。而核心的逻辑都在 <a href=/golang/tree/cmd/compile/internal/gc.typecheck1><code>cmd/compile/internal/gc.typecheck1</code></a> 中，这是由 switch 语句构成的 2000 行函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>typecheck1</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>, <span style=color:#a6e22e>top</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>res</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OTARRAY</span>:
		<span style=color:#f92672>...</span>

	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OTMAP</span>:
		<span style=color:#f92672>...</span>

	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OTCHAN</span>:
		<span style=color:#f92672>...</span>
	}

	<span style=color:#f92672>...</span>

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
}
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/gc.typecheck1><code>cmd/compile/internal/gc.typecheck1</code></a> 根据传入节点 Op 的类型进入不同的分支，其中包括加减乘数等操作符、函数调用、方法调用等 150 多种，因为节点的种类很多，所以这里只节选几个典型案例深入分析。</p><h3 id=切片-otarray>切片 OTARRAY
<a class=anchor href=#%e5%88%87%e7%89%87-otarray>#</a></h3><p>如果当前节点的操作类型是 <code>OTARRAY</code>，那么这个分支首先会对右节点，也就是切片或者数组中元素的类型进行类型检查：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OTARRAY</span>:
		<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>Etype</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Type</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
		}
</code></pre></div><p>然后会根据当前节点的左节点不同，分三种情况更新 <a href=/golang/tree/cmd/compile/internal/gc.Node><code>cmd/compile/internal/gc.Node</code></a> 的类型，即三种不同的声明方式 <code>[]int</code>、<code>[...]int</code> 和 <code>[3]int</code>，第一种相对来说比较简单，会直接调用 <a href=/golang/tree/cmd/compile/internal/types.NewSlice><code>cmd/compile/internal/types.NewSlice</code></a>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>t</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewSlice</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Type</span>)
</code></pre></div><p><a href=/golang/tree/cmd/compile/internal/types.NewSlice><code>cmd/compile/internal/types.NewSlice</code></a> 直接返回了一个 <code>TSLICE</code> 类型的结构体，元素的类型信息也会存储在结构体中。当遇到 <code>[...]int</code> 这种形式的数组类型时，会由 <a href=/golang/tree/cmd/compile/internal/gc.typecheckcomplit><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 处理：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>typecheckcomplit</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) (<span style=color:#a6e22e>res</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) {
	<span style=color:#f92672>...</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>OTARRAY</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Op</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>ODDD</span> {
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>ctxType</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Type</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
		}
		<span style=color:#a6e22e>elemType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Right</span>.<span style=color:#a6e22e>Type</span>

		<span style=color:#a6e22e>length</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheckarraylit</span>(<span style=color:#a6e22e>elemType</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Slice</span>(), <span style=color:#e6db74>&#34;array literal&#34;</span>)

		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> = <span style=color:#a6e22e>OARRAYLIT</span>
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewArray</span>(<span style=color:#a6e22e>elemType</span>, <span style=color:#a6e22e>length</span>)
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
	}
	<span style=color:#f92672>...</span>
}
</code></pre></div><p>在最后，如果源代码中包含了数组的大小，那么会调用 <a href=/golang/tree/cmd/compile/internal/types.NewArray><code>cmd/compile/internal/types.NewArray</code></a> 初始化一个存储着数组中元素类型和数组大小的结构体：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>indexlit</span>(<span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>ctxExpr</span>))
			<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>
			<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Val</span>()
			<span style=color:#a6e22e>bound</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>U</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>Mpint</span>).<span style=color:#a6e22e>Int64</span>()
			<span style=color:#a6e22e>t</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewArray</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>bound</span>)		}

		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> = <span style=color:#a6e22e>OTYPE</span>
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#a6e22e>t</span>
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#66d9ef>nil</span>
</code></pre></div><p>三个不同的分支会分别处理数组和切片声明的不同形式，每一个分支都会更新 <a href=/golang/tree/cmd/compile/internal/gc.Node><code>cmd/compile/internal/gc.Node</code></a> 结构体中存储的类型并修改抽象语法树中的内容。通过对这个片段的分析，我们发现数组的长度是类型检查期间确定的，而 <code>[...]int</code> 这种声明形式也只是 Go 语言为我们提供的语法糖。</p><h3 id=哈希-otmap>哈希 OTMAP
<a class=anchor href=#%e5%93%88%e5%b8%8c-otmap>#</a></h3><p>如果处理的节点是哈希，那么编译器会分别检查哈希的键值类型以验证它们类型的合法性：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OTMAP</span>:
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>Etype</span>)
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>Etype</span>)
		<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span>
		<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span>
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> = <span style=color:#a6e22e>OTYPE</span>
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>NewMap</span>(<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Type</span>)
		<span style=color:#a6e22e>mapqueue</span> = append(<span style=color:#a6e22e>mapqueue</span>, <span style=color:#a6e22e>n</span>)
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#66d9ef>nil</span>
</code></pre></div><p>与处理切片时几乎完全相同，这里会通过 <a href=/golang/tree/cmd/compile/internal/types.NewMap><code>cmd/compile/internal/types.NewMap</code></a> 创建一个新的 <code>TMAP</code> 结构并将哈希的键值类型都存储到该结构体中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewMap</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Type</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Type</span> {
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>TMAP</span>)
	<span style=color:#a6e22e>mt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>MapType</span>()
	<span style=color:#a6e22e>mt</span>.<span style=color:#a6e22e>Key</span> = <span style=color:#a6e22e>k</span>
	<span style=color:#a6e22e>mt</span>.<span style=color:#a6e22e>Elem</span> = <span style=color:#a6e22e>v</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>
}
</code></pre></div><p>代表当前哈希的节点最终也会被加入 <code>mapqueue</code> 队列，编译器会在后面的阶段对哈希键的类型进行再次检查，而检查键类型调用的其实是上面提到的 <a href=/golang/tree/cmd/compile/internal/gc.checkMapKeys><code>cmd/compile/internal/gc.checkMapKeys</code></a> 函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>checkMapKeys</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>mapqueue</span> {
		<span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span>.<span style=color:#a6e22e>MapType</span>().<span style=color:#a6e22e>Key</span>
		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>k</span>.<span style=color:#a6e22e>Broke</span>() <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>IsComparable</span>(<span style=color:#a6e22e>k</span>) {
			<span style=color:#a6e22e>yyerrorl</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Pos</span>, <span style=color:#e6db74>&#34;invalid map key type %v&#34;</span>, <span style=color:#a6e22e>k</span>)
		}
	}
	<span style=color:#a6e22e>mapqueue</span> = <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>该函数会遍历 <code>mapqueue</code> 队列中等待检查的节点，判断这些类型能否作为哈希的键，如果当前类型不合法会在类型检查的阶段直接报错中止整个检查的过程。</p><h3 id=关键字-omake>关键字 OMAKE
<a class=anchor href=#%e5%85%b3%e9%94%ae%e5%ad%97-omake>#</a></h3><p>最后要介绍的是 Go 语言中很常见的内置函数 <code>make</code>，在类型检查阶段之前，无论是创建切片、哈希还是 Channel 用的都是 <code>make</code> 关键字，不过在类型检查阶段会根据创建的类型将 <code>make</code> 替换成特定的函数，后面<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>生成中间代码</a>的过程就不再会处理 <code>OMAKE</code> 类型的节点了，而是会依据生成的细分类型处理：</p><p><img src=https://img.draveness.me/2019-12-20-15768548776677-golang-keyword-make.png alt=golang-keyword-make></p><p><strong>图 2-4 类型检查阶段对 make 进行改写</strong></p><p>编译器会先检查关键字 <code>make</code> 的第一个类型参数，根据类型的不同进入不同分支，切片分支 <code>TSLICE</code>、哈希分支 <code>TMAP</code> 和 Channel 分支 <code>TCHAN</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>OMAKE</span>:
		<span style=color:#a6e22e>args</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Slice</span>()

		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>List</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#66d9ef>nil</span>)
		<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>0</span>]
		<span style=color:#a6e22e>l</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>Etype</span>)
		<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Type</span>

		<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Etype</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TSLICE</span>:
			<span style=color:#f92672>...</span>

		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TMAP</span>:
			<span style=color:#f92672>...</span>

		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TCHAN</span>:
			<span style=color:#f92672>...</span>
		}

		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#a6e22e>t</span>
</code></pre></div><p>如果 <code>make</code> 的第一个参数是切片类型，那么就会从参数中获取切片的长度 <code>len</code> 和容量 <code>cap</code> 并对这两个参数进行校验，其中包括：</p><ol><li>切片的长度参数是否被传入；</li><li>切片的长度必须要小于或者等于切片的容量；</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TSLICE</span>:
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> len(<span style=color:#a6e22e>args</span>) {
				<span style=color:#a6e22e>yyerror</span>(<span style=color:#e6db74>&#34;missing len argument to make(%v)&#34;</span>, <span style=color:#a6e22e>t</span>)
				<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#66d9ef>nil</span>
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
			}

			<span style=color:#a6e22e>l</span> = <span style=color:#a6e22e>args</span>[<span style=color:#a6e22e>i</span>]
			<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
			<span style=color:#a6e22e>l</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>ctxExpr</span>)
			<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>args</span>) {
				<span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>args</span>[<span style=color:#a6e22e>i</span>]
				<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
				<span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>ctxExpr</span>)
			}

			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>Isconst</span>(<span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>CTINT</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>Isconst</span>(<span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>CTINT</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Val</span>().<span style=color:#a6e22e>U</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>Mpint</span>).<span style=color:#a6e22e>Cmp</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Val</span>().<span style=color:#a6e22e>U</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>Mpint</span>)) &gt; <span style=color:#ae81ff>0</span> {
				<span style=color:#a6e22e>yyerror</span>(<span style=color:#e6db74>&#34;len larger than cap in make(%v)&#34;</span>, <span style=color:#a6e22e>t</span>)
				<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#66d9ef>nil</span>
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
			}

			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>l</span>
			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>r</span>
			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> = <span style=color:#a6e22e>OMAKESLICE</span>
</code></pre></div><p>除了对参数的数量和合法性进行校验，这段代码最后会将当前节点的操作 Op 改成 <code>OMAKESLICE</code>，方便后面编译阶段的处理。</p><p>第二种情况就是 <code>make</code> 的第一个参数是 <code>map</code> 类型，在这种情况下，第二个可选的参数就是哈希的初始大小，在默认情况下它的大小是 0，当前分支最后也会改变当前节点的 Op 属性：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TMAP</span>:
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>args</span>) {
				<span style=color:#a6e22e>l</span> = <span style=color:#a6e22e>args</span>[<span style=color:#a6e22e>i</span>]
				<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
				<span style=color:#a6e22e>l</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>ctxExpr</span>)
				<span style=color:#a6e22e>l</span> = <span style=color:#a6e22e>defaultlit</span>(<span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TINT</span>])
				<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>checkmake</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;size&#34;</span>, <span style=color:#a6e22e>l</span>) {
					<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#66d9ef>nil</span>
					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
				}
				<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>l</span>
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>nodintconst</span>(<span style=color:#ae81ff>0</span>)
			}
			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> = <span style=color:#a6e22e>OMAKEMAP</span>
</code></pre></div><p><code>make</code> 内置函数能够初始化的最后一种结构就是 <a href=/golang/docs/part3-runtime/ch06-concurrency/golang-channel/>Channel</a> 了，从下面的代码我们可以发现第二个参数表示的就是 Channel 的缓冲区大小，如果不存在第二个参数，那么会创建缓冲区大小为 0 的 Channel：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>TCHAN</span>:
			<span style=color:#a6e22e>l</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>args</span>) {
				<span style=color:#a6e22e>l</span> = <span style=color:#a6e22e>args</span>[<span style=color:#a6e22e>i</span>]
				<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
				<span style=color:#a6e22e>l</span> = <span style=color:#a6e22e>typecheck</span>(<span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>ctxExpr</span>)
				<span style=color:#a6e22e>l</span> = <span style=color:#a6e22e>defaultlit</span>(<span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>TINT</span>])
				<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>checkmake</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;buffer&#34;</span>, <span style=color:#a6e22e>l</span>) {
					<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Type</span> = <span style=color:#66d9ef>nil</span>
					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
				}
				<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>l</span>
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>nodintconst</span>(<span style=color:#ae81ff>0</span>)
			}
			<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span> = <span style=color:#a6e22e>OMAKECHAN</span>
</code></pre></div><p>在类型检查的过程中，无论 <code>make</code> 的第一个参数是什么类型，都会对当前节点的 Op 类型进行修改并且对传入参数的合法性进行一定的验证。</p><h2 id=234-小结>2.3.4 小结
<a class=anchor href=#234-%e5%b0%8f%e7%bb%93>#</a></h2><p>类型检查是 Go 语言编译的第二个阶段，在词法和语法分析之后我们得到了每个文件对应的抽象语法树，随后的类型检查会遍历抽象语法树中的节点，对每个节点的类型进行检验，找出其中存在的语法错误，在这个过程中也可能会对抽象语法树进行改写，这不仅能够去除一些不会被执行的代码、对代码进行优化以提高执行效率，而且也会修改 <code>make</code>、<code>new</code> 等关键字对应节点的操作类型。</p><p><code>make</code> 和 <code>new</code> 这些内置函数其实并不会直接对应某些函数的实现，它们会在编译期间被转换成真正存在的其他函数，我们在下一节<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/>中间代码生成</a>中会介绍编译器对它们做了什么。</p><p><a href=/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/ class=book-btn>上一节</a>
<a href=/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/ class=book-btn>下一节</a></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Strong and weak typing <a href=https://en.wikipedia.org/wiki/Strong_and_weak_typing>https://en.wikipedia.org/wiki/Strong_and_weak_typing</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Weak And Strong Typing <a href=https://wiki.c2.com/?WeakAndStrongTyping>https://wiki.c2.com/?WeakAndStrongTyping</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Type_system#Static_type_checking>https://en.wikipedia.org/wiki/Type_system#Static_type_checking</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>JavaScript 静态检查工具 <a href=https://flow.org/>https://flow.org/</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>为什么说“动态类型一时爽，代码重构火葬场”？ <a href=https://www.zhihu.com/question/30072490>https://www.zhihu.com/question/30072490</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Type_system#Dynamic_type_checking_and_runtime_type_information>https://en.wikipedia.org/wiki/Type_system#Dynamic_type_checking_and_runtime_type_information</a> <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"></div><h2>购买纸质书</h2><p>各位读者朋友，很高兴大家通过本博客学习 Go 语言，感谢一路相伴！ <a href=/golang>《Go语言设计与实现》</a> 的纸质版图书已经上架京东，本书目前已经四印，印数超过 10,000 册，有需要的朋友请点击 <a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA">链接 </a>或者下面的图片购买。</p><a href="https://union-click.jd.com/jdc?e=&p=JF8BAL8JK1olXDYCVlpeCEsQAl9MRANLAjZbERscSkAJHTdNTwcKBlMdBgABFksVB2wIG1wUQl9HCANtSABQA2hTHjBwD15qUVsVU01rX2oKXVcZbQcyV19eC0sTAWwPHGslXQEyAjBdCUoWAm4NH1wSbQcyVFlfDkkfBWsKGFkXWDYFVFdtfQhHRDtXTxlXbTYyV25tOEsnAF9KdV4QXw4HUAlVAU5DAmoMSQhGDgMBAVpcWEMSU2sLTlpBbQQDVVpUOA"><img src=https://img.draveness.me/16375090482882-golang-intro-1.png alt=golang-book-intro></a><div class="flex flex-wrap justify-between"></div><p><img width=70% style=width:70%;height:70%;!important src=https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png alt=wechat-account-qrcode></p><p>本作品采用<a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p><link rel=stylesheet href=/golang/assets/prism.css><script type=text/javascript src=/golang/assets/prism.js></script><script>(function(w,d,s,id){if(typeof(w.webpushr)!=='undefined')return;w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js,fjs=d.getElementsByTagName(s)[0];js=d.createElement(s);js.id=id;js.async=1;js.src="https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document,'script','webpushr-jssdk'));webpushr('setup',{'key':'BKEGOqbGDOw5cDK8oIeqPhiq0LKfd-U8kXuIdwc_qyR_AGs0QtzZFBICnOPmi9hnApzzdX0X0TXC-oJ1-nGupGY'});</script><script src=https://giscus.app/client.js data-repo=draveness/blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkxMDg1NzY3MTY=" data-category=Announcements data-category-id=DIC_kwDOBni_zM4COMft data-mapping=specific data-term=/golang-typecheck data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56898419-1','auto');ga('set','referrer','https://dive-deep-into-golang');ga('send',{hitType:'pageview',page:"\/golang-typecheck",source:'a-sip-of-golang'});</script><script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><footer class="site-footer clearfix"><style>.site-footer{position:relative;margin:1rem 0 0;padding:1rem 15px;font-family:open sans,sans-serif;font-size:1rem;line-height:1.75em;color:#bbc7cc}.site-footer a{color:#bbc7cc;text-decoration:none;font-weight:700}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.copyright{display:block;width:100%;float:left}</style><section class=copyright><a href=>面向信仰编程</a> &copy; 2014 - 2020 | <a href=http://beian.miit.gov.cn target=_blank>陕ICP备15004432号-2</a></section></footer></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#23-类型检查>2.3 类型检查</a><ul><li><a href=#231-强弱类型>2.3.1 强弱类型</a></li><li><a href=#232-静态类型与动态类型>2.3.2 静态类型与动态类型</a><ul><li><a href=#静态类型检查>静态类型检查</a></li><li><a href=#动态类型检查>动态类型检查</a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#233-执行过程>2.3.3 执行过程</a><ul><li><a href=#切片-otarray>切片 OTARRAY</a></li><li><a href=#哈希-otmap>哈希 OTMAP</a></li><li><a href=#关键字-omake>关键字 OMAKE</a></li></ul></li><li><a href=#234-小结>2.3.4 小结</a></li></ul></li></ul></nav></aside></main></body></html>